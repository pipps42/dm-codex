
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model NPC
 * 
 */
export type NPC = $Result.DefaultSelection<Prisma.$NPCPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Map
 * 
 */
export type Map = $Result.DefaultSelection<Prisma.$MapPayload>
/**
 * Model MapAnnotation
 * 
 */
export type MapAnnotation = $Result.DefaultSelection<Prisma.$MapAnnotationPayload>
/**
 * Model Monster
 * 
 */
export type Monster = $Result.DefaultSelection<Prisma.$MonsterPayload>
/**
 * Model Condition
 * 
 */
export type Condition = $Result.DefaultSelection<Prisma.$ConditionPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model EncounterParticipant
 * 
 */
export type EncounterParticipant = $Result.DefaultSelection<Prisma.$EncounterParticipantPayload>
/**
 * Model PlayerCharacter
 * 
 */
export type PlayerCharacter = $Result.DefaultSelection<Prisma.$PlayerCharacterPayload>
/**
 * Model Quest
 * 
 */
export type Quest = $Result.DefaultSelection<Prisma.$QuestPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model Chronicle
 * 
 */
export type Chronicle = $Result.DefaultSelection<Prisma.$ChroniclePayload>
/**
 * Model Interaction
 * 
 */
export type Interaction = $Result.DefaultSelection<Prisma.$InteractionPayload>
/**
 * Model MonsterCampaign
 * 
 */
export type MonsterCampaign = $Result.DefaultSelection<Prisma.$MonsterCampaignPayload>
/**
 * Model ItemCampaign
 * 
 */
export type ItemCampaign = $Result.DefaultSelection<Prisma.$ItemCampaignPayload>
/**
 * Model NPCLocation
 * 
 */
export type NPCLocation = $Result.DefaultSelection<Prisma.$NPCLocationPayload>
/**
 * Model QuestNPC
 * 
 */
export type QuestNPC = $Result.DefaultSelection<Prisma.$QuestNPCPayload>
/**
 * Model QuestLocation
 * 
 */
export type QuestLocation = $Result.DefaultSelection<Prisma.$QuestLocationPayload>
/**
 * Model ChronicleQuest
 * 
 */
export type ChronicleQuest = $Result.DefaultSelection<Prisma.$ChronicleQuestPayload>
/**
 * Model ItemLocation
 * 
 */
export type ItemLocation = $Result.DefaultSelection<Prisma.$ItemLocationPayload>
/**
 * Model ItemNPC
 * 
 */
export type ItemNPC = $Result.DefaultSelection<Prisma.$ItemNPCPayload>
/**
 * Model InteractionItem
 * 
 */
export type InteractionItem = $Result.DefaultSelection<Prisma.$InteractionItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CreatureType: {
  humanoid: 'humanoid',
  undead: 'undead',
  construct: 'construct',
  dragon: 'dragon',
  fey: 'fey',
  fiend: 'fiend',
  celestial: 'celestial',
  elemental: 'elemental',
  aberration: 'aberration',
  beast: 'beast',
  monstrosity: 'monstrosity',
  ooze: 'ooze',
  plant: 'plant',
  giant: 'giant'
};

export type CreatureType = (typeof CreatureType)[keyof typeof CreatureType]


export const Size: {
  tiny: 'tiny',
  small: 'small',
  medium: 'medium',
  large: 'large',
  huge: 'huge',
  gargantuan: 'gargantuan'
};

export type Size = (typeof Size)[keyof typeof Size]


export const Alignment: {
  lawful_good: 'lawful_good',
  neutral_good: 'neutral_good',
  chaotic_good: 'chaotic_good',
  lawful_neutral: 'lawful_neutral',
  true_neutral: 'true_neutral',
  chaotic_neutral: 'chaotic_neutral',
  lawful_evil: 'lawful_evil',
  neutral_evil: 'neutral_evil',
  chaotic_evil: 'chaotic_evil',
  unaligned: 'unaligned'
};

export type Alignment = (typeof Alignment)[keyof typeof Alignment]


export const Language: {
  common: 'common',
  dwarvish: 'dwarvish',
  elvish: 'elvish',
  giant: 'giant',
  gnomish: 'gnomish',
  goblin: 'goblin',
  halfling: 'halfling',
  orc: 'orc',
  abyssal: 'abyssal',
  celestial: 'celestial',
  draconic: 'draconic',
  deep_speech: 'deep_speech',
  infernal: 'infernal',
  primordial: 'primordial',
  sylvan: 'sylvan',
  undercommon: 'undercommon',
  thieves_cant: 'thieves_cant',
  druidic: 'druidic'
};

export type Language = (typeof Language)[keyof typeof Language]


export const CharacterClass: {
  barbarian: 'barbarian',
  bard: 'bard',
  cleric: 'cleric',
  druid: 'druid',
  fighter: 'fighter',
  monk: 'monk',
  paladin: 'paladin',
  ranger: 'ranger',
  rogue: 'rogue',
  sorcerer: 'sorcerer',
  warlock: 'warlock',
  wizard: 'wizard',
  artificer: 'artificer',
  blood_hunter: 'blood_hunter'
};

export type CharacterClass = (typeof CharacterClass)[keyof typeof CharacterClass]


export const Race: {
  human: 'human',
  elf: 'elf',
  dwarf: 'dwarf',
  halfling: 'halfling',
  dragonborn: 'dragonborn',
  gnome: 'gnome',
  half_elf: 'half_elf',
  half_orc: 'half_orc',
  tiefling: 'tiefling',
  aasimar: 'aasimar',
  firbolg: 'firbolg',
  goliath: 'goliath',
  kenku: 'kenku',
  tabaxi: 'tabaxi',
  triton: 'triton',
  yuan_ti: 'yuan_ti',
  tortle: 'tortle',
  changeling: 'changeling',
  kalashtar: 'kalashtar',
  warforged: 'warforged',
  gith: 'gith',
  centaur: 'centaur',
  loxodon: 'loxodon',
  minotaur: 'minotaur',
  simic_hybrid: 'simic_hybrid',
  vedalken: 'vedalken',
  verdan: 'verdan',
  leonin: 'leonin',
  satyr: 'satyr',
  fairy: 'fairy',
  harengon: 'harengon',
  owlin: 'owlin',
  custom: 'custom'
};

export type Race = (typeof Race)[keyof typeof Race]


export const NPCRole: {
  merchant: 'merchant',
  guard: 'guard',
  noble: 'noble',
  commoner: 'commoner',
  criminal: 'criminal',
  cultist: 'cultist',
  scholar: 'scholar',
  priest: 'priest',
  soldier: 'soldier',
  artisan: 'artisan',
  entertainer: 'entertainer',
  innkeeper: 'innkeeper',
  spy: 'spy',
  assassin: 'assassin',
  mage: 'mage',
  healer: 'healer',
  scout: 'scout',
  leader: 'leader',
  advisor: 'advisor',
  other: 'other'
};

export type NPCRole = (typeof NPCRole)[keyof typeof NPCRole]


export const NPCAttitude: {
  hostile: 'hostile',
  unfriendly: 'unfriendly',
  indifferent: 'indifferent',
  friendly: 'friendly',
  helpful: 'helpful',
  devoted: 'devoted'
};

export type NPCAttitude = (typeof NPCAttitude)[keyof typeof NPCAttitude]


export const BackgroundType: {
  acolyte: 'acolyte',
  charlatan: 'charlatan',
  criminal: 'criminal',
  entertainer: 'entertainer',
  folk_hero: 'folk_hero',
  guild_artisan: 'guild_artisan',
  hermit: 'hermit',
  noble: 'noble',
  outlander: 'outlander',
  sage: 'sage',
  sailor: 'sailor',
  soldier: 'soldier',
  urchin: 'urchin',
  haunted_one: 'haunted_one',
  investigator: 'investigator',
  knight: 'knight',
  pirate: 'pirate',
  custom: 'custom'
};

export type BackgroundType = (typeof BackgroundType)[keyof typeof BackgroundType]


export const ItemType: {
  weapon: 'weapon',
  armor: 'armor',
  potion: 'potion',
  scroll: 'scroll',
  wondrous: 'wondrous',
  ring: 'ring',
  rod: 'rod',
  staff: 'staff',
  wand: 'wand',
  key_item: 'key_item',
  treasure: 'treasure',
  consumable: 'consumable',
  tool: 'tool',
  other: 'other'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const ItemRarity: {
  common: 'common',
  uncommon: 'uncommon',
  rare: 'rare',
  very_rare: 'very_rare',
  legendary: 'legendary',
  artifact: 'artifact',
  unique: 'unique'
};

export type ItemRarity = (typeof ItemRarity)[keyof typeof ItemRarity]


export const Difficulty: {
  trivial: 'trivial',
  easy: 'easy',
  medium: 'medium',
  hard: 'hard',
  deadly: 'deadly'
};

export type Difficulty = (typeof Difficulty)[keyof typeof Difficulty]


export const QuestStatus: {
  available: 'available',
  active: 'active',
  completed: 'completed',
  failed: 'failed',
  abandoned: 'abandoned'
};

export type QuestStatus = (typeof QuestStatus)[keyof typeof QuestStatus]


export const ResetType: {
  none: 'none',
  short_rest: 'short_rest',
  long_rest: 'long_rest',
  dawn: 'dawn',
  dusk: 'dusk'
};

export type ResetType = (typeof ResetType)[keyof typeof ResetType]


export const LocationType: {
  city: 'city',
  dungeon: 'dungeon',
  region: 'region',
  building: 'building',
  room: 'room',
  wilderness: 'wilderness',
  other: 'other'
};

export type LocationType = (typeof LocationType)[keyof typeof LocationType]


export const MapAnnotationType: {
  note: 'note',
  treasure: 'treasure',
  secret: 'secret',
  trap: 'trap',
  poi: 'poi',
  encounter: 'encounter'
};

export type MapAnnotationType = (typeof MapAnnotationType)[keyof typeof MapAnnotationType]


export const EncounterStatus: {
  planned: 'planned',
  active: 'active',
  completed: 'completed'
};

export type EncounterStatus = (typeof EncounterStatus)[keyof typeof EncounterStatus]


export const ParticipantType: {
  monster: 'monster',
  player: 'player'
};

export type ParticipantType = (typeof ParticipantType)[keyof typeof ParticipantType]


export const InteractionType: {
  conversation: 'conversation',
  transaction: 'transaction',
  conflict: 'conflict',
  quest_given: 'quest_given',
  quest_completed: 'quest_completed',
  other: 'other'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const TransactionType: {
  given_to_party: 'given_to_party',
  received_from_party: 'received_from_party',
  shown: 'shown',
  discussed: 'discussed'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]

}

export type CreatureType = $Enums.CreatureType

export const CreatureType: typeof $Enums.CreatureType

export type Size = $Enums.Size

export const Size: typeof $Enums.Size

export type Alignment = $Enums.Alignment

export const Alignment: typeof $Enums.Alignment

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

export type CharacterClass = $Enums.CharacterClass

export const CharacterClass: typeof $Enums.CharacterClass

export type Race = $Enums.Race

export const Race: typeof $Enums.Race

export type NPCRole = $Enums.NPCRole

export const NPCRole: typeof $Enums.NPCRole

export type NPCAttitude = $Enums.NPCAttitude

export const NPCAttitude: typeof $Enums.NPCAttitude

export type BackgroundType = $Enums.BackgroundType

export const BackgroundType: typeof $Enums.BackgroundType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type ItemRarity = $Enums.ItemRarity

export const ItemRarity: typeof $Enums.ItemRarity

export type Difficulty = $Enums.Difficulty

export const Difficulty: typeof $Enums.Difficulty

export type QuestStatus = $Enums.QuestStatus

export const QuestStatus: typeof $Enums.QuestStatus

export type ResetType = $Enums.ResetType

export const ResetType: typeof $Enums.ResetType

export type LocationType = $Enums.LocationType

export const LocationType: typeof $Enums.LocationType

export type MapAnnotationType = $Enums.MapAnnotationType

export const MapAnnotationType: typeof $Enums.MapAnnotationType

export type EncounterStatus = $Enums.EncounterStatus

export const EncounterStatus: typeof $Enums.EncounterStatus

export type ParticipantType = $Enums.ParticipantType

export const ParticipantType: typeof $Enums.ParticipantType

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Campaigns
 * const campaigns = await prisma.campaign.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Campaigns
   * const campaigns = await prisma.campaign.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nPC`: Exposes CRUD operations for the **NPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPCS
    * const nPCS = await prisma.nPC.findMany()
    * ```
    */
  get nPC(): Prisma.NPCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.map`: Exposes CRUD operations for the **Map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maps
    * const maps = await prisma.map.findMany()
    * ```
    */
  get map(): Prisma.MapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapAnnotation`: Exposes CRUD operations for the **MapAnnotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapAnnotations
    * const mapAnnotations = await prisma.mapAnnotation.findMany()
    * ```
    */
  get mapAnnotation(): Prisma.MapAnnotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monster`: Exposes CRUD operations for the **Monster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monsters
    * const monsters = await prisma.monster.findMany()
    * ```
    */
  get monster(): Prisma.MonsterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.condition`: Exposes CRUD operations for the **Condition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conditions
    * const conditions = await prisma.condition.findMany()
    * ```
    */
  get condition(): Prisma.ConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounterParticipant`: Exposes CRUD operations for the **EncounterParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterParticipants
    * const encounterParticipants = await prisma.encounterParticipant.findMany()
    * ```
    */
  get encounterParticipant(): Prisma.EncounterParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerCharacter`: Exposes CRUD operations for the **PlayerCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerCharacters
    * const playerCharacters = await prisma.playerCharacter.findMany()
    * ```
    */
  get playerCharacter(): Prisma.PlayerCharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quest`: Exposes CRUD operations for the **Quest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quests
    * const quests = await prisma.quest.findMany()
    * ```
    */
  get quest(): Prisma.QuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chronicle`: Exposes CRUD operations for the **Chronicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chronicles
    * const chronicles = await prisma.chronicle.findMany()
    * ```
    */
  get chronicle(): Prisma.ChronicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interaction`: Exposes CRUD operations for the **Interaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interactions
    * const interactions = await prisma.interaction.findMany()
    * ```
    */
  get interaction(): Prisma.InteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monsterCampaign`: Exposes CRUD operations for the **MonsterCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonsterCampaigns
    * const monsterCampaigns = await prisma.monsterCampaign.findMany()
    * ```
    */
  get monsterCampaign(): Prisma.MonsterCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCampaign`: Exposes CRUD operations for the **ItemCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCampaigns
    * const itemCampaigns = await prisma.itemCampaign.findMany()
    * ```
    */
  get itemCampaign(): Prisma.ItemCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nPCLocation`: Exposes CRUD operations for the **NPCLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPCLocations
    * const nPCLocations = await prisma.nPCLocation.findMany()
    * ```
    */
  get nPCLocation(): Prisma.NPCLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questNPC`: Exposes CRUD operations for the **QuestNPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestNPCS
    * const questNPCS = await prisma.questNPC.findMany()
    * ```
    */
  get questNPC(): Prisma.QuestNPCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questLocation`: Exposes CRUD operations for the **QuestLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestLocations
    * const questLocations = await prisma.questLocation.findMany()
    * ```
    */
  get questLocation(): Prisma.QuestLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chronicleQuest`: Exposes CRUD operations for the **ChronicleQuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChronicleQuests
    * const chronicleQuests = await prisma.chronicleQuest.findMany()
    * ```
    */
  get chronicleQuest(): Prisma.ChronicleQuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemLocation`: Exposes CRUD operations for the **ItemLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemLocations
    * const itemLocations = await prisma.itemLocation.findMany()
    * ```
    */
  get itemLocation(): Prisma.ItemLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemNPC`: Exposes CRUD operations for the **ItemNPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemNPCS
    * const itemNPCS = await prisma.itemNPC.findMany()
    * ```
    */
  get itemNPC(): Prisma.ItemNPCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interactionItem`: Exposes CRUD operations for the **InteractionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InteractionItems
    * const interactionItems = await prisma.interactionItem.findMany()
    * ```
    */
  get interactionItem(): Prisma.InteractionItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Campaign: 'Campaign',
    NPC: 'NPC',
    Location: 'Location',
    Map: 'Map',
    MapAnnotation: 'MapAnnotation',
    Monster: 'Monster',
    Condition: 'Condition',
    Encounter: 'Encounter',
    EncounterParticipant: 'EncounterParticipant',
    PlayerCharacter: 'PlayerCharacter',
    Quest: 'Quest',
    Item: 'Item',
    Chronicle: 'Chronicle',
    Interaction: 'Interaction',
    MonsterCampaign: 'MonsterCampaign',
    ItemCampaign: 'ItemCampaign',
    NPCLocation: 'NPCLocation',
    QuestNPC: 'QuestNPC',
    QuestLocation: 'QuestLocation',
    ChronicleQuest: 'ChronicleQuest',
    ItemLocation: 'ItemLocation',
    ItemNPC: 'ItemNPC',
    InteractionItem: 'InteractionItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "campaign" | "nPC" | "location" | "map" | "mapAnnotation" | "monster" | "condition" | "encounter" | "encounterParticipant" | "playerCharacter" | "quest" | "item" | "chronicle" | "interaction" | "monsterCampaign" | "itemCampaign" | "nPCLocation" | "questNPC" | "questLocation" | "chronicleQuest" | "itemLocation" | "itemNPC" | "interactionItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      NPC: {
        payload: Prisma.$NPCPayload<ExtArgs>
        fields: Prisma.NPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findFirst: {
            args: Prisma.NPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findMany: {
            args: Prisma.NPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          create: {
            args: Prisma.NPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          createMany: {
            args: Prisma.NPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          delete: {
            args: Prisma.NPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          update: {
            args: Prisma.NPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          deleteMany: {
            args: Prisma.NPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NPCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          upsert: {
            args: Prisma.NPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          aggregate: {
            args: Prisma.NPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPC>
          }
          groupBy: {
            args: Prisma.NPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPCCountArgs<ExtArgs>
            result: $Utils.Optional<NPCCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Map: {
        payload: Prisma.$MapPayload<ExtArgs>
        fields: Prisma.MapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          findFirst: {
            args: Prisma.MapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          findMany: {
            args: Prisma.MapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          create: {
            args: Prisma.MapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          createMany: {
            args: Prisma.MapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          delete: {
            args: Prisma.MapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          update: {
            args: Prisma.MapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          deleteMany: {
            args: Prisma.MapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          upsert: {
            args: Prisma.MapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          aggregate: {
            args: Prisma.MapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMap>
          }
          groupBy: {
            args: Prisma.MapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapCountArgs<ExtArgs>
            result: $Utils.Optional<MapCountAggregateOutputType> | number
          }
        }
      }
      MapAnnotation: {
        payload: Prisma.$MapAnnotationPayload<ExtArgs>
        fields: Prisma.MapAnnotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapAnnotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapAnnotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>
          }
          findFirst: {
            args: Prisma.MapAnnotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapAnnotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>
          }
          findMany: {
            args: Prisma.MapAnnotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>[]
          }
          create: {
            args: Prisma.MapAnnotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>
          }
          createMany: {
            args: Prisma.MapAnnotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapAnnotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>[]
          }
          delete: {
            args: Prisma.MapAnnotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>
          }
          update: {
            args: Prisma.MapAnnotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>
          }
          deleteMany: {
            args: Prisma.MapAnnotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapAnnotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapAnnotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>[]
          }
          upsert: {
            args: Prisma.MapAnnotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapAnnotationPayload>
          }
          aggregate: {
            args: Prisma.MapAnnotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapAnnotation>
          }
          groupBy: {
            args: Prisma.MapAnnotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapAnnotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapAnnotationCountArgs<ExtArgs>
            result: $Utils.Optional<MapAnnotationCountAggregateOutputType> | number
          }
        }
      }
      Monster: {
        payload: Prisma.$MonsterPayload<ExtArgs>
        fields: Prisma.MonsterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonsterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonsterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>
          }
          findFirst: {
            args: Prisma.MonsterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonsterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>
          }
          findMany: {
            args: Prisma.MonsterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>[]
          }
          create: {
            args: Prisma.MonsterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>
          }
          createMany: {
            args: Prisma.MonsterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonsterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>[]
          }
          delete: {
            args: Prisma.MonsterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>
          }
          update: {
            args: Prisma.MonsterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>
          }
          deleteMany: {
            args: Prisma.MonsterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonsterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonsterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>[]
          }
          upsert: {
            args: Prisma.MonsterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterPayload>
          }
          aggregate: {
            args: Prisma.MonsterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonster>
          }
          groupBy: {
            args: Prisma.MonsterGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonsterGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonsterCountArgs<ExtArgs>
            result: $Utils.Optional<MonsterCountAggregateOutputType> | number
          }
        }
      }
      Condition: {
        payload: Prisma.$ConditionPayload<ExtArgs>
        fields: Prisma.ConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          findFirst: {
            args: Prisma.ConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          findMany: {
            args: Prisma.ConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          create: {
            args: Prisma.ConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          createMany: {
            args: Prisma.ConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          delete: {
            args: Prisma.ConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          update: {
            args: Prisma.ConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          deleteMany: {
            args: Prisma.ConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          upsert: {
            args: Prisma.ConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          aggregate: {
            args: Prisma.ConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCondition>
          }
          groupBy: {
            args: Prisma.ConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConditionCountArgs<ExtArgs>
            result: $Utils.Optional<ConditionCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      EncounterParticipant: {
        payload: Prisma.$EncounterParticipantPayload<ExtArgs>
        fields: Prisma.EncounterParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>
          }
          findFirst: {
            args: Prisma.EncounterParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>
          }
          findMany: {
            args: Prisma.EncounterParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>[]
          }
          create: {
            args: Prisma.EncounterParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>
          }
          createMany: {
            args: Prisma.EncounterParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>[]
          }
          delete: {
            args: Prisma.EncounterParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>
          }
          update: {
            args: Prisma.EncounterParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>
          }
          deleteMany: {
            args: Prisma.EncounterParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>[]
          }
          upsert: {
            args: Prisma.EncounterParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterParticipantPayload>
          }
          aggregate: {
            args: Prisma.EncounterParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterParticipant>
          }
          groupBy: {
            args: Prisma.EncounterParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterParticipantCountAggregateOutputType> | number
          }
        }
      }
      PlayerCharacter: {
        payload: Prisma.$PlayerCharacterPayload<ExtArgs>
        fields: Prisma.PlayerCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerCharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerCharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>
          }
          findFirst: {
            args: Prisma.PlayerCharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerCharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>
          }
          findMany: {
            args: Prisma.PlayerCharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>[]
          }
          create: {
            args: Prisma.PlayerCharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>
          }
          createMany: {
            args: Prisma.PlayerCharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>[]
          }
          delete: {
            args: Prisma.PlayerCharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>
          }
          update: {
            args: Prisma.PlayerCharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>
          }
          deleteMany: {
            args: Prisma.PlayerCharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerCharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerCharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>[]
          }
          upsert: {
            args: Prisma.PlayerCharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerCharacterPayload>
          }
          aggregate: {
            args: Prisma.PlayerCharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerCharacter>
          }
          groupBy: {
            args: Prisma.PlayerCharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCharacterCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCharacterCountAggregateOutputType> | number
          }
        }
      }
      Quest: {
        payload: Prisma.$QuestPayload<ExtArgs>
        fields: Prisma.QuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findFirst: {
            args: Prisma.QuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          findMany: {
            args: Prisma.QuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          create: {
            args: Prisma.QuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          createMany: {
            args: Prisma.QuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          delete: {
            args: Prisma.QuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          update: {
            args: Prisma.QuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          deleteMany: {
            args: Prisma.QuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>[]
          }
          upsert: {
            args: Prisma.QuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestPayload>
          }
          aggregate: {
            args: Prisma.QuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuest>
          }
          groupBy: {
            args: Prisma.QuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestCountArgs<ExtArgs>
            result: $Utils.Optional<QuestCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Chronicle: {
        payload: Prisma.$ChroniclePayload<ExtArgs>
        fields: Prisma.ChronicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChronicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChronicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>
          }
          findFirst: {
            args: Prisma.ChronicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChronicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>
          }
          findMany: {
            args: Prisma.ChronicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>[]
          }
          create: {
            args: Prisma.ChronicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>
          }
          createMany: {
            args: Prisma.ChronicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChronicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>[]
          }
          delete: {
            args: Prisma.ChronicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>
          }
          update: {
            args: Prisma.ChronicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>
          }
          deleteMany: {
            args: Prisma.ChronicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChronicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChronicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>[]
          }
          upsert: {
            args: Prisma.ChronicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChroniclePayload>
          }
          aggregate: {
            args: Prisma.ChronicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChronicle>
          }
          groupBy: {
            args: Prisma.ChronicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChronicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChronicleCountArgs<ExtArgs>
            result: $Utils.Optional<ChronicleCountAggregateOutputType> | number
          }
        }
      }
      Interaction: {
        payload: Prisma.$InteractionPayload<ExtArgs>
        fields: Prisma.InteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findFirst: {
            args: Prisma.InteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findMany: {
            args: Prisma.InteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          create: {
            args: Prisma.InteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          createMany: {
            args: Prisma.InteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          delete: {
            args: Prisma.InteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          update: {
            args: Prisma.InteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          deleteMany: {
            args: Prisma.InteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          upsert: {
            args: Prisma.InteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          aggregate: {
            args: Prisma.InteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteraction>
          }
          groupBy: {
            args: Prisma.InteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionCountAggregateOutputType> | number
          }
        }
      }
      MonsterCampaign: {
        payload: Prisma.$MonsterCampaignPayload<ExtArgs>
        fields: Prisma.MonsterCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonsterCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonsterCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>
          }
          findFirst: {
            args: Prisma.MonsterCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonsterCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>
          }
          findMany: {
            args: Prisma.MonsterCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>[]
          }
          create: {
            args: Prisma.MonsterCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>
          }
          createMany: {
            args: Prisma.MonsterCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonsterCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>[]
          }
          delete: {
            args: Prisma.MonsterCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>
          }
          update: {
            args: Prisma.MonsterCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>
          }
          deleteMany: {
            args: Prisma.MonsterCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonsterCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonsterCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>[]
          }
          upsert: {
            args: Prisma.MonsterCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonsterCampaignPayload>
          }
          aggregate: {
            args: Prisma.MonsterCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonsterCampaign>
          }
          groupBy: {
            args: Prisma.MonsterCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonsterCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonsterCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<MonsterCampaignCountAggregateOutputType> | number
          }
        }
      }
      ItemCampaign: {
        payload: Prisma.$ItemCampaignPayload<ExtArgs>
        fields: Prisma.ItemCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>
          }
          findFirst: {
            args: Prisma.ItemCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>
          }
          findMany: {
            args: Prisma.ItemCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>[]
          }
          create: {
            args: Prisma.ItemCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>
          }
          createMany: {
            args: Prisma.ItemCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>[]
          }
          delete: {
            args: Prisma.ItemCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>
          }
          update: {
            args: Prisma.ItemCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>
          }
          deleteMany: {
            args: Prisma.ItemCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>[]
          }
          upsert: {
            args: Prisma.ItemCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCampaignPayload>
          }
          aggregate: {
            args: Prisma.ItemCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCampaign>
          }
          groupBy: {
            args: Prisma.ItemCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCampaignCountAggregateOutputType> | number
          }
        }
      }
      NPCLocation: {
        payload: Prisma.$NPCLocationPayload<ExtArgs>
        fields: Prisma.NPCLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPCLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPCLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>
          }
          findFirst: {
            args: Prisma.NPCLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPCLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>
          }
          findMany: {
            args: Prisma.NPCLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>[]
          }
          create: {
            args: Prisma.NPCLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>
          }
          createMany: {
            args: Prisma.NPCLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPCLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>[]
          }
          delete: {
            args: Prisma.NPCLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>
          }
          update: {
            args: Prisma.NPCLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>
          }
          deleteMany: {
            args: Prisma.NPCLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPCLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NPCLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>[]
          }
          upsert: {
            args: Prisma.NPCLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCLocationPayload>
          }
          aggregate: {
            args: Prisma.NPCLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPCLocation>
          }
          groupBy: {
            args: Prisma.NPCLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPCLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPCLocationCountArgs<ExtArgs>
            result: $Utils.Optional<NPCLocationCountAggregateOutputType> | number
          }
        }
      }
      QuestNPC: {
        payload: Prisma.$QuestNPCPayload<ExtArgs>
        fields: Prisma.QuestNPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestNPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestNPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>
          }
          findFirst: {
            args: Prisma.QuestNPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestNPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>
          }
          findMany: {
            args: Prisma.QuestNPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>[]
          }
          create: {
            args: Prisma.QuestNPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>
          }
          createMany: {
            args: Prisma.QuestNPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestNPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>[]
          }
          delete: {
            args: Prisma.QuestNPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>
          }
          update: {
            args: Prisma.QuestNPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>
          }
          deleteMany: {
            args: Prisma.QuestNPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestNPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestNPCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>[]
          }
          upsert: {
            args: Prisma.QuestNPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestNPCPayload>
          }
          aggregate: {
            args: Prisma.QuestNPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestNPC>
          }
          groupBy: {
            args: Prisma.QuestNPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestNPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestNPCCountArgs<ExtArgs>
            result: $Utils.Optional<QuestNPCCountAggregateOutputType> | number
          }
        }
      }
      QuestLocation: {
        payload: Prisma.$QuestLocationPayload<ExtArgs>
        fields: Prisma.QuestLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>
          }
          findFirst: {
            args: Prisma.QuestLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>
          }
          findMany: {
            args: Prisma.QuestLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>[]
          }
          create: {
            args: Prisma.QuestLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>
          }
          createMany: {
            args: Prisma.QuestLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>[]
          }
          delete: {
            args: Prisma.QuestLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>
          }
          update: {
            args: Prisma.QuestLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>
          }
          deleteMany: {
            args: Prisma.QuestLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>[]
          }
          upsert: {
            args: Prisma.QuestLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestLocationPayload>
          }
          aggregate: {
            args: Prisma.QuestLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestLocation>
          }
          groupBy: {
            args: Prisma.QuestLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestLocationCountArgs<ExtArgs>
            result: $Utils.Optional<QuestLocationCountAggregateOutputType> | number
          }
        }
      }
      ChronicleQuest: {
        payload: Prisma.$ChronicleQuestPayload<ExtArgs>
        fields: Prisma.ChronicleQuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChronicleQuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChronicleQuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>
          }
          findFirst: {
            args: Prisma.ChronicleQuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChronicleQuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>
          }
          findMany: {
            args: Prisma.ChronicleQuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>[]
          }
          create: {
            args: Prisma.ChronicleQuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>
          }
          createMany: {
            args: Prisma.ChronicleQuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChronicleQuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>[]
          }
          delete: {
            args: Prisma.ChronicleQuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>
          }
          update: {
            args: Prisma.ChronicleQuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>
          }
          deleteMany: {
            args: Prisma.ChronicleQuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChronicleQuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChronicleQuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>[]
          }
          upsert: {
            args: Prisma.ChronicleQuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChronicleQuestPayload>
          }
          aggregate: {
            args: Prisma.ChronicleQuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChronicleQuest>
          }
          groupBy: {
            args: Prisma.ChronicleQuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChronicleQuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChronicleQuestCountArgs<ExtArgs>
            result: $Utils.Optional<ChronicleQuestCountAggregateOutputType> | number
          }
        }
      }
      ItemLocation: {
        payload: Prisma.$ItemLocationPayload<ExtArgs>
        fields: Prisma.ItemLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          findFirst: {
            args: Prisma.ItemLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          findMany: {
            args: Prisma.ItemLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>[]
          }
          create: {
            args: Prisma.ItemLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          createMany: {
            args: Prisma.ItemLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>[]
          }
          delete: {
            args: Prisma.ItemLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          update: {
            args: Prisma.ItemLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          deleteMany: {
            args: Prisma.ItemLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>[]
          }
          upsert: {
            args: Prisma.ItemLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLocationPayload>
          }
          aggregate: {
            args: Prisma.ItemLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemLocation>
          }
          groupBy: {
            args: Prisma.ItemLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemLocationCountArgs<ExtArgs>
            result: $Utils.Optional<ItemLocationCountAggregateOutputType> | number
          }
        }
      }
      ItemNPC: {
        payload: Prisma.$ItemNPCPayload<ExtArgs>
        fields: Prisma.ItemNPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemNPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemNPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>
          }
          findFirst: {
            args: Prisma.ItemNPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemNPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>
          }
          findMany: {
            args: Prisma.ItemNPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>[]
          }
          create: {
            args: Prisma.ItemNPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>
          }
          createMany: {
            args: Prisma.ItemNPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemNPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>[]
          }
          delete: {
            args: Prisma.ItemNPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>
          }
          update: {
            args: Prisma.ItemNPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>
          }
          deleteMany: {
            args: Prisma.ItemNPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemNPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemNPCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>[]
          }
          upsert: {
            args: Prisma.ItemNPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemNPCPayload>
          }
          aggregate: {
            args: Prisma.ItemNPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemNPC>
          }
          groupBy: {
            args: Prisma.ItemNPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemNPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemNPCCountArgs<ExtArgs>
            result: $Utils.Optional<ItemNPCCountAggregateOutputType> | number
          }
        }
      }
      InteractionItem: {
        payload: Prisma.$InteractionItemPayload<ExtArgs>
        fields: Prisma.InteractionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>
          }
          findFirst: {
            args: Prisma.InteractionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>
          }
          findMany: {
            args: Prisma.InteractionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>[]
          }
          create: {
            args: Prisma.InteractionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>
          }
          createMany: {
            args: Prisma.InteractionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>[]
          }
          delete: {
            args: Prisma.InteractionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>
          }
          update: {
            args: Prisma.InteractionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>
          }
          deleteMany: {
            args: Prisma.InteractionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>[]
          }
          upsert: {
            args: Prisma.InteractionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionItemPayload>
          }
          aggregate: {
            args: Prisma.InteractionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteractionItem>
          }
          groupBy: {
            args: Prisma.InteractionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionItemCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    campaign?: CampaignOmit
    nPC?: NPCOmit
    location?: LocationOmit
    map?: MapOmit
    mapAnnotation?: MapAnnotationOmit
    monster?: MonsterOmit
    condition?: ConditionOmit
    encounter?: EncounterOmit
    encounterParticipant?: EncounterParticipantOmit
    playerCharacter?: PlayerCharacterOmit
    quest?: QuestOmit
    item?: ItemOmit
    chronicle?: ChronicleOmit
    interaction?: InteractionOmit
    monsterCampaign?: MonsterCampaignOmit
    itemCampaign?: ItemCampaignOmit
    nPCLocation?: NPCLocationOmit
    questNPC?: QuestNPCOmit
    questLocation?: QuestLocationOmit
    chronicleQuest?: ChronicleQuestOmit
    itemLocation?: ItemLocationOmit
    itemNPC?: ItemNPCOmit
    interactionItem?: InteractionItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    npcs: number
    locations: number
    maps: number
    encounters: number
    playerCharacters: number
    quests: number
    chronicles: number
    interactions: number
    monsterCampaigns: number
    itemCampaigns: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npcs?: boolean | CampaignCountOutputTypeCountNpcsArgs
    locations?: boolean | CampaignCountOutputTypeCountLocationsArgs
    maps?: boolean | CampaignCountOutputTypeCountMapsArgs
    encounters?: boolean | CampaignCountOutputTypeCountEncountersArgs
    playerCharacters?: boolean | CampaignCountOutputTypeCountPlayerCharactersArgs
    quests?: boolean | CampaignCountOutputTypeCountQuestsArgs
    chronicles?: boolean | CampaignCountOutputTypeCountChroniclesArgs
    interactions?: boolean | CampaignCountOutputTypeCountInteractionsArgs
    monsterCampaigns?: boolean | CampaignCountOutputTypeCountMonsterCampaignsArgs
    itemCampaigns?: boolean | CampaignCountOutputTypeCountItemCampaignsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountPlayerCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerCharacterWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountChroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChronicleWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMonsterCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonsterCampaignWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountItemCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCampaignWhereInput
  }


  /**
   * Count Type NPCCountOutputType
   */

  export type NPCCountOutputType = {
    locations: number
    questsGiven: number
    questsInvolved: number
    interactions: number
    items: number
  }

  export type NPCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | NPCCountOutputTypeCountLocationsArgs
    questsGiven?: boolean | NPCCountOutputTypeCountQuestsGivenArgs
    questsInvolved?: boolean | NPCCountOutputTypeCountQuestsInvolvedArgs
    interactions?: boolean | NPCCountOutputTypeCountInteractionsArgs
    items?: boolean | NPCCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCCountOutputType
     */
    select?: NPCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCLocationWhereInput
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountQuestsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountQuestsInvolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestNPCWhereInput
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemNPCWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    childLocations: number
    maps: number
    encounters: number
    npcs: number
    quests: number
    items: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childLocations?: boolean | LocationCountOutputTypeCountChildLocationsArgs
    maps?: boolean | LocationCountOutputTypeCountMapsArgs
    encounters?: boolean | LocationCountOutputTypeCountEncountersArgs
    npcs?: boolean | LocationCountOutputTypeCountNpcsArgs
    quests?: boolean | LocationCountOutputTypeCountQuestsArgs
    items?: boolean | LocationCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountChildLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCLocationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestLocationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLocationWhereInput
  }


  /**
   * Count Type MapCountOutputType
   */

  export type MapCountOutputType = {
    annotations: number
    encounters: number
  }

  export type MapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    annotations?: boolean | MapCountOutputTypeCountAnnotationsArgs
    encounters?: boolean | MapCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapCountOutputType
     */
    select?: MapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountAnnotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapAnnotationWhereInput
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type MonsterCountOutputType
   */

  export type MonsterCountOutputType = {
    campaigns: number
    encounterParticipants: number
  }

  export type MonsterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | MonsterCountOutputTypeCountCampaignsArgs
    encounterParticipants?: boolean | MonsterCountOutputTypeCountEncounterParticipantsArgs
  }

  // Custom InputTypes
  /**
   * MonsterCountOutputType without action
   */
  export type MonsterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCountOutputType
     */
    select?: MonsterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MonsterCountOutputType without action
   */
  export type MonsterCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonsterCampaignWhereInput
  }

  /**
   * MonsterCountOutputType without action
   */
  export type MonsterCountOutputTypeCountEncounterParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterParticipantWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    participants: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | EncounterCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterParticipantWhereInput
  }


  /**
   * Count Type PlayerCharacterCountOutputType
   */

  export type PlayerCharacterCountOutputType = {
    encounterParticipants: number
  }

  export type PlayerCharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterParticipants?: boolean | PlayerCharacterCountOutputTypeCountEncounterParticipantsArgs
  }

  // Custom InputTypes
  /**
   * PlayerCharacterCountOutputType without action
   */
  export type PlayerCharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacterCountOutputType
     */
    select?: PlayerCharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCharacterCountOutputType without action
   */
  export type PlayerCharacterCountOutputTypeCountEncounterParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterParticipantWhereInput
  }


  /**
   * Count Type QuestCountOutputType
   */

  export type QuestCountOutputType = {
    subQuests: number
    npcs: number
    locations: number
    chronicles: number
  }

  export type QuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subQuests?: boolean | QuestCountOutputTypeCountSubQuestsArgs
    npcs?: boolean | QuestCountOutputTypeCountNpcsArgs
    locations?: boolean | QuestCountOutputTypeCountLocationsArgs
    chronicles?: boolean | QuestCountOutputTypeCountChroniclesArgs
  }

  // Custom InputTypes
  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestCountOutputType
     */
    select?: QuestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeCountSubQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
  }

  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestNPCWhereInput
  }

  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestLocationWhereInput
  }

  /**
   * QuestCountOutputType without action
   */
  export type QuestCountOutputTypeCountChroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChronicleQuestWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    campaigns: number
    locations: number
    npcs: number
    interactions: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | ItemCountOutputTypeCountCampaignsArgs
    locations?: boolean | ItemCountOutputTypeCountLocationsArgs
    npcs?: boolean | ItemCountOutputTypeCountNpcsArgs
    interactions?: boolean | ItemCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCampaignWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLocationWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemNPCWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionItemWhereInput
  }


  /**
   * Count Type ChronicleCountOutputType
   */

  export type ChronicleCountOutputType = {
    quests: number
  }

  export type ChronicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quests?: boolean | ChronicleCountOutputTypeCountQuestsArgs
  }

  // Custom InputTypes
  /**
   * ChronicleCountOutputType without action
   */
  export type ChronicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleCountOutputType
     */
    select?: ChronicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChronicleCountOutputType without action
   */
  export type ChronicleCountOutputTypeCountQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChronicleQuestWhereInput
  }


  /**
   * Count Type InteractionCountOutputType
   */

  export type InteractionCountOutputType = {
    items: number
  }

  export type InteractionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InteractionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InteractionCountOutputType without action
   */
  export type InteractionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionCountOutputType
     */
    select?: InteractionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InteractionCountOutputType without action
   */
  export type InteractionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    coverImagePath: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastPlayedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    coverImagePath: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastPlayedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    coverImagePath: number
    createdAt: number
    updatedAt: number
    lastPlayedAt: number
    settings: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coverImagePath?: true
    createdAt?: true
    updatedAt?: true
    lastPlayedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coverImagePath?: true
    createdAt?: true
    updatedAt?: true
    lastPlayedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    coverImagePath?: true
    createdAt?: true
    updatedAt?: true
    lastPlayedAt?: true
    settings?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    coverImagePath: string | null
    createdAt: Date
    updatedAt: Date
    lastPlayedAt: Date | null
    settings: JsonValue | null
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coverImagePath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPlayedAt?: boolean
    settings?: boolean
    npcs?: boolean | Campaign$npcsArgs<ExtArgs>
    locations?: boolean | Campaign$locationsArgs<ExtArgs>
    maps?: boolean | Campaign$mapsArgs<ExtArgs>
    encounters?: boolean | Campaign$encountersArgs<ExtArgs>
    playerCharacters?: boolean | Campaign$playerCharactersArgs<ExtArgs>
    quests?: boolean | Campaign$questsArgs<ExtArgs>
    chronicles?: boolean | Campaign$chroniclesArgs<ExtArgs>
    interactions?: boolean | Campaign$interactionsArgs<ExtArgs>
    monsterCampaigns?: boolean | Campaign$monsterCampaignsArgs<ExtArgs>
    itemCampaigns?: boolean | Campaign$itemCampaignsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coverImagePath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPlayedAt?: boolean
    settings?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    coverImagePath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPlayedAt?: boolean
    settings?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    coverImagePath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPlayedAt?: boolean
    settings?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "coverImagePath" | "createdAt" | "updatedAt" | "lastPlayedAt" | "settings", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npcs?: boolean | Campaign$npcsArgs<ExtArgs>
    locations?: boolean | Campaign$locationsArgs<ExtArgs>
    maps?: boolean | Campaign$mapsArgs<ExtArgs>
    encounters?: boolean | Campaign$encountersArgs<ExtArgs>
    playerCharacters?: boolean | Campaign$playerCharactersArgs<ExtArgs>
    quests?: boolean | Campaign$questsArgs<ExtArgs>
    chronicles?: boolean | Campaign$chroniclesArgs<ExtArgs>
    interactions?: boolean | Campaign$interactionsArgs<ExtArgs>
    monsterCampaigns?: boolean | Campaign$monsterCampaignsArgs<ExtArgs>
    itemCampaigns?: boolean | Campaign$itemCampaignsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      npcs: Prisma.$NPCPayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
      maps: Prisma.$MapPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      playerCharacters: Prisma.$PlayerCharacterPayload<ExtArgs>[]
      quests: Prisma.$QuestPayload<ExtArgs>[]
      chronicles: Prisma.$ChroniclePayload<ExtArgs>[]
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      monsterCampaigns: Prisma.$MonsterCampaignPayload<ExtArgs>[]
      itemCampaigns: Prisma.$ItemCampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      coverImagePath: string | null
      createdAt: Date
      updatedAt: Date
      lastPlayedAt: Date | null
      settings: Prisma.JsonValue | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    npcs<T extends Campaign$npcsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Campaign$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maps<T extends Campaign$mapsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounters<T extends Campaign$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerCharacters<T extends Campaign$playerCharactersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$playerCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quests<T extends Campaign$questsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chronicles<T extends Campaign$chroniclesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$chroniclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Campaign$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    monsterCampaigns<T extends Campaign$monsterCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$monsterCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemCampaigns<T extends Campaign$itemCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$itemCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly coverImagePath: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly lastPlayedAt: FieldRef<"Campaign", 'DateTime'>
    readonly settings: FieldRef<"Campaign", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.npcs
   */
  export type Campaign$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    cursor?: NPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * Campaign.locations
   */
  export type Campaign$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Campaign.maps
   */
  export type Campaign$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    cursor?: MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Campaign.encounters
   */
  export type Campaign$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Campaign.playerCharacters
   */
  export type Campaign$playerCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    where?: PlayerCharacterWhereInput
    orderBy?: PlayerCharacterOrderByWithRelationInput | PlayerCharacterOrderByWithRelationInput[]
    cursor?: PlayerCharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerCharacterScalarFieldEnum | PlayerCharacterScalarFieldEnum[]
  }

  /**
   * Campaign.quests
   */
  export type Campaign$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Campaign.chronicles
   */
  export type Campaign$chroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    where?: ChronicleWhereInput
    orderBy?: ChronicleOrderByWithRelationInput | ChronicleOrderByWithRelationInput[]
    cursor?: ChronicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChronicleScalarFieldEnum | ChronicleScalarFieldEnum[]
  }

  /**
   * Campaign.interactions
   */
  export type Campaign$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Campaign.monsterCampaigns
   */
  export type Campaign$monsterCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    where?: MonsterCampaignWhereInput
    orderBy?: MonsterCampaignOrderByWithRelationInput | MonsterCampaignOrderByWithRelationInput[]
    cursor?: MonsterCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonsterCampaignScalarFieldEnum | MonsterCampaignScalarFieldEnum[]
  }

  /**
   * Campaign.itemCampaigns
   */
  export type Campaign$itemCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    where?: ItemCampaignWhereInput
    orderBy?: ItemCampaignOrderByWithRelationInput | ItemCampaignOrderByWithRelationInput[]
    cursor?: ItemCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCampaignScalarFieldEnum | ItemCampaignScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model NPC
   */

  export type AggregateNPC = {
    _count: NPCCountAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  export type NPCMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    name: string | null
    title: string | null
    race: $Enums.Race | null
    creatureType: $Enums.CreatureType | null
    role: $Enums.NPCRole | null
    class: $Enums.CharacterClass | null
    alignment: $Enums.Alignment | null
    attitudeToParty: $Enums.NPCAttitude | null
    appearance: string | null
    personality: string | null
    motivations: string | null
    backstory: string | null
    dmNotes: string | null
    portraitPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NPCMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    name: string | null
    title: string | null
    race: $Enums.Race | null
    creatureType: $Enums.CreatureType | null
    role: $Enums.NPCRole | null
    class: $Enums.CharacterClass | null
    alignment: $Enums.Alignment | null
    attitudeToParty: $Enums.NPCAttitude | null
    appearance: string | null
    personality: string | null
    motivations: string | null
    backstory: string | null
    dmNotes: string | null
    portraitPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NPCCountAggregateOutputType = {
    id: number
    campaignId: number
    name: number
    title: number
    race: number
    creatureType: number
    role: number
    class: number
    alignment: number
    attitudeToParty: number
    languages: number
    appearance: number
    personality: number
    motivations: number
    backstory: number
    dmNotes: number
    portraitPath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NPCMinAggregateInputType = {
    id?: true
    campaignId?: true
    name?: true
    title?: true
    race?: true
    creatureType?: true
    role?: true
    class?: true
    alignment?: true
    attitudeToParty?: true
    appearance?: true
    personality?: true
    motivations?: true
    backstory?: true
    dmNotes?: true
    portraitPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NPCMaxAggregateInputType = {
    id?: true
    campaignId?: true
    name?: true
    title?: true
    race?: true
    creatureType?: true
    role?: true
    class?: true
    alignment?: true
    attitudeToParty?: true
    appearance?: true
    personality?: true
    motivations?: true
    backstory?: true
    dmNotes?: true
    portraitPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NPCCountAggregateInputType = {
    id?: true
    campaignId?: true
    name?: true
    title?: true
    race?: true
    creatureType?: true
    role?: true
    class?: true
    alignment?: true
    attitudeToParty?: true
    languages?: true
    appearance?: true
    personality?: true
    motivations?: true
    backstory?: true
    dmNotes?: true
    portraitPath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPC to aggregate.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPCS
    **/
    _count?: true | NPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPCMaxAggregateInputType
  }

  export type GetNPCAggregateType<T extends NPCAggregateArgs> = {
        [P in keyof T & keyof AggregateNPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPC[P]>
      : GetScalarType<T[P], AggregateNPC[P]>
  }




  export type NPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithAggregationInput | NPCOrderByWithAggregationInput[]
    by: NPCScalarFieldEnum[] | NPCScalarFieldEnum
    having?: NPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPCCountAggregateInputType | true
    _min?: NPCMinAggregateInputType
    _max?: NPCMaxAggregateInputType
  }

  export type NPCGroupByOutputType = {
    id: string
    campaignId: string
    name: string
    title: string | null
    race: $Enums.Race | null
    creatureType: $Enums.CreatureType | null
    role: $Enums.NPCRole | null
    class: $Enums.CharacterClass | null
    alignment: $Enums.Alignment | null
    attitudeToParty: $Enums.NPCAttitude | null
    languages: JsonValue | null
    appearance: string | null
    personality: string | null
    motivations: string | null
    backstory: string | null
    dmNotes: string | null
    portraitPath: string | null
    createdAt: Date
    updatedAt: Date
    _count: NPCCountAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  type GetNPCGroupByPayload<T extends NPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPCGroupByOutputType[P]>
            : GetScalarType<T[P], NPCGroupByOutputType[P]>
        }
      >
    >


  export type NPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    name?: boolean
    title?: boolean
    race?: boolean
    creatureType?: boolean
    role?: boolean
    class?: boolean
    alignment?: boolean
    attitudeToParty?: boolean
    languages?: boolean
    appearance?: boolean
    personality?: boolean
    motivations?: boolean
    backstory?: boolean
    dmNotes?: boolean
    portraitPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    locations?: boolean | NPC$locationsArgs<ExtArgs>
    questsGiven?: boolean | NPC$questsGivenArgs<ExtArgs>
    questsInvolved?: boolean | NPC$questsInvolvedArgs<ExtArgs>
    interactions?: boolean | NPC$interactionsArgs<ExtArgs>
    items?: boolean | NPC$itemsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    name?: boolean
    title?: boolean
    race?: boolean
    creatureType?: boolean
    role?: boolean
    class?: boolean
    alignment?: boolean
    attitudeToParty?: boolean
    languages?: boolean
    appearance?: boolean
    personality?: boolean
    motivations?: boolean
    backstory?: boolean
    dmNotes?: boolean
    portraitPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    name?: boolean
    title?: boolean
    race?: boolean
    creatureType?: boolean
    role?: boolean
    class?: boolean
    alignment?: boolean
    attitudeToParty?: boolean
    languages?: boolean
    appearance?: boolean
    personality?: boolean
    motivations?: boolean
    backstory?: boolean
    dmNotes?: boolean
    portraitPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectScalar = {
    id?: boolean
    campaignId?: boolean
    name?: boolean
    title?: boolean
    race?: boolean
    creatureType?: boolean
    role?: boolean
    class?: boolean
    alignment?: boolean
    attitudeToParty?: boolean
    languages?: boolean
    appearance?: boolean
    personality?: boolean
    motivations?: boolean
    backstory?: boolean
    dmNotes?: boolean
    portraitPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NPCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "name" | "title" | "race" | "creatureType" | "role" | "class" | "alignment" | "attitudeToParty" | "languages" | "appearance" | "personality" | "motivations" | "backstory" | "dmNotes" | "portraitPath" | "createdAt" | "updatedAt", ExtArgs["result"]["nPC"]>
  export type NPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    locations?: boolean | NPC$locationsArgs<ExtArgs>
    questsGiven?: boolean | NPC$questsGivenArgs<ExtArgs>
    questsInvolved?: boolean | NPC$questsInvolvedArgs<ExtArgs>
    interactions?: boolean | NPC$interactionsArgs<ExtArgs>
    items?: boolean | NPC$itemsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type NPCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $NPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPC"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      locations: Prisma.$NPCLocationPayload<ExtArgs>[]
      questsGiven: Prisma.$QuestPayload<ExtArgs>[]
      questsInvolved: Prisma.$QuestNPCPayload<ExtArgs>[]
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      items: Prisma.$ItemNPCPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      name: string
      title: string | null
      race: $Enums.Race | null
      creatureType: $Enums.CreatureType | null
      role: $Enums.NPCRole | null
      class: $Enums.CharacterClass | null
      alignment: $Enums.Alignment | null
      attitudeToParty: $Enums.NPCAttitude | null
      languages: Prisma.JsonValue | null
      appearance: string | null
      personality: string | null
      motivations: string | null
      backstory: string | null
      dmNotes: string | null
      portraitPath: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nPC"]>
    composites: {}
  }

  type NPCGetPayload<S extends boolean | null | undefined | NPCDefaultArgs> = $Result.GetResult<Prisma.$NPCPayload, S>

  type NPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NPCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NPCCountAggregateInputType | true
    }

  export interface NPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPC'], meta: { name: 'NPC' } }
    /**
     * Find zero or one NPC that matches the filter.
     * @param {NPCFindUniqueArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPCFindUniqueArgs>(args: SelectSubset<T, NPCFindUniqueArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NPC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NPCFindUniqueOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPCFindUniqueOrThrowArgs>(args: SelectSubset<T, NPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPCFindFirstArgs>(args?: SelectSubset<T, NPCFindFirstArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPCFindFirstOrThrowArgs>(args?: SelectSubset<T, NPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPCS
     * const nPCS = await prisma.nPC.findMany()
     * 
     * // Get first 10 NPCS
     * const nPCS = await prisma.nPC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nPCWithIdOnly = await prisma.nPC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NPCFindManyArgs>(args?: SelectSubset<T, NPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NPC.
     * @param {NPCCreateArgs} args - Arguments to create a NPC.
     * @example
     * // Create one NPC
     * const NPC = await prisma.nPC.create({
     *   data: {
     *     // ... data to create a NPC
     *   }
     * })
     * 
     */
    create<T extends NPCCreateArgs>(args: SelectSubset<T, NPCCreateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NPCS.
     * @param {NPCCreateManyArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPCCreateManyArgs>(args?: SelectSubset<T, NPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPCS and returns the data saved in the database.
     * @param {NPCCreateManyAndReturnArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPCCreateManyAndReturnArgs>(args?: SelectSubset<T, NPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NPC.
     * @param {NPCDeleteArgs} args - Arguments to delete one NPC.
     * @example
     * // Delete one NPC
     * const NPC = await prisma.nPC.delete({
     *   where: {
     *     // ... filter to delete one NPC
     *   }
     * })
     * 
     */
    delete<T extends NPCDeleteArgs>(args: SelectSubset<T, NPCDeleteArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NPC.
     * @param {NPCUpdateArgs} args - Arguments to update one NPC.
     * @example
     * // Update one NPC
     * const nPC = await prisma.nPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPCUpdateArgs>(args: SelectSubset<T, NPCUpdateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NPCS.
     * @param {NPCDeleteManyArgs} args - Arguments to filter NPCS to delete.
     * @example
     * // Delete a few NPCS
     * const { count } = await prisma.nPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPCDeleteManyArgs>(args?: SelectSubset<T, NPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPCUpdateManyArgs>(args: SelectSubset<T, NPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS and returns the data updated in the database.
     * @param {NPCUpdateManyAndReturnArgs} args - Arguments to update many NPCS.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NPCUpdateManyAndReturnArgs>(args: SelectSubset<T, NPCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NPC.
     * @param {NPCUpsertArgs} args - Arguments to update or create a NPC.
     * @example
     * // Update or create a NPC
     * const nPC = await prisma.nPC.upsert({
     *   create: {
     *     // ... data to create a NPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPC we want to update
     *   }
     * })
     */
    upsert<T extends NPCUpsertArgs>(args: SelectSubset<T, NPCUpsertArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCCountArgs} args - Arguments to filter NPCS to count.
     * @example
     * // Count the number of NPCS
     * const count = await prisma.nPC.count({
     *   where: {
     *     // ... the filter for the NPCS we want to count
     *   }
     * })
    **/
    count<T extends NPCCountArgs>(
      args?: Subset<T, NPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPCAggregateArgs>(args: Subset<T, NPCAggregateArgs>): Prisma.PrismaPromise<GetNPCAggregateType<T>>

    /**
     * Group by NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPCGroupByArgs['orderBy'] }
        : { orderBy?: NPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPC model
   */
  readonly fields: NPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    locations<T extends NPC$locationsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questsGiven<T extends NPC$questsGivenArgs<ExtArgs> = {}>(args?: Subset<T, NPC$questsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questsInvolved<T extends NPC$questsInvolvedArgs<ExtArgs> = {}>(args?: Subset<T, NPC$questsInvolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends NPC$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends NPC$itemsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPC model
   */
  interface NPCFieldRefs {
    readonly id: FieldRef<"NPC", 'String'>
    readonly campaignId: FieldRef<"NPC", 'String'>
    readonly name: FieldRef<"NPC", 'String'>
    readonly title: FieldRef<"NPC", 'String'>
    readonly race: FieldRef<"NPC", 'Race'>
    readonly creatureType: FieldRef<"NPC", 'CreatureType'>
    readonly role: FieldRef<"NPC", 'NPCRole'>
    readonly class: FieldRef<"NPC", 'CharacterClass'>
    readonly alignment: FieldRef<"NPC", 'Alignment'>
    readonly attitudeToParty: FieldRef<"NPC", 'NPCAttitude'>
    readonly languages: FieldRef<"NPC", 'Json'>
    readonly appearance: FieldRef<"NPC", 'String'>
    readonly personality: FieldRef<"NPC", 'String'>
    readonly motivations: FieldRef<"NPC", 'String'>
    readonly backstory: FieldRef<"NPC", 'String'>
    readonly dmNotes: FieldRef<"NPC", 'String'>
    readonly portraitPath: FieldRef<"NPC", 'String'>
    readonly createdAt: FieldRef<"NPC", 'DateTime'>
    readonly updatedAt: FieldRef<"NPC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NPC findUnique
   */
  export type NPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findUniqueOrThrow
   */
  export type NPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findFirst
   */
  export type NPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findFirstOrThrow
   */
  export type NPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findMany
   */
  export type NPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPCS to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC create
   */
  export type NPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to create a NPC.
     */
    data: XOR<NPCCreateInput, NPCUncheckedCreateInput>
  }

  /**
   * NPC createMany
   */
  export type NPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
  }

  /**
   * NPC createManyAndReturn
   */
  export type NPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC update
   */
  export type NPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to update a NPC.
     */
    data: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
    /**
     * Choose, which NPC to update.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC updateMany
   */
  export type NPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to update.
     */
    limit?: number
  }

  /**
   * NPC updateManyAndReturn
   */
  export type NPCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC upsert
   */
  export type NPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The filter to search for the NPC to update in case it exists.
     */
    where: NPCWhereUniqueInput
    /**
     * In case the NPC found by the `where` argument doesn't exist, create a new NPC with this data.
     */
    create: XOR<NPCCreateInput, NPCUncheckedCreateInput>
    /**
     * In case the NPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
  }

  /**
   * NPC delete
   */
  export type NPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter which NPC to delete.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC deleteMany
   */
  export type NPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCS to delete
     */
    where?: NPCWhereInput
    /**
     * Limit how many NPCS to delete.
     */
    limit?: number
  }

  /**
   * NPC.locations
   */
  export type NPC$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    where?: NPCLocationWhereInput
    orderBy?: NPCLocationOrderByWithRelationInput | NPCLocationOrderByWithRelationInput[]
    cursor?: NPCLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCLocationScalarFieldEnum | NPCLocationScalarFieldEnum[]
  }

  /**
   * NPC.questsGiven
   */
  export type NPC$questsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * NPC.questsInvolved
   */
  export type NPC$questsInvolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    where?: QuestNPCWhereInput
    orderBy?: QuestNPCOrderByWithRelationInput | QuestNPCOrderByWithRelationInput[]
    cursor?: QuestNPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestNPCScalarFieldEnum | QuestNPCScalarFieldEnum[]
  }

  /**
   * NPC.interactions
   */
  export type NPC$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * NPC.items
   */
  export type NPC$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    where?: ItemNPCWhereInput
    orderBy?: ItemNPCOrderByWithRelationInput | ItemNPCOrderByWithRelationInput[]
    cursor?: ItemNPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemNPCScalarFieldEnum | ItemNPCScalarFieldEnum[]
  }

  /**
   * NPC without action
   */
  export type NPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    parentLocationId: string | null
    name: string | null
    type: $Enums.LocationType | null
    description: string | null
    coverImagePath: string | null
    dmNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    parentLocationId: string | null
    name: string | null
    type: $Enums.LocationType | null
    description: string | null
    coverImagePath: string | null
    dmNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    campaignId: number
    parentLocationId: number
    name: number
    type: number
    description: number
    notableFeatures: number
    coverImagePath: number
    dmNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    campaignId?: true
    parentLocationId?: true
    name?: true
    type?: true
    description?: true
    coverImagePath?: true
    dmNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    campaignId?: true
    parentLocationId?: true
    name?: true
    type?: true
    description?: true
    coverImagePath?: true
    dmNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    campaignId?: true
    parentLocationId?: true
    name?: true
    type?: true
    description?: true
    notableFeatures?: true
    coverImagePath?: true
    dmNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    campaignId: string
    parentLocationId: string | null
    name: string
    type: $Enums.LocationType
    description: string | null
    notableFeatures: JsonValue | null
    coverImagePath: string | null
    dmNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    parentLocationId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    notableFeatures?: boolean
    coverImagePath?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentLocation?: boolean | Location$parentLocationArgs<ExtArgs>
    childLocations?: boolean | Location$childLocationsArgs<ExtArgs>
    maps?: boolean | Location$mapsArgs<ExtArgs>
    encounters?: boolean | Location$encountersArgs<ExtArgs>
    npcs?: boolean | Location$npcsArgs<ExtArgs>
    quests?: boolean | Location$questsArgs<ExtArgs>
    items?: boolean | Location$itemsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    parentLocationId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    notableFeatures?: boolean
    coverImagePath?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentLocation?: boolean | Location$parentLocationArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    parentLocationId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    notableFeatures?: boolean
    coverImagePath?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentLocation?: boolean | Location$parentLocationArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    campaignId?: boolean
    parentLocationId?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    notableFeatures?: boolean
    coverImagePath?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "parentLocationId" | "name" | "type" | "description" | "notableFeatures" | "coverImagePath" | "dmNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentLocation?: boolean | Location$parentLocationArgs<ExtArgs>
    childLocations?: boolean | Location$childLocationsArgs<ExtArgs>
    maps?: boolean | Location$mapsArgs<ExtArgs>
    encounters?: boolean | Location$encountersArgs<ExtArgs>
    npcs?: boolean | Location$npcsArgs<ExtArgs>
    quests?: boolean | Location$questsArgs<ExtArgs>
    items?: boolean | Location$itemsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentLocation?: boolean | Location$parentLocationArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentLocation?: boolean | Location$parentLocationArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      parentLocation: Prisma.$LocationPayload<ExtArgs> | null
      childLocations: Prisma.$LocationPayload<ExtArgs>[]
      maps: Prisma.$MapPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      npcs: Prisma.$NPCLocationPayload<ExtArgs>[]
      quests: Prisma.$QuestLocationPayload<ExtArgs>[]
      items: Prisma.$ItemLocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      parentLocationId: string | null
      name: string
      type: $Enums.LocationType
      description: string | null
      notableFeatures: Prisma.JsonValue | null
      coverImagePath: string | null
      dmNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentLocation<T extends Location$parentLocationArgs<ExtArgs> = {}>(args?: Subset<T, Location$parentLocationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childLocations<T extends Location$childLocationsArgs<ExtArgs> = {}>(args?: Subset<T, Location$childLocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maps<T extends Location$mapsArgs<ExtArgs> = {}>(args?: Subset<T, Location$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounters<T extends Location$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Location$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    npcs<T extends Location$npcsArgs<ExtArgs> = {}>(args?: Subset<T, Location$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quests<T extends Location$questsArgs<ExtArgs> = {}>(args?: Subset<T, Location$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Location$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Location$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly campaignId: FieldRef<"Location", 'String'>
    readonly parentLocationId: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly type: FieldRef<"Location", 'LocationType'>
    readonly description: FieldRef<"Location", 'String'>
    readonly notableFeatures: FieldRef<"Location", 'Json'>
    readonly coverImagePath: FieldRef<"Location", 'String'>
    readonly dmNotes: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.parentLocation
   */
  export type Location$parentLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Location.childLocations
   */
  export type Location$childLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location.maps
   */
  export type Location$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    cursor?: MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Location.encounters
   */
  export type Location$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Location.npcs
   */
  export type Location$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    where?: NPCLocationWhereInput
    orderBy?: NPCLocationOrderByWithRelationInput | NPCLocationOrderByWithRelationInput[]
    cursor?: NPCLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCLocationScalarFieldEnum | NPCLocationScalarFieldEnum[]
  }

  /**
   * Location.quests
   */
  export type Location$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    where?: QuestLocationWhereInput
    orderBy?: QuestLocationOrderByWithRelationInput | QuestLocationOrderByWithRelationInput[]
    cursor?: QuestLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestLocationScalarFieldEnum | QuestLocationScalarFieldEnum[]
  }

  /**
   * Location.items
   */
  export type Location$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    where?: ItemLocationWhereInput
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    cursor?: ItemLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Map
   */

  export type AggregateMap = {
    _count: MapCountAggregateOutputType | null
    _avg: MapAvgAggregateOutputType | null
    _sum: MapSumAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  export type MapAvgAggregateOutputType = {
    gridSize: number | null
    width: number | null
    height: number | null
  }

  export type MapSumAggregateOutputType = {
    gridSize: number | null
    width: number | null
    height: number | null
  }

  export type MapMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    locationId: string | null
    name: string | null
    imagePath: string | null
    gridSize: number | null
    gridEnabled: boolean | null
    scale: string | null
    width: number | null
    height: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    locationId: string | null
    name: string | null
    imagePath: string | null
    gridSize: number | null
    gridEnabled: boolean | null
    scale: string | null
    width: number | null
    height: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MapCountAggregateOutputType = {
    id: number
    campaignId: number
    locationId: number
    name: number
    imagePath: number
    gridSize: number
    gridEnabled: number
    scale: number
    width: number
    height: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MapAvgAggregateInputType = {
    gridSize?: true
    width?: true
    height?: true
  }

  export type MapSumAggregateInputType = {
    gridSize?: true
    width?: true
    height?: true
  }

  export type MapMinAggregateInputType = {
    id?: true
    campaignId?: true
    locationId?: true
    name?: true
    imagePath?: true
    gridSize?: true
    gridEnabled?: true
    scale?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapMaxAggregateInputType = {
    id?: true
    campaignId?: true
    locationId?: true
    name?: true
    imagePath?: true
    gridSize?: true
    gridEnabled?: true
    scale?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MapCountAggregateInputType = {
    id?: true
    campaignId?: true
    locationId?: true
    name?: true
    imagePath?: true
    gridSize?: true
    gridEnabled?: true
    scale?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Map to aggregate.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maps
    **/
    _count?: true | MapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapMaxAggregateInputType
  }

  export type GetMapAggregateType<T extends MapAggregateArgs> = {
        [P in keyof T & keyof AggregateMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMap[P]>
      : GetScalarType<T[P], AggregateMap[P]>
  }




  export type MapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
    orderBy?: MapOrderByWithAggregationInput | MapOrderByWithAggregationInput[]
    by: MapScalarFieldEnum[] | MapScalarFieldEnum
    having?: MapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCountAggregateInputType | true
    _avg?: MapAvgAggregateInputType
    _sum?: MapSumAggregateInputType
    _min?: MapMinAggregateInputType
    _max?: MapMaxAggregateInputType
  }

  export type MapGroupByOutputType = {
    id: string
    campaignId: string
    locationId: string | null
    name: string
    imagePath: string
    gridSize: number | null
    gridEnabled: boolean
    scale: string | null
    width: number | null
    height: number | null
    createdAt: Date
    updatedAt: Date
    _count: MapCountAggregateOutputType | null
    _avg: MapAvgAggregateOutputType | null
    _sum: MapSumAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  type GetMapGroupByPayload<T extends MapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapGroupByOutputType[P]>
            : GetScalarType<T[P], MapGroupByOutputType[P]>
        }
      >
    >


  export type MapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    locationId?: boolean
    name?: boolean
    imagePath?: boolean
    gridSize?: boolean
    gridEnabled?: boolean
    scale?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    location?: boolean | Map$locationArgs<ExtArgs>
    annotations?: boolean | Map$annotationsArgs<ExtArgs>
    encounters?: boolean | Map$encountersArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    locationId?: boolean
    name?: boolean
    imagePath?: boolean
    gridSize?: boolean
    gridEnabled?: boolean
    scale?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    location?: boolean | Map$locationArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    locationId?: boolean
    name?: boolean
    imagePath?: boolean
    gridSize?: boolean
    gridEnabled?: boolean
    scale?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    location?: boolean | Map$locationArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectScalar = {
    id?: boolean
    campaignId?: boolean
    locationId?: boolean
    name?: boolean
    imagePath?: boolean
    gridSize?: boolean
    gridEnabled?: boolean
    scale?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "locationId" | "name" | "imagePath" | "gridSize" | "gridEnabled" | "scale" | "width" | "height" | "createdAt" | "updatedAt", ExtArgs["result"]["map"]>
  export type MapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    location?: boolean | Map$locationArgs<ExtArgs>
    annotations?: boolean | Map$annotationsArgs<ExtArgs>
    encounters?: boolean | Map$encountersArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    location?: boolean | Map$locationArgs<ExtArgs>
  }
  export type MapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    location?: boolean | Map$locationArgs<ExtArgs>
  }

  export type $MapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Map"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
      annotations: Prisma.$MapAnnotationPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      locationId: string | null
      name: string
      imagePath: string
      gridSize: number | null
      gridEnabled: boolean
      scale: string | null
      width: number | null
      height: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["map"]>
    composites: {}
  }

  type MapGetPayload<S extends boolean | null | undefined | MapDefaultArgs> = $Result.GetResult<Prisma.$MapPayload, S>

  type MapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapCountAggregateInputType | true
    }

  export interface MapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Map'], meta: { name: 'Map' } }
    /**
     * Find zero or one Map that matches the filter.
     * @param {MapFindUniqueArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapFindUniqueArgs>(args: SelectSubset<T, MapFindUniqueArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapFindUniqueOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapFindUniqueOrThrowArgs>(args: SelectSubset<T, MapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindFirstArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapFindFirstArgs>(args?: SelectSubset<T, MapFindFirstArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindFirstOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapFindFirstOrThrowArgs>(args?: SelectSubset<T, MapFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maps
     * const maps = await prisma.map.findMany()
     * 
     * // Get first 10 Maps
     * const maps = await prisma.map.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapWithIdOnly = await prisma.map.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapFindManyArgs>(args?: SelectSubset<T, MapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Map.
     * @param {MapCreateArgs} args - Arguments to create a Map.
     * @example
     * // Create one Map
     * const Map = await prisma.map.create({
     *   data: {
     *     // ... data to create a Map
     *   }
     * })
     * 
     */
    create<T extends MapCreateArgs>(args: SelectSubset<T, MapCreateArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maps.
     * @param {MapCreateManyArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapCreateManyArgs>(args?: SelectSubset<T, MapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maps and returns the data saved in the database.
     * @param {MapCreateManyAndReturnArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapCreateManyAndReturnArgs>(args?: SelectSubset<T, MapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Map.
     * @param {MapDeleteArgs} args - Arguments to delete one Map.
     * @example
     * // Delete one Map
     * const Map = await prisma.map.delete({
     *   where: {
     *     // ... filter to delete one Map
     *   }
     * })
     * 
     */
    delete<T extends MapDeleteArgs>(args: SelectSubset<T, MapDeleteArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Map.
     * @param {MapUpdateArgs} args - Arguments to update one Map.
     * @example
     * // Update one Map
     * const map = await prisma.map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapUpdateArgs>(args: SelectSubset<T, MapUpdateArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maps.
     * @param {MapDeleteManyArgs} args - Arguments to filter Maps to delete.
     * @example
     * // Delete a few Maps
     * const { count } = await prisma.map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapDeleteManyArgs>(args?: SelectSubset<T, MapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapUpdateManyArgs>(args: SelectSubset<T, MapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps and returns the data updated in the database.
     * @param {MapUpdateManyAndReturnArgs} args - Arguments to update many Maps.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapUpdateManyAndReturnArgs>(args: SelectSubset<T, MapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Map.
     * @param {MapUpsertArgs} args - Arguments to update or create a Map.
     * @example
     * // Update or create a Map
     * const map = await prisma.map.upsert({
     *   create: {
     *     // ... data to create a Map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Map we want to update
     *   }
     * })
     */
    upsert<T extends MapUpsertArgs>(args: SelectSubset<T, MapUpsertArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCountArgs} args - Arguments to filter Maps to count.
     * @example
     * // Count the number of Maps
     * const count = await prisma.map.count({
     *   where: {
     *     // ... the filter for the Maps we want to count
     *   }
     * })
    **/
    count<T extends MapCountArgs>(
      args?: Subset<T, MapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapAggregateArgs>(args: Subset<T, MapAggregateArgs>): Prisma.PrismaPromise<GetMapAggregateType<T>>

    /**
     * Group by Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapGroupByArgs['orderBy'] }
        : { orderBy?: MapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Map model
   */
  readonly fields: MapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends Map$locationArgs<ExtArgs> = {}>(args?: Subset<T, Map$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    annotations<T extends Map$annotationsArgs<ExtArgs> = {}>(args?: Subset<T, Map$annotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounters<T extends Map$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Map$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Map model
   */
  interface MapFieldRefs {
    readonly id: FieldRef<"Map", 'String'>
    readonly campaignId: FieldRef<"Map", 'String'>
    readonly locationId: FieldRef<"Map", 'String'>
    readonly name: FieldRef<"Map", 'String'>
    readonly imagePath: FieldRef<"Map", 'String'>
    readonly gridSize: FieldRef<"Map", 'Int'>
    readonly gridEnabled: FieldRef<"Map", 'Boolean'>
    readonly scale: FieldRef<"Map", 'String'>
    readonly width: FieldRef<"Map", 'Int'>
    readonly height: FieldRef<"Map", 'Int'>
    readonly createdAt: FieldRef<"Map", 'DateTime'>
    readonly updatedAt: FieldRef<"Map", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Map findUnique
   */
  export type MapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map findUniqueOrThrow
   */
  export type MapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map findFirst
   */
  export type MapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map findFirstOrThrow
   */
  export type MapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map findMany
   */
  export type MapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map create
   */
  export type MapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The data needed to create a Map.
     */
    data: XOR<MapCreateInput, MapUncheckedCreateInput>
  }

  /**
   * Map createMany
   */
  export type MapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maps.
     */
    data: MapCreateManyInput | MapCreateManyInput[]
  }

  /**
   * Map createManyAndReturn
   */
  export type MapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * The data used to create many Maps.
     */
    data: MapCreateManyInput | MapCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Map update
   */
  export type MapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The data needed to update a Map.
     */
    data: XOR<MapUpdateInput, MapUncheckedUpdateInput>
    /**
     * Choose, which Map to update.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map updateMany
   */
  export type MapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maps.
     */
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
  }

  /**
   * Map updateManyAndReturn
   */
  export type MapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * The data used to update Maps.
     */
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Map upsert
   */
  export type MapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The filter to search for the Map to update in case it exists.
     */
    where: MapWhereUniqueInput
    /**
     * In case the Map found by the `where` argument doesn't exist, create a new Map with this data.
     */
    create: XOR<MapCreateInput, MapUncheckedCreateInput>
    /**
     * In case the Map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapUpdateInput, MapUncheckedUpdateInput>
  }

  /**
   * Map delete
   */
  export type MapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter which Map to delete.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map deleteMany
   */
  export type MapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maps to delete
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to delete.
     */
    limit?: number
  }

  /**
   * Map.location
   */
  export type Map$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Map.annotations
   */
  export type Map$annotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    where?: MapAnnotationWhereInput
    orderBy?: MapAnnotationOrderByWithRelationInput | MapAnnotationOrderByWithRelationInput[]
    cursor?: MapAnnotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapAnnotationScalarFieldEnum | MapAnnotationScalarFieldEnum[]
  }

  /**
   * Map.encounters
   */
  export type Map$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Map without action
   */
  export type MapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
  }


  /**
   * Model MapAnnotation
   */

  export type AggregateMapAnnotation = {
    _count: MapAnnotationCountAggregateOutputType | null
    _avg: MapAnnotationAvgAggregateOutputType | null
    _sum: MapAnnotationSumAggregateOutputType | null
    _min: MapAnnotationMinAggregateOutputType | null
    _max: MapAnnotationMaxAggregateOutputType | null
  }

  export type MapAnnotationAvgAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type MapAnnotationSumAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type MapAnnotationMinAggregateOutputType = {
    id: string | null
    mapId: string | null
    type: $Enums.MapAnnotationType | null
    x: number | null
    y: number | null
    title: string | null
    content: string | null
    isHidden: boolean | null
  }

  export type MapAnnotationMaxAggregateOutputType = {
    id: string | null
    mapId: string | null
    type: $Enums.MapAnnotationType | null
    x: number | null
    y: number | null
    title: string | null
    content: string | null
    isHidden: boolean | null
  }

  export type MapAnnotationCountAggregateOutputType = {
    id: number
    mapId: number
    type: number
    x: number
    y: number
    title: number
    content: number
    isHidden: number
    _all: number
  }


  export type MapAnnotationAvgAggregateInputType = {
    x?: true
    y?: true
  }

  export type MapAnnotationSumAggregateInputType = {
    x?: true
    y?: true
  }

  export type MapAnnotationMinAggregateInputType = {
    id?: true
    mapId?: true
    type?: true
    x?: true
    y?: true
    title?: true
    content?: true
    isHidden?: true
  }

  export type MapAnnotationMaxAggregateInputType = {
    id?: true
    mapId?: true
    type?: true
    x?: true
    y?: true
    title?: true
    content?: true
    isHidden?: true
  }

  export type MapAnnotationCountAggregateInputType = {
    id?: true
    mapId?: true
    type?: true
    x?: true
    y?: true
    title?: true
    content?: true
    isHidden?: true
    _all?: true
  }

  export type MapAnnotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapAnnotation to aggregate.
     */
    where?: MapAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapAnnotations to fetch.
     */
    orderBy?: MapAnnotationOrderByWithRelationInput | MapAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapAnnotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapAnnotations
    **/
    _count?: true | MapAnnotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapAnnotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapAnnotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapAnnotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapAnnotationMaxAggregateInputType
  }

  export type GetMapAnnotationAggregateType<T extends MapAnnotationAggregateArgs> = {
        [P in keyof T & keyof AggregateMapAnnotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapAnnotation[P]>
      : GetScalarType<T[P], AggregateMapAnnotation[P]>
  }




  export type MapAnnotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapAnnotationWhereInput
    orderBy?: MapAnnotationOrderByWithAggregationInput | MapAnnotationOrderByWithAggregationInput[]
    by: MapAnnotationScalarFieldEnum[] | MapAnnotationScalarFieldEnum
    having?: MapAnnotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapAnnotationCountAggregateInputType | true
    _avg?: MapAnnotationAvgAggregateInputType
    _sum?: MapAnnotationSumAggregateInputType
    _min?: MapAnnotationMinAggregateInputType
    _max?: MapAnnotationMaxAggregateInputType
  }

  export type MapAnnotationGroupByOutputType = {
    id: string
    mapId: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title: string | null
    content: string | null
    isHidden: boolean
    _count: MapAnnotationCountAggregateOutputType | null
    _avg: MapAnnotationAvgAggregateOutputType | null
    _sum: MapAnnotationSumAggregateOutputType | null
    _min: MapAnnotationMinAggregateOutputType | null
    _max: MapAnnotationMaxAggregateOutputType | null
  }

  type GetMapAnnotationGroupByPayload<T extends MapAnnotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapAnnotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapAnnotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapAnnotationGroupByOutputType[P]>
            : GetScalarType<T[P], MapAnnotationGroupByOutputType[P]>
        }
      >
    >


  export type MapAnnotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mapId?: boolean
    type?: boolean
    x?: boolean
    y?: boolean
    title?: boolean
    content?: boolean
    isHidden?: boolean
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapAnnotation"]>

  export type MapAnnotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mapId?: boolean
    type?: boolean
    x?: boolean
    y?: boolean
    title?: boolean
    content?: boolean
    isHidden?: boolean
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapAnnotation"]>

  export type MapAnnotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mapId?: boolean
    type?: boolean
    x?: boolean
    y?: boolean
    title?: boolean
    content?: boolean
    isHidden?: boolean
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapAnnotation"]>

  export type MapAnnotationSelectScalar = {
    id?: boolean
    mapId?: boolean
    type?: boolean
    x?: boolean
    y?: boolean
    title?: boolean
    content?: boolean
    isHidden?: boolean
  }

  export type MapAnnotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mapId" | "type" | "x" | "y" | "title" | "content" | "isHidden", ExtArgs["result"]["mapAnnotation"]>
  export type MapAnnotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | MapDefaultArgs<ExtArgs>
  }
  export type MapAnnotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | MapDefaultArgs<ExtArgs>
  }
  export type MapAnnotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    map?: boolean | MapDefaultArgs<ExtArgs>
  }

  export type $MapAnnotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapAnnotation"
    objects: {
      map: Prisma.$MapPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mapId: string
      type: $Enums.MapAnnotationType
      x: number
      y: number
      title: string | null
      content: string | null
      isHidden: boolean
    }, ExtArgs["result"]["mapAnnotation"]>
    composites: {}
  }

  type MapAnnotationGetPayload<S extends boolean | null | undefined | MapAnnotationDefaultArgs> = $Result.GetResult<Prisma.$MapAnnotationPayload, S>

  type MapAnnotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapAnnotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapAnnotationCountAggregateInputType | true
    }

  export interface MapAnnotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapAnnotation'], meta: { name: 'MapAnnotation' } }
    /**
     * Find zero or one MapAnnotation that matches the filter.
     * @param {MapAnnotationFindUniqueArgs} args - Arguments to find a MapAnnotation
     * @example
     * // Get one MapAnnotation
     * const mapAnnotation = await prisma.mapAnnotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapAnnotationFindUniqueArgs>(args: SelectSubset<T, MapAnnotationFindUniqueArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapAnnotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapAnnotationFindUniqueOrThrowArgs} args - Arguments to find a MapAnnotation
     * @example
     * // Get one MapAnnotation
     * const mapAnnotation = await prisma.mapAnnotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapAnnotationFindUniqueOrThrowArgs>(args: SelectSubset<T, MapAnnotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapAnnotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationFindFirstArgs} args - Arguments to find a MapAnnotation
     * @example
     * // Get one MapAnnotation
     * const mapAnnotation = await prisma.mapAnnotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapAnnotationFindFirstArgs>(args?: SelectSubset<T, MapAnnotationFindFirstArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapAnnotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationFindFirstOrThrowArgs} args - Arguments to find a MapAnnotation
     * @example
     * // Get one MapAnnotation
     * const mapAnnotation = await prisma.mapAnnotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapAnnotationFindFirstOrThrowArgs>(args?: SelectSubset<T, MapAnnotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapAnnotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapAnnotations
     * const mapAnnotations = await prisma.mapAnnotation.findMany()
     * 
     * // Get first 10 MapAnnotations
     * const mapAnnotations = await prisma.mapAnnotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapAnnotationWithIdOnly = await prisma.mapAnnotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapAnnotationFindManyArgs>(args?: SelectSubset<T, MapAnnotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapAnnotation.
     * @param {MapAnnotationCreateArgs} args - Arguments to create a MapAnnotation.
     * @example
     * // Create one MapAnnotation
     * const MapAnnotation = await prisma.mapAnnotation.create({
     *   data: {
     *     // ... data to create a MapAnnotation
     *   }
     * })
     * 
     */
    create<T extends MapAnnotationCreateArgs>(args: SelectSubset<T, MapAnnotationCreateArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapAnnotations.
     * @param {MapAnnotationCreateManyArgs} args - Arguments to create many MapAnnotations.
     * @example
     * // Create many MapAnnotations
     * const mapAnnotation = await prisma.mapAnnotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapAnnotationCreateManyArgs>(args?: SelectSubset<T, MapAnnotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapAnnotations and returns the data saved in the database.
     * @param {MapAnnotationCreateManyAndReturnArgs} args - Arguments to create many MapAnnotations.
     * @example
     * // Create many MapAnnotations
     * const mapAnnotation = await prisma.mapAnnotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapAnnotations and only return the `id`
     * const mapAnnotationWithIdOnly = await prisma.mapAnnotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapAnnotationCreateManyAndReturnArgs>(args?: SelectSubset<T, MapAnnotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapAnnotation.
     * @param {MapAnnotationDeleteArgs} args - Arguments to delete one MapAnnotation.
     * @example
     * // Delete one MapAnnotation
     * const MapAnnotation = await prisma.mapAnnotation.delete({
     *   where: {
     *     // ... filter to delete one MapAnnotation
     *   }
     * })
     * 
     */
    delete<T extends MapAnnotationDeleteArgs>(args: SelectSubset<T, MapAnnotationDeleteArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapAnnotation.
     * @param {MapAnnotationUpdateArgs} args - Arguments to update one MapAnnotation.
     * @example
     * // Update one MapAnnotation
     * const mapAnnotation = await prisma.mapAnnotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapAnnotationUpdateArgs>(args: SelectSubset<T, MapAnnotationUpdateArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapAnnotations.
     * @param {MapAnnotationDeleteManyArgs} args - Arguments to filter MapAnnotations to delete.
     * @example
     * // Delete a few MapAnnotations
     * const { count } = await prisma.mapAnnotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapAnnotationDeleteManyArgs>(args?: SelectSubset<T, MapAnnotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapAnnotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapAnnotations
     * const mapAnnotation = await prisma.mapAnnotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapAnnotationUpdateManyArgs>(args: SelectSubset<T, MapAnnotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapAnnotations and returns the data updated in the database.
     * @param {MapAnnotationUpdateManyAndReturnArgs} args - Arguments to update many MapAnnotations.
     * @example
     * // Update many MapAnnotations
     * const mapAnnotation = await prisma.mapAnnotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapAnnotations and only return the `id`
     * const mapAnnotationWithIdOnly = await prisma.mapAnnotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapAnnotationUpdateManyAndReturnArgs>(args: SelectSubset<T, MapAnnotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapAnnotation.
     * @param {MapAnnotationUpsertArgs} args - Arguments to update or create a MapAnnotation.
     * @example
     * // Update or create a MapAnnotation
     * const mapAnnotation = await prisma.mapAnnotation.upsert({
     *   create: {
     *     // ... data to create a MapAnnotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapAnnotation we want to update
     *   }
     * })
     */
    upsert<T extends MapAnnotationUpsertArgs>(args: SelectSubset<T, MapAnnotationUpsertArgs<ExtArgs>>): Prisma__MapAnnotationClient<$Result.GetResult<Prisma.$MapAnnotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapAnnotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationCountArgs} args - Arguments to filter MapAnnotations to count.
     * @example
     * // Count the number of MapAnnotations
     * const count = await prisma.mapAnnotation.count({
     *   where: {
     *     // ... the filter for the MapAnnotations we want to count
     *   }
     * })
    **/
    count<T extends MapAnnotationCountArgs>(
      args?: Subset<T, MapAnnotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapAnnotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapAnnotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapAnnotationAggregateArgs>(args: Subset<T, MapAnnotationAggregateArgs>): Prisma.PrismaPromise<GetMapAnnotationAggregateType<T>>

    /**
     * Group by MapAnnotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAnnotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapAnnotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapAnnotationGroupByArgs['orderBy'] }
        : { orderBy?: MapAnnotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapAnnotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapAnnotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapAnnotation model
   */
  readonly fields: MapAnnotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapAnnotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapAnnotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    map<T extends MapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MapDefaultArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapAnnotation model
   */
  interface MapAnnotationFieldRefs {
    readonly id: FieldRef<"MapAnnotation", 'String'>
    readonly mapId: FieldRef<"MapAnnotation", 'String'>
    readonly type: FieldRef<"MapAnnotation", 'MapAnnotationType'>
    readonly x: FieldRef<"MapAnnotation", 'Float'>
    readonly y: FieldRef<"MapAnnotation", 'Float'>
    readonly title: FieldRef<"MapAnnotation", 'String'>
    readonly content: FieldRef<"MapAnnotation", 'String'>
    readonly isHidden: FieldRef<"MapAnnotation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MapAnnotation findUnique
   */
  export type MapAnnotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which MapAnnotation to fetch.
     */
    where: MapAnnotationWhereUniqueInput
  }

  /**
   * MapAnnotation findUniqueOrThrow
   */
  export type MapAnnotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which MapAnnotation to fetch.
     */
    where: MapAnnotationWhereUniqueInput
  }

  /**
   * MapAnnotation findFirst
   */
  export type MapAnnotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which MapAnnotation to fetch.
     */
    where?: MapAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapAnnotations to fetch.
     */
    orderBy?: MapAnnotationOrderByWithRelationInput | MapAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapAnnotations.
     */
    cursor?: MapAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapAnnotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapAnnotations.
     */
    distinct?: MapAnnotationScalarFieldEnum | MapAnnotationScalarFieldEnum[]
  }

  /**
   * MapAnnotation findFirstOrThrow
   */
  export type MapAnnotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which MapAnnotation to fetch.
     */
    where?: MapAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapAnnotations to fetch.
     */
    orderBy?: MapAnnotationOrderByWithRelationInput | MapAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapAnnotations.
     */
    cursor?: MapAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapAnnotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapAnnotations.
     */
    distinct?: MapAnnotationScalarFieldEnum | MapAnnotationScalarFieldEnum[]
  }

  /**
   * MapAnnotation findMany
   */
  export type MapAnnotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * Filter, which MapAnnotations to fetch.
     */
    where?: MapAnnotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapAnnotations to fetch.
     */
    orderBy?: MapAnnotationOrderByWithRelationInput | MapAnnotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapAnnotations.
     */
    cursor?: MapAnnotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapAnnotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapAnnotations.
     */
    skip?: number
    distinct?: MapAnnotationScalarFieldEnum | MapAnnotationScalarFieldEnum[]
  }

  /**
   * MapAnnotation create
   */
  export type MapAnnotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * The data needed to create a MapAnnotation.
     */
    data: XOR<MapAnnotationCreateInput, MapAnnotationUncheckedCreateInput>
  }

  /**
   * MapAnnotation createMany
   */
  export type MapAnnotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapAnnotations.
     */
    data: MapAnnotationCreateManyInput | MapAnnotationCreateManyInput[]
  }

  /**
   * MapAnnotation createManyAndReturn
   */
  export type MapAnnotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * The data used to create many MapAnnotations.
     */
    data: MapAnnotationCreateManyInput | MapAnnotationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapAnnotation update
   */
  export type MapAnnotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * The data needed to update a MapAnnotation.
     */
    data: XOR<MapAnnotationUpdateInput, MapAnnotationUncheckedUpdateInput>
    /**
     * Choose, which MapAnnotation to update.
     */
    where: MapAnnotationWhereUniqueInput
  }

  /**
   * MapAnnotation updateMany
   */
  export type MapAnnotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapAnnotations.
     */
    data: XOR<MapAnnotationUpdateManyMutationInput, MapAnnotationUncheckedUpdateManyInput>
    /**
     * Filter which MapAnnotations to update
     */
    where?: MapAnnotationWhereInput
    /**
     * Limit how many MapAnnotations to update.
     */
    limit?: number
  }

  /**
   * MapAnnotation updateManyAndReturn
   */
  export type MapAnnotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * The data used to update MapAnnotations.
     */
    data: XOR<MapAnnotationUpdateManyMutationInput, MapAnnotationUncheckedUpdateManyInput>
    /**
     * Filter which MapAnnotations to update
     */
    where?: MapAnnotationWhereInput
    /**
     * Limit how many MapAnnotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapAnnotation upsert
   */
  export type MapAnnotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * The filter to search for the MapAnnotation to update in case it exists.
     */
    where: MapAnnotationWhereUniqueInput
    /**
     * In case the MapAnnotation found by the `where` argument doesn't exist, create a new MapAnnotation with this data.
     */
    create: XOR<MapAnnotationCreateInput, MapAnnotationUncheckedCreateInput>
    /**
     * In case the MapAnnotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapAnnotationUpdateInput, MapAnnotationUncheckedUpdateInput>
  }

  /**
   * MapAnnotation delete
   */
  export type MapAnnotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
    /**
     * Filter which MapAnnotation to delete.
     */
    where: MapAnnotationWhereUniqueInput
  }

  /**
   * MapAnnotation deleteMany
   */
  export type MapAnnotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapAnnotations to delete
     */
    where?: MapAnnotationWhereInput
    /**
     * Limit how many MapAnnotations to delete.
     */
    limit?: number
  }

  /**
   * MapAnnotation without action
   */
  export type MapAnnotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapAnnotation
     */
    select?: MapAnnotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapAnnotation
     */
    omit?: MapAnnotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapAnnotationInclude<ExtArgs> | null
  }


  /**
   * Model Monster
   */

  export type AggregateMonster = {
    _count: MonsterCountAggregateOutputType | null
    _avg: MonsterAvgAggregateOutputType | null
    _sum: MonsterSumAggregateOutputType | null
    _min: MonsterMinAggregateOutputType | null
    _max: MonsterMaxAggregateOutputType | null
  }

  export type MonsterAvgAggregateOutputType = {
    hpMax: number | null
    ac: number | null
    challengeRating: number | null
  }

  export type MonsterSumAggregateOutputType = {
    hpMax: number | null
    ac: number | null
    challengeRating: number | null
  }

  export type MonsterMinAggregateOutputType = {
    id: string | null
    name: string | null
    size: $Enums.Size | null
    creatureType: $Enums.CreatureType | null
    alignment: $Enums.Alignment | null
    portraitPath: string | null
    hpMax: number | null
    hpDice: string | null
    ac: number | null
    acDescription: string | null
    senses: string | null
    challengeRating: number | null
    description: string | null
    dmNotes: string | null
    isTemplate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonsterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    size: $Enums.Size | null
    creatureType: $Enums.CreatureType | null
    alignment: $Enums.Alignment | null
    portraitPath: string | null
    hpMax: number | null
    hpDice: string | null
    ac: number | null
    acDescription: string | null
    senses: string | null
    challengeRating: number | null
    description: string | null
    dmNotes: string | null
    isTemplate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MonsterCountAggregateOutputType = {
    id: number
    name: number
    size: number
    creatureType: number
    alignment: number
    portraitPath: number
    hpMax: number
    hpDice: number
    ac: number
    acDescription: number
    speed: number
    abilities: number
    savingThrows: number
    skills: number
    damageResistances: number
    damageImmunities: number
    conditionImmunities: number
    senses: number
    languages: number
    challengeRating: number
    actions: number
    reactions: number
    legendaryActions: number
    description: number
    dmNotes: number
    isTemplate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MonsterAvgAggregateInputType = {
    hpMax?: true
    ac?: true
    challengeRating?: true
  }

  export type MonsterSumAggregateInputType = {
    hpMax?: true
    ac?: true
    challengeRating?: true
  }

  export type MonsterMinAggregateInputType = {
    id?: true
    name?: true
    size?: true
    creatureType?: true
    alignment?: true
    portraitPath?: true
    hpMax?: true
    hpDice?: true
    ac?: true
    acDescription?: true
    senses?: true
    challengeRating?: true
    description?: true
    dmNotes?: true
    isTemplate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonsterMaxAggregateInputType = {
    id?: true
    name?: true
    size?: true
    creatureType?: true
    alignment?: true
    portraitPath?: true
    hpMax?: true
    hpDice?: true
    ac?: true
    acDescription?: true
    senses?: true
    challengeRating?: true
    description?: true
    dmNotes?: true
    isTemplate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MonsterCountAggregateInputType = {
    id?: true
    name?: true
    size?: true
    creatureType?: true
    alignment?: true
    portraitPath?: true
    hpMax?: true
    hpDice?: true
    ac?: true
    acDescription?: true
    speed?: true
    abilities?: true
    savingThrows?: true
    skills?: true
    damageResistances?: true
    damageImmunities?: true
    conditionImmunities?: true
    senses?: true
    languages?: true
    challengeRating?: true
    actions?: true
    reactions?: true
    legendaryActions?: true
    description?: true
    dmNotes?: true
    isTemplate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MonsterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monster to aggregate.
     */
    where?: MonsterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monsters to fetch.
     */
    orderBy?: MonsterOrderByWithRelationInput | MonsterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonsterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monsters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monsters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monsters
    **/
    _count?: true | MonsterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonsterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonsterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonsterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonsterMaxAggregateInputType
  }

  export type GetMonsterAggregateType<T extends MonsterAggregateArgs> = {
        [P in keyof T & keyof AggregateMonster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonster[P]>
      : GetScalarType<T[P], AggregateMonster[P]>
  }




  export type MonsterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonsterWhereInput
    orderBy?: MonsterOrderByWithAggregationInput | MonsterOrderByWithAggregationInput[]
    by: MonsterScalarFieldEnum[] | MonsterScalarFieldEnum
    having?: MonsterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonsterCountAggregateInputType | true
    _avg?: MonsterAvgAggregateInputType
    _sum?: MonsterSumAggregateInputType
    _min?: MonsterMinAggregateInputType
    _max?: MonsterMaxAggregateInputType
  }

  export type MonsterGroupByOutputType = {
    id: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath: string | null
    hpMax: number
    hpDice: string | null
    ac: number
    acDescription: string | null
    speed: JsonValue
    abilities: JsonValue
    savingThrows: JsonValue | null
    skills: JsonValue | null
    damageResistances: JsonValue | null
    damageImmunities: JsonValue | null
    conditionImmunities: JsonValue | null
    senses: string | null
    languages: JsonValue | null
    challengeRating: number
    actions: JsonValue | null
    reactions: JsonValue | null
    legendaryActions: JsonValue | null
    description: string | null
    dmNotes: string | null
    isTemplate: boolean
    createdAt: Date
    updatedAt: Date
    _count: MonsterCountAggregateOutputType | null
    _avg: MonsterAvgAggregateOutputType | null
    _sum: MonsterSumAggregateOutputType | null
    _min: MonsterMinAggregateOutputType | null
    _max: MonsterMaxAggregateOutputType | null
  }

  type GetMonsterGroupByPayload<T extends MonsterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonsterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonsterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonsterGroupByOutputType[P]>
            : GetScalarType<T[P], MonsterGroupByOutputType[P]>
        }
      >
    >


  export type MonsterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    size?: boolean
    creatureType?: boolean
    alignment?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    hpDice?: boolean
    ac?: boolean
    acDescription?: boolean
    speed?: boolean
    abilities?: boolean
    savingThrows?: boolean
    skills?: boolean
    damageResistances?: boolean
    damageImmunities?: boolean
    conditionImmunities?: boolean
    senses?: boolean
    languages?: boolean
    challengeRating?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    description?: boolean
    dmNotes?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaigns?: boolean | Monster$campaignsArgs<ExtArgs>
    encounterParticipants?: boolean | Monster$encounterParticipantsArgs<ExtArgs>
    _count?: boolean | MonsterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monster"]>

  export type MonsterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    size?: boolean
    creatureType?: boolean
    alignment?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    hpDice?: boolean
    ac?: boolean
    acDescription?: boolean
    speed?: boolean
    abilities?: boolean
    savingThrows?: boolean
    skills?: boolean
    damageResistances?: boolean
    damageImmunities?: boolean
    conditionImmunities?: boolean
    senses?: boolean
    languages?: boolean
    challengeRating?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    description?: boolean
    dmNotes?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["monster"]>

  export type MonsterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    size?: boolean
    creatureType?: boolean
    alignment?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    hpDice?: boolean
    ac?: boolean
    acDescription?: boolean
    speed?: boolean
    abilities?: boolean
    savingThrows?: boolean
    skills?: boolean
    damageResistances?: boolean
    damageImmunities?: boolean
    conditionImmunities?: boolean
    senses?: boolean
    languages?: boolean
    challengeRating?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    description?: boolean
    dmNotes?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["monster"]>

  export type MonsterSelectScalar = {
    id?: boolean
    name?: boolean
    size?: boolean
    creatureType?: boolean
    alignment?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    hpDice?: boolean
    ac?: boolean
    acDescription?: boolean
    speed?: boolean
    abilities?: boolean
    savingThrows?: boolean
    skills?: boolean
    damageResistances?: boolean
    damageImmunities?: boolean
    conditionImmunities?: boolean
    senses?: boolean
    languages?: boolean
    challengeRating?: boolean
    actions?: boolean
    reactions?: boolean
    legendaryActions?: boolean
    description?: boolean
    dmNotes?: boolean
    isTemplate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MonsterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "size" | "creatureType" | "alignment" | "portraitPath" | "hpMax" | "hpDice" | "ac" | "acDescription" | "speed" | "abilities" | "savingThrows" | "skills" | "damageResistances" | "damageImmunities" | "conditionImmunities" | "senses" | "languages" | "challengeRating" | "actions" | "reactions" | "legendaryActions" | "description" | "dmNotes" | "isTemplate" | "createdAt" | "updatedAt", ExtArgs["result"]["monster"]>
  export type MonsterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | Monster$campaignsArgs<ExtArgs>
    encounterParticipants?: boolean | Monster$encounterParticipantsArgs<ExtArgs>
    _count?: boolean | MonsterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MonsterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MonsterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MonsterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monster"
    objects: {
      campaigns: Prisma.$MonsterCampaignPayload<ExtArgs>[]
      encounterParticipants: Prisma.$EncounterParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      size: $Enums.Size
      creatureType: $Enums.CreatureType
      alignment: $Enums.Alignment
      portraitPath: string | null
      hpMax: number
      hpDice: string | null
      ac: number
      acDescription: string | null
      speed: Prisma.JsonValue
      abilities: Prisma.JsonValue
      savingThrows: Prisma.JsonValue | null
      skills: Prisma.JsonValue | null
      damageResistances: Prisma.JsonValue | null
      damageImmunities: Prisma.JsonValue | null
      conditionImmunities: Prisma.JsonValue | null
      senses: string | null
      languages: Prisma.JsonValue | null
      challengeRating: number
      actions: Prisma.JsonValue | null
      reactions: Prisma.JsonValue | null
      legendaryActions: Prisma.JsonValue | null
      description: string | null
      dmNotes: string | null
      isTemplate: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["monster"]>
    composites: {}
  }

  type MonsterGetPayload<S extends boolean | null | undefined | MonsterDefaultArgs> = $Result.GetResult<Prisma.$MonsterPayload, S>

  type MonsterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonsterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonsterCountAggregateInputType | true
    }

  export interface MonsterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monster'], meta: { name: 'Monster' } }
    /**
     * Find zero or one Monster that matches the filter.
     * @param {MonsterFindUniqueArgs} args - Arguments to find a Monster
     * @example
     * // Get one Monster
     * const monster = await prisma.monster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonsterFindUniqueArgs>(args: SelectSubset<T, MonsterFindUniqueArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Monster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonsterFindUniqueOrThrowArgs} args - Arguments to find a Monster
     * @example
     * // Get one Monster
     * const monster = await prisma.monster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonsterFindUniqueOrThrowArgs>(args: SelectSubset<T, MonsterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Monster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterFindFirstArgs} args - Arguments to find a Monster
     * @example
     * // Get one Monster
     * const monster = await prisma.monster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonsterFindFirstArgs>(args?: SelectSubset<T, MonsterFindFirstArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Monster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterFindFirstOrThrowArgs} args - Arguments to find a Monster
     * @example
     * // Get one Monster
     * const monster = await prisma.monster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonsterFindFirstOrThrowArgs>(args?: SelectSubset<T, MonsterFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Monsters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monsters
     * const monsters = await prisma.monster.findMany()
     * 
     * // Get first 10 Monsters
     * const monsters = await prisma.monster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monsterWithIdOnly = await prisma.monster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonsterFindManyArgs>(args?: SelectSubset<T, MonsterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Monster.
     * @param {MonsterCreateArgs} args - Arguments to create a Monster.
     * @example
     * // Create one Monster
     * const Monster = await prisma.monster.create({
     *   data: {
     *     // ... data to create a Monster
     *   }
     * })
     * 
     */
    create<T extends MonsterCreateArgs>(args: SelectSubset<T, MonsterCreateArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Monsters.
     * @param {MonsterCreateManyArgs} args - Arguments to create many Monsters.
     * @example
     * // Create many Monsters
     * const monster = await prisma.monster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonsterCreateManyArgs>(args?: SelectSubset<T, MonsterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Monsters and returns the data saved in the database.
     * @param {MonsterCreateManyAndReturnArgs} args - Arguments to create many Monsters.
     * @example
     * // Create many Monsters
     * const monster = await prisma.monster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Monsters and only return the `id`
     * const monsterWithIdOnly = await prisma.monster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonsterCreateManyAndReturnArgs>(args?: SelectSubset<T, MonsterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Monster.
     * @param {MonsterDeleteArgs} args - Arguments to delete one Monster.
     * @example
     * // Delete one Monster
     * const Monster = await prisma.monster.delete({
     *   where: {
     *     // ... filter to delete one Monster
     *   }
     * })
     * 
     */
    delete<T extends MonsterDeleteArgs>(args: SelectSubset<T, MonsterDeleteArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Monster.
     * @param {MonsterUpdateArgs} args - Arguments to update one Monster.
     * @example
     * // Update one Monster
     * const monster = await prisma.monster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonsterUpdateArgs>(args: SelectSubset<T, MonsterUpdateArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Monsters.
     * @param {MonsterDeleteManyArgs} args - Arguments to filter Monsters to delete.
     * @example
     * // Delete a few Monsters
     * const { count } = await prisma.monster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonsterDeleteManyArgs>(args?: SelectSubset<T, MonsterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monsters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monsters
     * const monster = await prisma.monster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonsterUpdateManyArgs>(args: SelectSubset<T, MonsterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monsters and returns the data updated in the database.
     * @param {MonsterUpdateManyAndReturnArgs} args - Arguments to update many Monsters.
     * @example
     * // Update many Monsters
     * const monster = await prisma.monster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Monsters and only return the `id`
     * const monsterWithIdOnly = await prisma.monster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonsterUpdateManyAndReturnArgs>(args: SelectSubset<T, MonsterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Monster.
     * @param {MonsterUpsertArgs} args - Arguments to update or create a Monster.
     * @example
     * // Update or create a Monster
     * const monster = await prisma.monster.upsert({
     *   create: {
     *     // ... data to create a Monster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monster we want to update
     *   }
     * })
     */
    upsert<T extends MonsterUpsertArgs>(args: SelectSubset<T, MonsterUpsertArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Monsters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCountArgs} args - Arguments to filter Monsters to count.
     * @example
     * // Count the number of Monsters
     * const count = await prisma.monster.count({
     *   where: {
     *     // ... the filter for the Monsters we want to count
     *   }
     * })
    **/
    count<T extends MonsterCountArgs>(
      args?: Subset<T, MonsterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonsterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonsterAggregateArgs>(args: Subset<T, MonsterAggregateArgs>): Prisma.PrismaPromise<GetMonsterAggregateType<T>>

    /**
     * Group by Monster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonsterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonsterGroupByArgs['orderBy'] }
        : { orderBy?: MonsterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonsterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonsterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monster model
   */
  readonly fields: MonsterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonsterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends Monster$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Monster$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounterParticipants<T extends Monster$encounterParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, Monster$encounterParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monster model
   */
  interface MonsterFieldRefs {
    readonly id: FieldRef<"Monster", 'String'>
    readonly name: FieldRef<"Monster", 'String'>
    readonly size: FieldRef<"Monster", 'Size'>
    readonly creatureType: FieldRef<"Monster", 'CreatureType'>
    readonly alignment: FieldRef<"Monster", 'Alignment'>
    readonly portraitPath: FieldRef<"Monster", 'String'>
    readonly hpMax: FieldRef<"Monster", 'Int'>
    readonly hpDice: FieldRef<"Monster", 'String'>
    readonly ac: FieldRef<"Monster", 'Int'>
    readonly acDescription: FieldRef<"Monster", 'String'>
    readonly speed: FieldRef<"Monster", 'Json'>
    readonly abilities: FieldRef<"Monster", 'Json'>
    readonly savingThrows: FieldRef<"Monster", 'Json'>
    readonly skills: FieldRef<"Monster", 'Json'>
    readonly damageResistances: FieldRef<"Monster", 'Json'>
    readonly damageImmunities: FieldRef<"Monster", 'Json'>
    readonly conditionImmunities: FieldRef<"Monster", 'Json'>
    readonly senses: FieldRef<"Monster", 'String'>
    readonly languages: FieldRef<"Monster", 'Json'>
    readonly challengeRating: FieldRef<"Monster", 'Float'>
    readonly actions: FieldRef<"Monster", 'Json'>
    readonly reactions: FieldRef<"Monster", 'Json'>
    readonly legendaryActions: FieldRef<"Monster", 'Json'>
    readonly description: FieldRef<"Monster", 'String'>
    readonly dmNotes: FieldRef<"Monster", 'String'>
    readonly isTemplate: FieldRef<"Monster", 'Boolean'>
    readonly createdAt: FieldRef<"Monster", 'DateTime'>
    readonly updatedAt: FieldRef<"Monster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Monster findUnique
   */
  export type MonsterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * Filter, which Monster to fetch.
     */
    where: MonsterWhereUniqueInput
  }

  /**
   * Monster findUniqueOrThrow
   */
  export type MonsterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * Filter, which Monster to fetch.
     */
    where: MonsterWhereUniqueInput
  }

  /**
   * Monster findFirst
   */
  export type MonsterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * Filter, which Monster to fetch.
     */
    where?: MonsterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monsters to fetch.
     */
    orderBy?: MonsterOrderByWithRelationInput | MonsterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monsters.
     */
    cursor?: MonsterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monsters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monsters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monsters.
     */
    distinct?: MonsterScalarFieldEnum | MonsterScalarFieldEnum[]
  }

  /**
   * Monster findFirstOrThrow
   */
  export type MonsterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * Filter, which Monster to fetch.
     */
    where?: MonsterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monsters to fetch.
     */
    orderBy?: MonsterOrderByWithRelationInput | MonsterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monsters.
     */
    cursor?: MonsterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monsters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monsters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monsters.
     */
    distinct?: MonsterScalarFieldEnum | MonsterScalarFieldEnum[]
  }

  /**
   * Monster findMany
   */
  export type MonsterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * Filter, which Monsters to fetch.
     */
    where?: MonsterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monsters to fetch.
     */
    orderBy?: MonsterOrderByWithRelationInput | MonsterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monsters.
     */
    cursor?: MonsterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monsters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monsters.
     */
    skip?: number
    distinct?: MonsterScalarFieldEnum | MonsterScalarFieldEnum[]
  }

  /**
   * Monster create
   */
  export type MonsterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * The data needed to create a Monster.
     */
    data: XOR<MonsterCreateInput, MonsterUncheckedCreateInput>
  }

  /**
   * Monster createMany
   */
  export type MonsterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monsters.
     */
    data: MonsterCreateManyInput | MonsterCreateManyInput[]
  }

  /**
   * Monster createManyAndReturn
   */
  export type MonsterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * The data used to create many Monsters.
     */
    data: MonsterCreateManyInput | MonsterCreateManyInput[]
  }

  /**
   * Monster update
   */
  export type MonsterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * The data needed to update a Monster.
     */
    data: XOR<MonsterUpdateInput, MonsterUncheckedUpdateInput>
    /**
     * Choose, which Monster to update.
     */
    where: MonsterWhereUniqueInput
  }

  /**
   * Monster updateMany
   */
  export type MonsterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monsters.
     */
    data: XOR<MonsterUpdateManyMutationInput, MonsterUncheckedUpdateManyInput>
    /**
     * Filter which Monsters to update
     */
    where?: MonsterWhereInput
    /**
     * Limit how many Monsters to update.
     */
    limit?: number
  }

  /**
   * Monster updateManyAndReturn
   */
  export type MonsterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * The data used to update Monsters.
     */
    data: XOR<MonsterUpdateManyMutationInput, MonsterUncheckedUpdateManyInput>
    /**
     * Filter which Monsters to update
     */
    where?: MonsterWhereInput
    /**
     * Limit how many Monsters to update.
     */
    limit?: number
  }

  /**
   * Monster upsert
   */
  export type MonsterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * The filter to search for the Monster to update in case it exists.
     */
    where: MonsterWhereUniqueInput
    /**
     * In case the Monster found by the `where` argument doesn't exist, create a new Monster with this data.
     */
    create: XOR<MonsterCreateInput, MonsterUncheckedCreateInput>
    /**
     * In case the Monster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonsterUpdateInput, MonsterUncheckedUpdateInput>
  }

  /**
   * Monster delete
   */
  export type MonsterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    /**
     * Filter which Monster to delete.
     */
    where: MonsterWhereUniqueInput
  }

  /**
   * Monster deleteMany
   */
  export type MonsterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monsters to delete
     */
    where?: MonsterWhereInput
    /**
     * Limit how many Monsters to delete.
     */
    limit?: number
  }

  /**
   * Monster.campaigns
   */
  export type Monster$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    where?: MonsterCampaignWhereInput
    orderBy?: MonsterCampaignOrderByWithRelationInput | MonsterCampaignOrderByWithRelationInput[]
    cursor?: MonsterCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonsterCampaignScalarFieldEnum | MonsterCampaignScalarFieldEnum[]
  }

  /**
   * Monster.encounterParticipants
   */
  export type Monster$encounterParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    where?: EncounterParticipantWhereInput
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    cursor?: EncounterParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterParticipantScalarFieldEnum | EncounterParticipantScalarFieldEnum[]
  }

  /**
   * Monster without action
   */
  export type MonsterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
  }


  /**
   * Model Condition
   */

  export type AggregateCondition = {
    _count: ConditionCountAggregateOutputType | null
    _min: ConditionMinAggregateOutputType | null
    _max: ConditionMaxAggregateOutputType | null
  }

  export type ConditionMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    description: string | null
    mechanicalEffects: string | null
    isCustom: boolean | null
  }

  export type ConditionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    description: string | null
    mechanicalEffects: string | null
    isCustom: boolean | null
  }

  export type ConditionCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    description: number
    mechanicalEffects: number
    isCustom: number
    _all: number
  }


  export type ConditionMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    mechanicalEffects?: true
    isCustom?: true
  }

  export type ConditionMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    mechanicalEffects?: true
    isCustom?: true
  }

  export type ConditionCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    description?: true
    mechanicalEffects?: true
    isCustom?: true
    _all?: true
  }

  export type ConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Condition to aggregate.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conditions
    **/
    _count?: true | ConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionMaxAggregateInputType
  }

  export type GetConditionAggregateType<T extends ConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCondition[P]>
      : GetScalarType<T[P], AggregateCondition[P]>
  }




  export type ConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionWhereInput
    orderBy?: ConditionOrderByWithAggregationInput | ConditionOrderByWithAggregationInput[]
    by: ConditionScalarFieldEnum[] | ConditionScalarFieldEnum
    having?: ConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionCountAggregateInputType | true
    _min?: ConditionMinAggregateInputType
    _max?: ConditionMaxAggregateInputType
  }

  export type ConditionGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    description: string | null
    mechanicalEffects: string | null
    isCustom: boolean
    _count: ConditionCountAggregateOutputType | null
    _min: ConditionMinAggregateOutputType | null
    _max: ConditionMaxAggregateOutputType | null
  }

  type GetConditionGroupByPayload<T extends ConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionGroupByOutputType[P]>
        }
      >
    >


  export type ConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    isCustom?: boolean
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    isCustom?: boolean
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    isCustom?: boolean
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    isCustom?: boolean
  }

  export type ConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "description" | "mechanicalEffects" | "isCustom", ExtArgs["result"]["condition"]>

  export type $ConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Condition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string | null
      description: string | null
      mechanicalEffects: string | null
      isCustom: boolean
    }, ExtArgs["result"]["condition"]>
    composites: {}
  }

  type ConditionGetPayload<S extends boolean | null | undefined | ConditionDefaultArgs> = $Result.GetResult<Prisma.$ConditionPayload, S>

  type ConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConditionCountAggregateInputType | true
    }

  export interface ConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Condition'], meta: { name: 'Condition' } }
    /**
     * Find zero or one Condition that matches the filter.
     * @param {ConditionFindUniqueArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConditionFindUniqueArgs>(args: SelectSubset<T, ConditionFindUniqueArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Condition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConditionFindUniqueOrThrowArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Condition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindFirstArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConditionFindFirstArgs>(args?: SelectSubset<T, ConditionFindFirstArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Condition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindFirstOrThrowArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conditions
     * const conditions = await prisma.condition.findMany()
     * 
     * // Get first 10 Conditions
     * const conditions = await prisma.condition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionWithIdOnly = await prisma.condition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConditionFindManyArgs>(args?: SelectSubset<T, ConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Condition.
     * @param {ConditionCreateArgs} args - Arguments to create a Condition.
     * @example
     * // Create one Condition
     * const Condition = await prisma.condition.create({
     *   data: {
     *     // ... data to create a Condition
     *   }
     * })
     * 
     */
    create<T extends ConditionCreateArgs>(args: SelectSubset<T, ConditionCreateArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conditions.
     * @param {ConditionCreateManyArgs} args - Arguments to create many Conditions.
     * @example
     * // Create many Conditions
     * const condition = await prisma.condition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConditionCreateManyArgs>(args?: SelectSubset<T, ConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conditions and returns the data saved in the database.
     * @param {ConditionCreateManyAndReturnArgs} args - Arguments to create many Conditions.
     * @example
     * // Create many Conditions
     * const condition = await prisma.condition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conditions and only return the `id`
     * const conditionWithIdOnly = await prisma.condition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Condition.
     * @param {ConditionDeleteArgs} args - Arguments to delete one Condition.
     * @example
     * // Delete one Condition
     * const Condition = await prisma.condition.delete({
     *   where: {
     *     // ... filter to delete one Condition
     *   }
     * })
     * 
     */
    delete<T extends ConditionDeleteArgs>(args: SelectSubset<T, ConditionDeleteArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Condition.
     * @param {ConditionUpdateArgs} args - Arguments to update one Condition.
     * @example
     * // Update one Condition
     * const condition = await prisma.condition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConditionUpdateArgs>(args: SelectSubset<T, ConditionUpdateArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conditions.
     * @param {ConditionDeleteManyArgs} args - Arguments to filter Conditions to delete.
     * @example
     * // Delete a few Conditions
     * const { count } = await prisma.condition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConditionDeleteManyArgs>(args?: SelectSubset<T, ConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conditions
     * const condition = await prisma.condition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConditionUpdateManyArgs>(args: SelectSubset<T, ConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions and returns the data updated in the database.
     * @param {ConditionUpdateManyAndReturnArgs} args - Arguments to update many Conditions.
     * @example
     * // Update many Conditions
     * const condition = await prisma.condition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conditions and only return the `id`
     * const conditionWithIdOnly = await prisma.condition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Condition.
     * @param {ConditionUpsertArgs} args - Arguments to update or create a Condition.
     * @example
     * // Update or create a Condition
     * const condition = await prisma.condition.upsert({
     *   create: {
     *     // ... data to create a Condition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Condition we want to update
     *   }
     * })
     */
    upsert<T extends ConditionUpsertArgs>(args: SelectSubset<T, ConditionUpsertArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionCountArgs} args - Arguments to filter Conditions to count.
     * @example
     * // Count the number of Conditions
     * const count = await prisma.condition.count({
     *   where: {
     *     // ... the filter for the Conditions we want to count
     *   }
     * })
    **/
    count<T extends ConditionCountArgs>(
      args?: Subset<T, ConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Condition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionAggregateArgs>(args: Subset<T, ConditionAggregateArgs>): Prisma.PrismaPromise<GetConditionAggregateType<T>>

    /**
     * Group by Condition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionGroupByArgs['orderBy'] }
        : { orderBy?: ConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Condition model
   */
  readonly fields: ConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Condition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Condition model
   */
  interface ConditionFieldRefs {
    readonly id: FieldRef<"Condition", 'String'>
    readonly name: FieldRef<"Condition", 'String'>
    readonly icon: FieldRef<"Condition", 'String'>
    readonly description: FieldRef<"Condition", 'String'>
    readonly mechanicalEffects: FieldRef<"Condition", 'String'>
    readonly isCustom: FieldRef<"Condition", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Condition findUnique
   */
  export type ConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition findUniqueOrThrow
   */
  export type ConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition findFirst
   */
  export type ConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Condition findFirstOrThrow
   */
  export type ConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Condition findMany
   */
  export type ConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }

  /**
   * Condition create
   */
  export type ConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The data needed to create a Condition.
     */
    data: XOR<ConditionCreateInput, ConditionUncheckedCreateInput>
  }

  /**
   * Condition createMany
   */
  export type ConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conditions.
     */
    data: ConditionCreateManyInput | ConditionCreateManyInput[]
  }

  /**
   * Condition createManyAndReturn
   */
  export type ConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The data used to create many Conditions.
     */
    data: ConditionCreateManyInput | ConditionCreateManyInput[]
  }

  /**
   * Condition update
   */
  export type ConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The data needed to update a Condition.
     */
    data: XOR<ConditionUpdateInput, ConditionUncheckedUpdateInput>
    /**
     * Choose, which Condition to update.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition updateMany
   */
  export type ConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conditions.
     */
    data: XOR<ConditionUpdateManyMutationInput, ConditionUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     */
    where?: ConditionWhereInput
    /**
     * Limit how many Conditions to update.
     */
    limit?: number
  }

  /**
   * Condition updateManyAndReturn
   */
  export type ConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The data used to update Conditions.
     */
    data: XOR<ConditionUpdateManyMutationInput, ConditionUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     */
    where?: ConditionWhereInput
    /**
     * Limit how many Conditions to update.
     */
    limit?: number
  }

  /**
   * Condition upsert
   */
  export type ConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * The filter to search for the Condition to update in case it exists.
     */
    where: ConditionWhereUniqueInput
    /**
     * In case the Condition found by the `where` argument doesn't exist, create a new Condition with this data.
     */
    create: XOR<ConditionCreateInput, ConditionUncheckedCreateInput>
    /**
     * In case the Condition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionUpdateInput, ConditionUncheckedUpdateInput>
  }

  /**
   * Condition delete
   */
  export type ConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
    /**
     * Filter which Condition to delete.
     */
    where: ConditionWhereUniqueInput
  }

  /**
   * Condition deleteMany
   */
  export type ConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditions to delete
     */
    where?: ConditionWhereInput
    /**
     * Limit how many Conditions to delete.
     */
    limit?: number
  }

  /**
   * Condition without action
   */
  export type ConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Condition
     */
    omit?: ConditionOmit<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    mapId: string | null
    locationId: string | null
    name: string | null
    description: string | null
    difficulty: $Enums.Difficulty | null
    status: $Enums.EncounterStatus | null
    dmNotes: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    mapId: string | null
    locationId: string | null
    name: string | null
    description: string | null
    difficulty: $Enums.Difficulty | null
    status: $Enums.EncounterStatus | null
    dmNotes: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    campaignId: number
    mapId: number
    locationId: number
    name: number
    description: number
    difficulty: number
    status: number
    dmNotes: number
    createdAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type EncounterMinAggregateInputType = {
    id?: true
    campaignId?: true
    mapId?: true
    locationId?: true
    name?: true
    description?: true
    difficulty?: true
    status?: true
    dmNotes?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    campaignId?: true
    mapId?: true
    locationId?: true
    name?: true
    description?: true
    difficulty?: true
    status?: true
    dmNotes?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    campaignId?: true
    mapId?: true
    locationId?: true
    name?: true
    description?: true
    difficulty?: true
    status?: true
    dmNotes?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    campaignId: string
    mapId: string | null
    locationId: string | null
    name: string
    description: string | null
    difficulty: $Enums.Difficulty
    status: $Enums.EncounterStatus
    dmNotes: string | null
    createdAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    mapId?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    status?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    map?: boolean | Encounter$mapArgs<ExtArgs>
    location?: boolean | Encounter$locationArgs<ExtArgs>
    participants?: boolean | Encounter$participantsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    mapId?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    status?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    map?: boolean | Encounter$mapArgs<ExtArgs>
    location?: boolean | Encounter$locationArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    mapId?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    status?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    map?: boolean | Encounter$mapArgs<ExtArgs>
    location?: boolean | Encounter$locationArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    campaignId?: boolean
    mapId?: boolean
    locationId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    status?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type EncounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "mapId" | "locationId" | "name" | "description" | "difficulty" | "status" | "dmNotes" | "createdAt" | "startedAt" | "completedAt", ExtArgs["result"]["encounter"]>
  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    map?: boolean | Encounter$mapArgs<ExtArgs>
    location?: boolean | Encounter$locationArgs<ExtArgs>
    participants?: boolean | Encounter$participantsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    map?: boolean | Encounter$mapArgs<ExtArgs>
    location?: boolean | Encounter$locationArgs<ExtArgs>
  }
  export type EncounterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    map?: boolean | Encounter$mapArgs<ExtArgs>
    location?: boolean | Encounter$locationArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      map: Prisma.$MapPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs> | null
      participants: Prisma.$EncounterParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      mapId: string | null
      locationId: string | null
      name: string
      description: string | null
      difficulty: $Enums.Difficulty
      status: $Enums.EncounterStatus
      dmNotes: string | null
      createdAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters and returns the data updated in the database.
     * @param {EncounterUpdateManyAndReturnArgs} args - Arguments to update many Encounters.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    map<T extends Encounter$mapArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$mapArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends Encounter$locationArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends Encounter$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly campaignId: FieldRef<"Encounter", 'String'>
    readonly mapId: FieldRef<"Encounter", 'String'>
    readonly locationId: FieldRef<"Encounter", 'String'>
    readonly name: FieldRef<"Encounter", 'String'>
    readonly description: FieldRef<"Encounter", 'String'>
    readonly difficulty: FieldRef<"Encounter", 'Difficulty'>
    readonly status: FieldRef<"Encounter", 'EncounterStatus'>
    readonly dmNotes: FieldRef<"Encounter", 'String'>
    readonly createdAt: FieldRef<"Encounter", 'DateTime'>
    readonly startedAt: FieldRef<"Encounter", 'DateTime'>
    readonly completedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
  }

  /**
   * Encounter updateManyAndReturn
   */
  export type EncounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to delete.
     */
    limit?: number
  }

  /**
   * Encounter.map
   */
  export type Encounter$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
  }

  /**
   * Encounter.location
   */
  export type Encounter$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Encounter.participants
   */
  export type Encounter$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    where?: EncounterParticipantWhereInput
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    cursor?: EncounterParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterParticipantScalarFieldEnum | EncounterParticipantScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model EncounterParticipant
   */

  export type AggregateEncounterParticipant = {
    _count: EncounterParticipantCountAggregateOutputType | null
    _avg: EncounterParticipantAvgAggregateOutputType | null
    _sum: EncounterParticipantSumAggregateOutputType | null
    _min: EncounterParticipantMinAggregateOutputType | null
    _max: EncounterParticipantMaxAggregateOutputType | null
  }

  export type EncounterParticipantAvgAggregateOutputType = {
    initiative: number | null
    hpCurrent: number | null
    hpMax: number | null
    ac: number | null
    positionX: number | null
    positionY: number | null
  }

  export type EncounterParticipantSumAggregateOutputType = {
    initiative: number | null
    hpCurrent: number | null
    hpMax: number | null
    ac: number | null
    positionX: number | null
    positionY: number | null
  }

  export type EncounterParticipantMinAggregateOutputType = {
    id: string | null
    encounterId: string | null
    participantType: $Enums.ParticipantType | null
    monsterId: string | null
    playerCharacterId: string | null
    customName: string | null
    initiative: number | null
    hpCurrent: number | null
    hpMax: number | null
    ac: number | null
    positionX: number | null
    positionY: number | null
    isVisible: boolean | null
    dmNotes: string | null
  }

  export type EncounterParticipantMaxAggregateOutputType = {
    id: string | null
    encounterId: string | null
    participantType: $Enums.ParticipantType | null
    monsterId: string | null
    playerCharacterId: string | null
    customName: string | null
    initiative: number | null
    hpCurrent: number | null
    hpMax: number | null
    ac: number | null
    positionX: number | null
    positionY: number | null
    isVisible: boolean | null
    dmNotes: string | null
  }

  export type EncounterParticipantCountAggregateOutputType = {
    id: number
    encounterId: number
    participantType: number
    monsterId: number
    playerCharacterId: number
    customName: number
    initiative: number
    hpCurrent: number
    hpMax: number
    ac: number
    conditions: number
    positionX: number
    positionY: number
    isVisible: number
    dmNotes: number
    _all: number
  }


  export type EncounterParticipantAvgAggregateInputType = {
    initiative?: true
    hpCurrent?: true
    hpMax?: true
    ac?: true
    positionX?: true
    positionY?: true
  }

  export type EncounterParticipantSumAggregateInputType = {
    initiative?: true
    hpCurrent?: true
    hpMax?: true
    ac?: true
    positionX?: true
    positionY?: true
  }

  export type EncounterParticipantMinAggregateInputType = {
    id?: true
    encounterId?: true
    participantType?: true
    monsterId?: true
    playerCharacterId?: true
    customName?: true
    initiative?: true
    hpCurrent?: true
    hpMax?: true
    ac?: true
    positionX?: true
    positionY?: true
    isVisible?: true
    dmNotes?: true
  }

  export type EncounterParticipantMaxAggregateInputType = {
    id?: true
    encounterId?: true
    participantType?: true
    monsterId?: true
    playerCharacterId?: true
    customName?: true
    initiative?: true
    hpCurrent?: true
    hpMax?: true
    ac?: true
    positionX?: true
    positionY?: true
    isVisible?: true
    dmNotes?: true
  }

  export type EncounterParticipantCountAggregateInputType = {
    id?: true
    encounterId?: true
    participantType?: true
    monsterId?: true
    playerCharacterId?: true
    customName?: true
    initiative?: true
    hpCurrent?: true
    hpMax?: true
    ac?: true
    conditions?: true
    positionX?: true
    positionY?: true
    isVisible?: true
    dmNotes?: true
    _all?: true
  }

  export type EncounterParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterParticipant to aggregate.
     */
    where?: EncounterParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterParticipants to fetch.
     */
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterParticipants
    **/
    _count?: true | EncounterParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterParticipantMaxAggregateInputType
  }

  export type GetEncounterParticipantAggregateType<T extends EncounterParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterParticipant[P]>
      : GetScalarType<T[P], AggregateEncounterParticipant[P]>
  }




  export type EncounterParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterParticipantWhereInput
    orderBy?: EncounterParticipantOrderByWithAggregationInput | EncounterParticipantOrderByWithAggregationInput[]
    by: EncounterParticipantScalarFieldEnum[] | EncounterParticipantScalarFieldEnum
    having?: EncounterParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterParticipantCountAggregateInputType | true
    _avg?: EncounterParticipantAvgAggregateInputType
    _sum?: EncounterParticipantSumAggregateInputType
    _min?: EncounterParticipantMinAggregateInputType
    _max?: EncounterParticipantMaxAggregateInputType
  }

  export type EncounterParticipantGroupByOutputType = {
    id: string
    encounterId: string
    participantType: $Enums.ParticipantType
    monsterId: string | null
    playerCharacterId: string | null
    customName: string | null
    initiative: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions: JsonValue | null
    positionX: number | null
    positionY: number | null
    isVisible: boolean
    dmNotes: string | null
    _count: EncounterParticipantCountAggregateOutputType | null
    _avg: EncounterParticipantAvgAggregateOutputType | null
    _sum: EncounterParticipantSumAggregateOutputType | null
    _min: EncounterParticipantMinAggregateOutputType | null
    _max: EncounterParticipantMaxAggregateOutputType | null
  }

  type GetEncounterParticipantGroupByPayload<T extends EncounterParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterParticipantGroupByOutputType[P]>
        }
      >
    >


  export type EncounterParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    participantType?: boolean
    monsterId?: boolean
    playerCharacterId?: boolean
    customName?: boolean
    initiative?: boolean
    hpCurrent?: boolean
    hpMax?: boolean
    ac?: boolean
    conditions?: boolean
    positionX?: boolean
    positionY?: boolean
    isVisible?: boolean
    dmNotes?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    monster?: boolean | EncounterParticipant$monsterArgs<ExtArgs>
    playerCharacter?: boolean | EncounterParticipant$playerCharacterArgs<ExtArgs>
  }, ExtArgs["result"]["encounterParticipant"]>

  export type EncounterParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    participantType?: boolean
    monsterId?: boolean
    playerCharacterId?: boolean
    customName?: boolean
    initiative?: boolean
    hpCurrent?: boolean
    hpMax?: boolean
    ac?: boolean
    conditions?: boolean
    positionX?: boolean
    positionY?: boolean
    isVisible?: boolean
    dmNotes?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    monster?: boolean | EncounterParticipant$monsterArgs<ExtArgs>
    playerCharacter?: boolean | EncounterParticipant$playerCharacterArgs<ExtArgs>
  }, ExtArgs["result"]["encounterParticipant"]>

  export type EncounterParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    participantType?: boolean
    monsterId?: boolean
    playerCharacterId?: boolean
    customName?: boolean
    initiative?: boolean
    hpCurrent?: boolean
    hpMax?: boolean
    ac?: boolean
    conditions?: boolean
    positionX?: boolean
    positionY?: boolean
    isVisible?: boolean
    dmNotes?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    monster?: boolean | EncounterParticipant$monsterArgs<ExtArgs>
    playerCharacter?: boolean | EncounterParticipant$playerCharacterArgs<ExtArgs>
  }, ExtArgs["result"]["encounterParticipant"]>

  export type EncounterParticipantSelectScalar = {
    id?: boolean
    encounterId?: boolean
    participantType?: boolean
    monsterId?: boolean
    playerCharacterId?: boolean
    customName?: boolean
    initiative?: boolean
    hpCurrent?: boolean
    hpMax?: boolean
    ac?: boolean
    conditions?: boolean
    positionX?: boolean
    positionY?: boolean
    isVisible?: boolean
    dmNotes?: boolean
  }

  export type EncounterParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounterId" | "participantType" | "monsterId" | "playerCharacterId" | "customName" | "initiative" | "hpCurrent" | "hpMax" | "ac" | "conditions" | "positionX" | "positionY" | "isVisible" | "dmNotes", ExtArgs["result"]["encounterParticipant"]>
  export type EncounterParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    monster?: boolean | EncounterParticipant$monsterArgs<ExtArgs>
    playerCharacter?: boolean | EncounterParticipant$playerCharacterArgs<ExtArgs>
  }
  export type EncounterParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    monster?: boolean | EncounterParticipant$monsterArgs<ExtArgs>
    playerCharacter?: boolean | EncounterParticipant$playerCharacterArgs<ExtArgs>
  }
  export type EncounterParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    monster?: boolean | EncounterParticipant$monsterArgs<ExtArgs>
    playerCharacter?: boolean | EncounterParticipant$playerCharacterArgs<ExtArgs>
  }

  export type $EncounterParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterParticipant"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      monster: Prisma.$MonsterPayload<ExtArgs> | null
      playerCharacter: Prisma.$PlayerCharacterPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      encounterId: string
      participantType: $Enums.ParticipantType
      monsterId: string | null
      playerCharacterId: string | null
      customName: string | null
      initiative: number | null
      hpCurrent: number
      hpMax: number
      ac: number
      conditions: Prisma.JsonValue | null
      positionX: number | null
      positionY: number | null
      isVisible: boolean
      dmNotes: string | null
    }, ExtArgs["result"]["encounterParticipant"]>
    composites: {}
  }

  type EncounterParticipantGetPayload<S extends boolean | null | undefined | EncounterParticipantDefaultArgs> = $Result.GetResult<Prisma.$EncounterParticipantPayload, S>

  type EncounterParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterParticipantCountAggregateInputType | true
    }

  export interface EncounterParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterParticipant'], meta: { name: 'EncounterParticipant' } }
    /**
     * Find zero or one EncounterParticipant that matches the filter.
     * @param {EncounterParticipantFindUniqueArgs} args - Arguments to find a EncounterParticipant
     * @example
     * // Get one EncounterParticipant
     * const encounterParticipant = await prisma.encounterParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterParticipantFindUniqueArgs>(args: SelectSubset<T, EncounterParticipantFindUniqueArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncounterParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterParticipantFindUniqueOrThrowArgs} args - Arguments to find a EncounterParticipant
     * @example
     * // Get one EncounterParticipant
     * const encounterParticipant = await prisma.encounterParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantFindFirstArgs} args - Arguments to find a EncounterParticipant
     * @example
     * // Get one EncounterParticipant
     * const encounterParticipant = await prisma.encounterParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterParticipantFindFirstArgs>(args?: SelectSubset<T, EncounterParticipantFindFirstArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantFindFirstOrThrowArgs} args - Arguments to find a EncounterParticipant
     * @example
     * // Get one EncounterParticipant
     * const encounterParticipant = await prisma.encounterParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncounterParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterParticipants
     * const encounterParticipants = await prisma.encounterParticipant.findMany()
     * 
     * // Get first 10 EncounterParticipants
     * const encounterParticipants = await prisma.encounterParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterParticipantWithIdOnly = await prisma.encounterParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterParticipantFindManyArgs>(args?: SelectSubset<T, EncounterParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncounterParticipant.
     * @param {EncounterParticipantCreateArgs} args - Arguments to create a EncounterParticipant.
     * @example
     * // Create one EncounterParticipant
     * const EncounterParticipant = await prisma.encounterParticipant.create({
     *   data: {
     *     // ... data to create a EncounterParticipant
     *   }
     * })
     * 
     */
    create<T extends EncounterParticipantCreateArgs>(args: SelectSubset<T, EncounterParticipantCreateArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncounterParticipants.
     * @param {EncounterParticipantCreateManyArgs} args - Arguments to create many EncounterParticipants.
     * @example
     * // Create many EncounterParticipants
     * const encounterParticipant = await prisma.encounterParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterParticipantCreateManyArgs>(args?: SelectSubset<T, EncounterParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterParticipants and returns the data saved in the database.
     * @param {EncounterParticipantCreateManyAndReturnArgs} args - Arguments to create many EncounterParticipants.
     * @example
     * // Create many EncounterParticipants
     * const encounterParticipant = await prisma.encounterParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterParticipants and only return the `id`
     * const encounterParticipantWithIdOnly = await prisma.encounterParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncounterParticipant.
     * @param {EncounterParticipantDeleteArgs} args - Arguments to delete one EncounterParticipant.
     * @example
     * // Delete one EncounterParticipant
     * const EncounterParticipant = await prisma.encounterParticipant.delete({
     *   where: {
     *     // ... filter to delete one EncounterParticipant
     *   }
     * })
     * 
     */
    delete<T extends EncounterParticipantDeleteArgs>(args: SelectSubset<T, EncounterParticipantDeleteArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncounterParticipant.
     * @param {EncounterParticipantUpdateArgs} args - Arguments to update one EncounterParticipant.
     * @example
     * // Update one EncounterParticipant
     * const encounterParticipant = await prisma.encounterParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterParticipantUpdateArgs>(args: SelectSubset<T, EncounterParticipantUpdateArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncounterParticipants.
     * @param {EncounterParticipantDeleteManyArgs} args - Arguments to filter EncounterParticipants to delete.
     * @example
     * // Delete a few EncounterParticipants
     * const { count } = await prisma.encounterParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterParticipantDeleteManyArgs>(args?: SelectSubset<T, EncounterParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterParticipants
     * const encounterParticipant = await prisma.encounterParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterParticipantUpdateManyArgs>(args: SelectSubset<T, EncounterParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterParticipants and returns the data updated in the database.
     * @param {EncounterParticipantUpdateManyAndReturnArgs} args - Arguments to update many EncounterParticipants.
     * @example
     * // Update many EncounterParticipants
     * const encounterParticipant = await prisma.encounterParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncounterParticipants and only return the `id`
     * const encounterParticipantWithIdOnly = await prisma.encounterParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncounterParticipant.
     * @param {EncounterParticipantUpsertArgs} args - Arguments to update or create a EncounterParticipant.
     * @example
     * // Update or create a EncounterParticipant
     * const encounterParticipant = await prisma.encounterParticipant.upsert({
     *   create: {
     *     // ... data to create a EncounterParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterParticipant we want to update
     *   }
     * })
     */
    upsert<T extends EncounterParticipantUpsertArgs>(args: SelectSubset<T, EncounterParticipantUpsertArgs<ExtArgs>>): Prisma__EncounterParticipantClient<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncounterParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantCountArgs} args - Arguments to filter EncounterParticipants to count.
     * @example
     * // Count the number of EncounterParticipants
     * const count = await prisma.encounterParticipant.count({
     *   where: {
     *     // ... the filter for the EncounterParticipants we want to count
     *   }
     * })
    **/
    count<T extends EncounterParticipantCountArgs>(
      args?: Subset<T, EncounterParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterParticipantAggregateArgs>(args: Subset<T, EncounterParticipantAggregateArgs>): Prisma.PrismaPromise<GetEncounterParticipantAggregateType<T>>

    /**
     * Group by EncounterParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterParticipantGroupByArgs['orderBy'] }
        : { orderBy?: EncounterParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterParticipant model
   */
  readonly fields: EncounterParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    monster<T extends EncounterParticipant$monsterArgs<ExtArgs> = {}>(args?: Subset<T, EncounterParticipant$monsterArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playerCharacter<T extends EncounterParticipant$playerCharacterArgs<ExtArgs> = {}>(args?: Subset<T, EncounterParticipant$playerCharacterArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterParticipant model
   */
  interface EncounterParticipantFieldRefs {
    readonly id: FieldRef<"EncounterParticipant", 'String'>
    readonly encounterId: FieldRef<"EncounterParticipant", 'String'>
    readonly participantType: FieldRef<"EncounterParticipant", 'ParticipantType'>
    readonly monsterId: FieldRef<"EncounterParticipant", 'String'>
    readonly playerCharacterId: FieldRef<"EncounterParticipant", 'String'>
    readonly customName: FieldRef<"EncounterParticipant", 'String'>
    readonly initiative: FieldRef<"EncounterParticipant", 'Int'>
    readonly hpCurrent: FieldRef<"EncounterParticipant", 'Int'>
    readonly hpMax: FieldRef<"EncounterParticipant", 'Int'>
    readonly ac: FieldRef<"EncounterParticipant", 'Int'>
    readonly conditions: FieldRef<"EncounterParticipant", 'Json'>
    readonly positionX: FieldRef<"EncounterParticipant", 'Float'>
    readonly positionY: FieldRef<"EncounterParticipant", 'Float'>
    readonly isVisible: FieldRef<"EncounterParticipant", 'Boolean'>
    readonly dmNotes: FieldRef<"EncounterParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EncounterParticipant findUnique
   */
  export type EncounterParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EncounterParticipant to fetch.
     */
    where: EncounterParticipantWhereUniqueInput
  }

  /**
   * EncounterParticipant findUniqueOrThrow
   */
  export type EncounterParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EncounterParticipant to fetch.
     */
    where: EncounterParticipantWhereUniqueInput
  }

  /**
   * EncounterParticipant findFirst
   */
  export type EncounterParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EncounterParticipant to fetch.
     */
    where?: EncounterParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterParticipants to fetch.
     */
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterParticipants.
     */
    cursor?: EncounterParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterParticipants.
     */
    distinct?: EncounterParticipantScalarFieldEnum | EncounterParticipantScalarFieldEnum[]
  }

  /**
   * EncounterParticipant findFirstOrThrow
   */
  export type EncounterParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EncounterParticipant to fetch.
     */
    where?: EncounterParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterParticipants to fetch.
     */
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterParticipants.
     */
    cursor?: EncounterParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterParticipants.
     */
    distinct?: EncounterParticipantScalarFieldEnum | EncounterParticipantScalarFieldEnum[]
  }

  /**
   * EncounterParticipant findMany
   */
  export type EncounterParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * Filter, which EncounterParticipants to fetch.
     */
    where?: EncounterParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterParticipants to fetch.
     */
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterParticipants.
     */
    cursor?: EncounterParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterParticipants.
     */
    skip?: number
    distinct?: EncounterParticipantScalarFieldEnum | EncounterParticipantScalarFieldEnum[]
  }

  /**
   * EncounterParticipant create
   */
  export type EncounterParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterParticipant.
     */
    data: XOR<EncounterParticipantCreateInput, EncounterParticipantUncheckedCreateInput>
  }

  /**
   * EncounterParticipant createMany
   */
  export type EncounterParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterParticipants.
     */
    data: EncounterParticipantCreateManyInput | EncounterParticipantCreateManyInput[]
  }

  /**
   * EncounterParticipant createManyAndReturn
   */
  export type EncounterParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many EncounterParticipants.
     */
    data: EncounterParticipantCreateManyInput | EncounterParticipantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterParticipant update
   */
  export type EncounterParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterParticipant.
     */
    data: XOR<EncounterParticipantUpdateInput, EncounterParticipantUncheckedUpdateInput>
    /**
     * Choose, which EncounterParticipant to update.
     */
    where: EncounterParticipantWhereUniqueInput
  }

  /**
   * EncounterParticipant updateMany
   */
  export type EncounterParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterParticipants.
     */
    data: XOR<EncounterParticipantUpdateManyMutationInput, EncounterParticipantUncheckedUpdateManyInput>
    /**
     * Filter which EncounterParticipants to update
     */
    where?: EncounterParticipantWhereInput
    /**
     * Limit how many EncounterParticipants to update.
     */
    limit?: number
  }

  /**
   * EncounterParticipant updateManyAndReturn
   */
  export type EncounterParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * The data used to update EncounterParticipants.
     */
    data: XOR<EncounterParticipantUpdateManyMutationInput, EncounterParticipantUncheckedUpdateManyInput>
    /**
     * Filter which EncounterParticipants to update
     */
    where?: EncounterParticipantWhereInput
    /**
     * Limit how many EncounterParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterParticipant upsert
   */
  export type EncounterParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterParticipant to update in case it exists.
     */
    where: EncounterParticipantWhereUniqueInput
    /**
     * In case the EncounterParticipant found by the `where` argument doesn't exist, create a new EncounterParticipant with this data.
     */
    create: XOR<EncounterParticipantCreateInput, EncounterParticipantUncheckedCreateInput>
    /**
     * In case the EncounterParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterParticipantUpdateInput, EncounterParticipantUncheckedUpdateInput>
  }

  /**
   * EncounterParticipant delete
   */
  export type EncounterParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    /**
     * Filter which EncounterParticipant to delete.
     */
    where: EncounterParticipantWhereUniqueInput
  }

  /**
   * EncounterParticipant deleteMany
   */
  export type EncounterParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterParticipants to delete
     */
    where?: EncounterParticipantWhereInput
    /**
     * Limit how many EncounterParticipants to delete.
     */
    limit?: number
  }

  /**
   * EncounterParticipant.monster
   */
  export type EncounterParticipant$monsterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monster
     */
    select?: MonsterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Monster
     */
    omit?: MonsterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterInclude<ExtArgs> | null
    where?: MonsterWhereInput
  }

  /**
   * EncounterParticipant.playerCharacter
   */
  export type EncounterParticipant$playerCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    where?: PlayerCharacterWhereInput
  }

  /**
   * EncounterParticipant without action
   */
  export type EncounterParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
  }


  /**
   * Model PlayerCharacter
   */

  export type AggregatePlayerCharacter = {
    _count: PlayerCharacterCountAggregateOutputType | null
    _avg: PlayerCharacterAvgAggregateOutputType | null
    _sum: PlayerCharacterSumAggregateOutputType | null
    _min: PlayerCharacterMinAggregateOutputType | null
    _max: PlayerCharacterMaxAggregateOutputType | null
  }

  export type PlayerCharacterAvgAggregateOutputType = {
    level: number | null
    hpMax: number | null
    ac: number | null
    passivePerception: number | null
  }

  export type PlayerCharacterSumAggregateOutputType = {
    level: number | null
    hpMax: number | null
    ac: number | null
    passivePerception: number | null
  }

  export type PlayerCharacterMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    playerName: string | null
    characterName: string | null
    race: $Enums.Race | null
    class: $Enums.CharacterClass | null
    level: number | null
    alignment: $Enums.Alignment | null
    backgroundType: $Enums.BackgroundType | null
    background: string | null
    portraitPath: string | null
    hpMax: number | null
    ac: number | null
    passivePerception: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCharacterMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    playerName: string | null
    characterName: string | null
    race: $Enums.Race | null
    class: $Enums.CharacterClass | null
    level: number | null
    alignment: $Enums.Alignment | null
    backgroundType: $Enums.BackgroundType | null
    background: string | null
    portraitPath: string | null
    hpMax: number | null
    ac: number | null
    passivePerception: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCharacterCountAggregateOutputType = {
    id: number
    campaignId: number
    playerName: number
    characterName: number
    race: number
    class: number
    level: number
    alignment: number
    backgroundType: number
    background: number
    languages: number
    portraitPath: number
    hpMax: number
    ac: number
    passivePerception: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerCharacterAvgAggregateInputType = {
    level?: true
    hpMax?: true
    ac?: true
    passivePerception?: true
  }

  export type PlayerCharacterSumAggregateInputType = {
    level?: true
    hpMax?: true
    ac?: true
    passivePerception?: true
  }

  export type PlayerCharacterMinAggregateInputType = {
    id?: true
    campaignId?: true
    playerName?: true
    characterName?: true
    race?: true
    class?: true
    level?: true
    alignment?: true
    backgroundType?: true
    background?: true
    portraitPath?: true
    hpMax?: true
    ac?: true
    passivePerception?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCharacterMaxAggregateInputType = {
    id?: true
    campaignId?: true
    playerName?: true
    characterName?: true
    race?: true
    class?: true
    level?: true
    alignment?: true
    backgroundType?: true
    background?: true
    portraitPath?: true
    hpMax?: true
    ac?: true
    passivePerception?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCharacterCountAggregateInputType = {
    id?: true
    campaignId?: true
    playerName?: true
    characterName?: true
    race?: true
    class?: true
    level?: true
    alignment?: true
    backgroundType?: true
    background?: true
    languages?: true
    portraitPath?: true
    hpMax?: true
    ac?: true
    passivePerception?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerCharacter to aggregate.
     */
    where?: PlayerCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCharacters to fetch.
     */
    orderBy?: PlayerCharacterOrderByWithRelationInput | PlayerCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerCharacters
    **/
    _count?: true | PlayerCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerCharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerCharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerCharacterMaxAggregateInputType
  }

  export type GetPlayerCharacterAggregateType<T extends PlayerCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerCharacter[P]>
      : GetScalarType<T[P], AggregatePlayerCharacter[P]>
  }




  export type PlayerCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerCharacterWhereInput
    orderBy?: PlayerCharacterOrderByWithAggregationInput | PlayerCharacterOrderByWithAggregationInput[]
    by: PlayerCharacterScalarFieldEnum[] | PlayerCharacterScalarFieldEnum
    having?: PlayerCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCharacterCountAggregateInputType | true
    _avg?: PlayerCharacterAvgAggregateInputType
    _sum?: PlayerCharacterSumAggregateInputType
    _min?: PlayerCharacterMinAggregateInputType
    _max?: PlayerCharacterMaxAggregateInputType
  }

  export type PlayerCharacterGroupByOutputType = {
    id: string
    campaignId: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background: string | null
    languages: JsonValue | null
    portraitPath: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlayerCharacterCountAggregateOutputType | null
    _avg: PlayerCharacterAvgAggregateOutputType | null
    _sum: PlayerCharacterSumAggregateOutputType | null
    _min: PlayerCharacterMinAggregateOutputType | null
    _max: PlayerCharacterMaxAggregateOutputType | null
  }

  type GetPlayerCharacterGroupByPayload<T extends PlayerCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerCharacterGroupByOutputType[P]>
        }
      >
    >


  export type PlayerCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    playerName?: boolean
    characterName?: boolean
    race?: boolean
    class?: boolean
    level?: boolean
    alignment?: boolean
    backgroundType?: boolean
    background?: boolean
    languages?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    ac?: boolean
    passivePerception?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    encounterParticipants?: boolean | PlayerCharacter$encounterParticipantsArgs<ExtArgs>
    _count?: boolean | PlayerCharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCharacter"]>

  export type PlayerCharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    playerName?: boolean
    characterName?: boolean
    race?: boolean
    class?: boolean
    level?: boolean
    alignment?: boolean
    backgroundType?: boolean
    background?: boolean
    languages?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    ac?: boolean
    passivePerception?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCharacter"]>

  export type PlayerCharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    playerName?: boolean
    characterName?: boolean
    race?: boolean
    class?: boolean
    level?: boolean
    alignment?: boolean
    backgroundType?: boolean
    background?: boolean
    languages?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    ac?: boolean
    passivePerception?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerCharacter"]>

  export type PlayerCharacterSelectScalar = {
    id?: boolean
    campaignId?: boolean
    playerName?: boolean
    characterName?: boolean
    race?: boolean
    class?: boolean
    level?: boolean
    alignment?: boolean
    backgroundType?: boolean
    background?: boolean
    languages?: boolean
    portraitPath?: boolean
    hpMax?: boolean
    ac?: boolean
    passivePerception?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerCharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "playerName" | "characterName" | "race" | "class" | "level" | "alignment" | "backgroundType" | "background" | "languages" | "portraitPath" | "hpMax" | "ac" | "passivePerception" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["playerCharacter"]>
  export type PlayerCharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    encounterParticipants?: boolean | PlayerCharacter$encounterParticipantsArgs<ExtArgs>
    _count?: boolean | PlayerCharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerCharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type PlayerCharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $PlayerCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerCharacter"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      encounterParticipants: Prisma.$EncounterParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      playerName: string
      characterName: string
      race: $Enums.Race
      class: $Enums.CharacterClass
      level: number
      alignment: $Enums.Alignment
      backgroundType: $Enums.BackgroundType
      background: string | null
      languages: Prisma.JsonValue | null
      portraitPath: string | null
      hpMax: number
      ac: number
      passivePerception: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["playerCharacter"]>
    composites: {}
  }

  type PlayerCharacterGetPayload<S extends boolean | null | undefined | PlayerCharacterDefaultArgs> = $Result.GetResult<Prisma.$PlayerCharacterPayload, S>

  type PlayerCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerCharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCharacterCountAggregateInputType | true
    }

  export interface PlayerCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerCharacter'], meta: { name: 'PlayerCharacter' } }
    /**
     * Find zero or one PlayerCharacter that matches the filter.
     * @param {PlayerCharacterFindUniqueArgs} args - Arguments to find a PlayerCharacter
     * @example
     * // Get one PlayerCharacter
     * const playerCharacter = await prisma.playerCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerCharacterFindUniqueArgs>(args: SelectSubset<T, PlayerCharacterFindUniqueArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerCharacter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerCharacterFindUniqueOrThrowArgs} args - Arguments to find a PlayerCharacter
     * @example
     * // Get one PlayerCharacter
     * const playerCharacter = await prisma.playerCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerCharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerCharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterFindFirstArgs} args - Arguments to find a PlayerCharacter
     * @example
     * // Get one PlayerCharacter
     * const playerCharacter = await prisma.playerCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerCharacterFindFirstArgs>(args?: SelectSubset<T, PlayerCharacterFindFirstArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterFindFirstOrThrowArgs} args - Arguments to find a PlayerCharacter
     * @example
     * // Get one PlayerCharacter
     * const playerCharacter = await prisma.playerCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerCharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerCharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerCharacters
     * const playerCharacters = await prisma.playerCharacter.findMany()
     * 
     * // Get first 10 PlayerCharacters
     * const playerCharacters = await prisma.playerCharacter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerCharacterWithIdOnly = await prisma.playerCharacter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerCharacterFindManyArgs>(args?: SelectSubset<T, PlayerCharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerCharacter.
     * @param {PlayerCharacterCreateArgs} args - Arguments to create a PlayerCharacter.
     * @example
     * // Create one PlayerCharacter
     * const PlayerCharacter = await prisma.playerCharacter.create({
     *   data: {
     *     // ... data to create a PlayerCharacter
     *   }
     * })
     * 
     */
    create<T extends PlayerCharacterCreateArgs>(args: SelectSubset<T, PlayerCharacterCreateArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerCharacters.
     * @param {PlayerCharacterCreateManyArgs} args - Arguments to create many PlayerCharacters.
     * @example
     * // Create many PlayerCharacters
     * const playerCharacter = await prisma.playerCharacter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCharacterCreateManyArgs>(args?: SelectSubset<T, PlayerCharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerCharacters and returns the data saved in the database.
     * @param {PlayerCharacterCreateManyAndReturnArgs} args - Arguments to create many PlayerCharacters.
     * @example
     * // Create many PlayerCharacters
     * const playerCharacter = await prisma.playerCharacter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerCharacters and only return the `id`
     * const playerCharacterWithIdOnly = await prisma.playerCharacter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlayerCharacter.
     * @param {PlayerCharacterDeleteArgs} args - Arguments to delete one PlayerCharacter.
     * @example
     * // Delete one PlayerCharacter
     * const PlayerCharacter = await prisma.playerCharacter.delete({
     *   where: {
     *     // ... filter to delete one PlayerCharacter
     *   }
     * })
     * 
     */
    delete<T extends PlayerCharacterDeleteArgs>(args: SelectSubset<T, PlayerCharacterDeleteArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerCharacter.
     * @param {PlayerCharacterUpdateArgs} args - Arguments to update one PlayerCharacter.
     * @example
     * // Update one PlayerCharacter
     * const playerCharacter = await prisma.playerCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerCharacterUpdateArgs>(args: SelectSubset<T, PlayerCharacterUpdateArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerCharacters.
     * @param {PlayerCharacterDeleteManyArgs} args - Arguments to filter PlayerCharacters to delete.
     * @example
     * // Delete a few PlayerCharacters
     * const { count } = await prisma.playerCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerCharacterDeleteManyArgs>(args?: SelectSubset<T, PlayerCharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerCharacters
     * const playerCharacter = await prisma.playerCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerCharacterUpdateManyArgs>(args: SelectSubset<T, PlayerCharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerCharacters and returns the data updated in the database.
     * @param {PlayerCharacterUpdateManyAndReturnArgs} args - Arguments to update many PlayerCharacters.
     * @example
     * // Update many PlayerCharacters
     * const playerCharacter = await prisma.playerCharacter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlayerCharacters and only return the `id`
     * const playerCharacterWithIdOnly = await prisma.playerCharacter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerCharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerCharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlayerCharacter.
     * @param {PlayerCharacterUpsertArgs} args - Arguments to update or create a PlayerCharacter.
     * @example
     * // Update or create a PlayerCharacter
     * const playerCharacter = await prisma.playerCharacter.upsert({
     *   create: {
     *     // ... data to create a PlayerCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerCharacter we want to update
     *   }
     * })
     */
    upsert<T extends PlayerCharacterUpsertArgs>(args: SelectSubset<T, PlayerCharacterUpsertArgs<ExtArgs>>): Prisma__PlayerCharacterClient<$Result.GetResult<Prisma.$PlayerCharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlayerCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterCountArgs} args - Arguments to filter PlayerCharacters to count.
     * @example
     * // Count the number of PlayerCharacters
     * const count = await prisma.playerCharacter.count({
     *   where: {
     *     // ... the filter for the PlayerCharacters we want to count
     *   }
     * })
    **/
    count<T extends PlayerCharacterCountArgs>(
      args?: Subset<T, PlayerCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerCharacterAggregateArgs>(args: Subset<T, PlayerCharacterAggregateArgs>): Prisma.PrismaPromise<GetPlayerCharacterAggregateType<T>>

    /**
     * Group by PlayerCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerCharacterGroupByArgs['orderBy'] }
        : { orderBy?: PlayerCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerCharacter model
   */
  readonly fields: PlayerCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encounterParticipants<T extends PlayerCharacter$encounterParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, PlayerCharacter$encounterParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerCharacter model
   */
  interface PlayerCharacterFieldRefs {
    readonly id: FieldRef<"PlayerCharacter", 'String'>
    readonly campaignId: FieldRef<"PlayerCharacter", 'String'>
    readonly playerName: FieldRef<"PlayerCharacter", 'String'>
    readonly characterName: FieldRef<"PlayerCharacter", 'String'>
    readonly race: FieldRef<"PlayerCharacter", 'Race'>
    readonly class: FieldRef<"PlayerCharacter", 'CharacterClass'>
    readonly level: FieldRef<"PlayerCharacter", 'Int'>
    readonly alignment: FieldRef<"PlayerCharacter", 'Alignment'>
    readonly backgroundType: FieldRef<"PlayerCharacter", 'BackgroundType'>
    readonly background: FieldRef<"PlayerCharacter", 'String'>
    readonly languages: FieldRef<"PlayerCharacter", 'Json'>
    readonly portraitPath: FieldRef<"PlayerCharacter", 'String'>
    readonly hpMax: FieldRef<"PlayerCharacter", 'Int'>
    readonly ac: FieldRef<"PlayerCharacter", 'Int'>
    readonly passivePerception: FieldRef<"PlayerCharacter", 'Int'>
    readonly isActive: FieldRef<"PlayerCharacter", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerCharacter", 'DateTime'>
    readonly updatedAt: FieldRef<"PlayerCharacter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerCharacter findUnique
   */
  export type PlayerCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCharacter to fetch.
     */
    where: PlayerCharacterWhereUniqueInput
  }

  /**
   * PlayerCharacter findUniqueOrThrow
   */
  export type PlayerCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCharacter to fetch.
     */
    where: PlayerCharacterWhereUniqueInput
  }

  /**
   * PlayerCharacter findFirst
   */
  export type PlayerCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCharacter to fetch.
     */
    where?: PlayerCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCharacters to fetch.
     */
    orderBy?: PlayerCharacterOrderByWithRelationInput | PlayerCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerCharacters.
     */
    cursor?: PlayerCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerCharacters.
     */
    distinct?: PlayerCharacterScalarFieldEnum | PlayerCharacterScalarFieldEnum[]
  }

  /**
   * PlayerCharacter findFirstOrThrow
   */
  export type PlayerCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCharacter to fetch.
     */
    where?: PlayerCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCharacters to fetch.
     */
    orderBy?: PlayerCharacterOrderByWithRelationInput | PlayerCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerCharacters.
     */
    cursor?: PlayerCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerCharacters.
     */
    distinct?: PlayerCharacterScalarFieldEnum | PlayerCharacterScalarFieldEnum[]
  }

  /**
   * PlayerCharacter findMany
   */
  export type PlayerCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * Filter, which PlayerCharacters to fetch.
     */
    where?: PlayerCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerCharacters to fetch.
     */
    orderBy?: PlayerCharacterOrderByWithRelationInput | PlayerCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerCharacters.
     */
    cursor?: PlayerCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerCharacters.
     */
    skip?: number
    distinct?: PlayerCharacterScalarFieldEnum | PlayerCharacterScalarFieldEnum[]
  }

  /**
   * PlayerCharacter create
   */
  export type PlayerCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerCharacter.
     */
    data: XOR<PlayerCharacterCreateInput, PlayerCharacterUncheckedCreateInput>
  }

  /**
   * PlayerCharacter createMany
   */
  export type PlayerCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerCharacters.
     */
    data: PlayerCharacterCreateManyInput | PlayerCharacterCreateManyInput[]
  }

  /**
   * PlayerCharacter createManyAndReturn
   */
  export type PlayerCharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * The data used to create many PlayerCharacters.
     */
    data: PlayerCharacterCreateManyInput | PlayerCharacterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerCharacter update
   */
  export type PlayerCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerCharacter.
     */
    data: XOR<PlayerCharacterUpdateInput, PlayerCharacterUncheckedUpdateInput>
    /**
     * Choose, which PlayerCharacter to update.
     */
    where: PlayerCharacterWhereUniqueInput
  }

  /**
   * PlayerCharacter updateMany
   */
  export type PlayerCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerCharacters.
     */
    data: XOR<PlayerCharacterUpdateManyMutationInput, PlayerCharacterUncheckedUpdateManyInput>
    /**
     * Filter which PlayerCharacters to update
     */
    where?: PlayerCharacterWhereInput
    /**
     * Limit how many PlayerCharacters to update.
     */
    limit?: number
  }

  /**
   * PlayerCharacter updateManyAndReturn
   */
  export type PlayerCharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * The data used to update PlayerCharacters.
     */
    data: XOR<PlayerCharacterUpdateManyMutationInput, PlayerCharacterUncheckedUpdateManyInput>
    /**
     * Filter which PlayerCharacters to update
     */
    where?: PlayerCharacterWhereInput
    /**
     * Limit how many PlayerCharacters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerCharacter upsert
   */
  export type PlayerCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerCharacter to update in case it exists.
     */
    where: PlayerCharacterWhereUniqueInput
    /**
     * In case the PlayerCharacter found by the `where` argument doesn't exist, create a new PlayerCharacter with this data.
     */
    create: XOR<PlayerCharacterCreateInput, PlayerCharacterUncheckedCreateInput>
    /**
     * In case the PlayerCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerCharacterUpdateInput, PlayerCharacterUncheckedUpdateInput>
  }

  /**
   * PlayerCharacter delete
   */
  export type PlayerCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
    /**
     * Filter which PlayerCharacter to delete.
     */
    where: PlayerCharacterWhereUniqueInput
  }

  /**
   * PlayerCharacter deleteMany
   */
  export type PlayerCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerCharacters to delete
     */
    where?: PlayerCharacterWhereInput
    /**
     * Limit how many PlayerCharacters to delete.
     */
    limit?: number
  }

  /**
   * PlayerCharacter.encounterParticipants
   */
  export type PlayerCharacter$encounterParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterParticipant
     */
    select?: EncounterParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterParticipant
     */
    omit?: EncounterParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterParticipantInclude<ExtArgs> | null
    where?: EncounterParticipantWhereInput
    orderBy?: EncounterParticipantOrderByWithRelationInput | EncounterParticipantOrderByWithRelationInput[]
    cursor?: EncounterParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterParticipantScalarFieldEnum | EncounterParticipantScalarFieldEnum[]
  }

  /**
   * PlayerCharacter without action
   */
  export type PlayerCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCharacter
     */
    select?: PlayerCharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerCharacter
     */
    omit?: PlayerCharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerCharacterInclude<ExtArgs> | null
  }


  /**
   * Model Quest
   */

  export type AggregateQuest = {
    _count: QuestCountAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  export type QuestMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    parentQuestId: string | null
    name: string | null
    description: string | null
    status: $Enums.QuestStatus | null
    questGiverNpcId: string | null
    rewardDescription: string | null
    isMilestone: boolean | null
    dmNotes: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type QuestMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    parentQuestId: string | null
    name: string | null
    description: string | null
    status: $Enums.QuestStatus | null
    questGiverNpcId: string | null
    rewardDescription: string | null
    isMilestone: boolean | null
    dmNotes: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type QuestCountAggregateOutputType = {
    id: number
    campaignId: number
    parentQuestId: number
    name: number
    description: number
    objectives: number
    status: number
    questGiverNpcId: number
    rewardDescription: number
    rewardItems: number
    isMilestone: number
    dmNotes: number
    createdAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type QuestMinAggregateInputType = {
    id?: true
    campaignId?: true
    parentQuestId?: true
    name?: true
    description?: true
    status?: true
    questGiverNpcId?: true
    rewardDescription?: true
    isMilestone?: true
    dmNotes?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type QuestMaxAggregateInputType = {
    id?: true
    campaignId?: true
    parentQuestId?: true
    name?: true
    description?: true
    status?: true
    questGiverNpcId?: true
    rewardDescription?: true
    isMilestone?: true
    dmNotes?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type QuestCountAggregateInputType = {
    id?: true
    campaignId?: true
    parentQuestId?: true
    name?: true
    description?: true
    objectives?: true
    status?: true
    questGiverNpcId?: true
    rewardDescription?: true
    rewardItems?: true
    isMilestone?: true
    dmNotes?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type QuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quest to aggregate.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quests
    **/
    _count?: true | QuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestMaxAggregateInputType
  }

  export type GetQuestAggregateType<T extends QuestAggregateArgs> = {
        [P in keyof T & keyof AggregateQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuest[P]>
      : GetScalarType<T[P], AggregateQuest[P]>
  }




  export type QuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithAggregationInput | QuestOrderByWithAggregationInput[]
    by: QuestScalarFieldEnum[] | QuestScalarFieldEnum
    having?: QuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestCountAggregateInputType | true
    _min?: QuestMinAggregateInputType
    _max?: QuestMaxAggregateInputType
  }

  export type QuestGroupByOutputType = {
    id: string
    campaignId: string
    parentQuestId: string | null
    name: string
    description: string | null
    objectives: JsonValue | null
    status: $Enums.QuestStatus
    questGiverNpcId: string | null
    rewardDescription: string | null
    rewardItems: JsonValue | null
    isMilestone: boolean
    dmNotes: string | null
    createdAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: QuestCountAggregateOutputType | null
    _min: QuestMinAggregateOutputType | null
    _max: QuestMaxAggregateOutputType | null
  }

  type GetQuestGroupByPayload<T extends QuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestGroupByOutputType[P]>
            : GetScalarType<T[P], QuestGroupByOutputType[P]>
        }
      >
    >


  export type QuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    parentQuestId?: boolean
    name?: boolean
    description?: boolean
    objectives?: boolean
    status?: boolean
    questGiverNpcId?: boolean
    rewardDescription?: boolean
    rewardItems?: boolean
    isMilestone?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentQuest?: boolean | Quest$parentQuestArgs<ExtArgs>
    subQuests?: boolean | Quest$subQuestsArgs<ExtArgs>
    questGiver?: boolean | Quest$questGiverArgs<ExtArgs>
    npcs?: boolean | Quest$npcsArgs<ExtArgs>
    locations?: boolean | Quest$locationsArgs<ExtArgs>
    chronicles?: boolean | Quest$chroniclesArgs<ExtArgs>
    _count?: boolean | QuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    parentQuestId?: boolean
    name?: boolean
    description?: boolean
    objectives?: boolean
    status?: boolean
    questGiverNpcId?: boolean
    rewardDescription?: boolean
    rewardItems?: boolean
    isMilestone?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentQuest?: boolean | Quest$parentQuestArgs<ExtArgs>
    questGiver?: boolean | Quest$questGiverArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    parentQuestId?: boolean
    name?: boolean
    description?: boolean
    objectives?: boolean
    status?: boolean
    questGiverNpcId?: boolean
    rewardDescription?: boolean
    rewardItems?: boolean
    isMilestone?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentQuest?: boolean | Quest$parentQuestArgs<ExtArgs>
    questGiver?: boolean | Quest$questGiverArgs<ExtArgs>
  }, ExtArgs["result"]["quest"]>

  export type QuestSelectScalar = {
    id?: boolean
    campaignId?: boolean
    parentQuestId?: boolean
    name?: boolean
    description?: boolean
    objectives?: boolean
    status?: boolean
    questGiverNpcId?: boolean
    rewardDescription?: boolean
    rewardItems?: boolean
    isMilestone?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type QuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "parentQuestId" | "name" | "description" | "objectives" | "status" | "questGiverNpcId" | "rewardDescription" | "rewardItems" | "isMilestone" | "dmNotes" | "createdAt" | "startedAt" | "completedAt", ExtArgs["result"]["quest"]>
  export type QuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentQuest?: boolean | Quest$parentQuestArgs<ExtArgs>
    subQuests?: boolean | Quest$subQuestsArgs<ExtArgs>
    questGiver?: boolean | Quest$questGiverArgs<ExtArgs>
    npcs?: boolean | Quest$npcsArgs<ExtArgs>
    locations?: boolean | Quest$locationsArgs<ExtArgs>
    chronicles?: boolean | Quest$chroniclesArgs<ExtArgs>
    _count?: boolean | QuestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentQuest?: boolean | Quest$parentQuestArgs<ExtArgs>
    questGiver?: boolean | Quest$questGiverArgs<ExtArgs>
  }
  export type QuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    parentQuest?: boolean | Quest$parentQuestArgs<ExtArgs>
    questGiver?: boolean | Quest$questGiverArgs<ExtArgs>
  }

  export type $QuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quest"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      parentQuest: Prisma.$QuestPayload<ExtArgs> | null
      subQuests: Prisma.$QuestPayload<ExtArgs>[]
      questGiver: Prisma.$NPCPayload<ExtArgs> | null
      npcs: Prisma.$QuestNPCPayload<ExtArgs>[]
      locations: Prisma.$QuestLocationPayload<ExtArgs>[]
      chronicles: Prisma.$ChronicleQuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      parentQuestId: string | null
      name: string
      description: string | null
      objectives: Prisma.JsonValue | null
      status: $Enums.QuestStatus
      questGiverNpcId: string | null
      rewardDescription: string | null
      rewardItems: Prisma.JsonValue | null
      isMilestone: boolean
      dmNotes: string | null
      createdAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["quest"]>
    composites: {}
  }

  type QuestGetPayload<S extends boolean | null | undefined | QuestDefaultArgs> = $Result.GetResult<Prisma.$QuestPayload, S>

  type QuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestCountAggregateInputType | true
    }

  export interface QuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quest'], meta: { name: 'Quest' } }
    /**
     * Find zero or one Quest that matches the filter.
     * @param {QuestFindUniqueArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestFindUniqueArgs>(args: SelectSubset<T, QuestFindUniqueArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestFindUniqueOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestFindFirstArgs>(args?: SelectSubset<T, QuestFindFirstArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindFirstOrThrowArgs} args - Arguments to find a Quest
     * @example
     * // Get one Quest
     * const quest = await prisma.quest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quests
     * const quests = await prisma.quest.findMany()
     * 
     * // Get first 10 Quests
     * const quests = await prisma.quest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questWithIdOnly = await prisma.quest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestFindManyArgs>(args?: SelectSubset<T, QuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quest.
     * @param {QuestCreateArgs} args - Arguments to create a Quest.
     * @example
     * // Create one Quest
     * const Quest = await prisma.quest.create({
     *   data: {
     *     // ... data to create a Quest
     *   }
     * })
     * 
     */
    create<T extends QuestCreateArgs>(args: SelectSubset<T, QuestCreateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quests.
     * @param {QuestCreateManyArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestCreateManyArgs>(args?: SelectSubset<T, QuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quests and returns the data saved in the database.
     * @param {QuestCreateManyAndReturnArgs} args - Arguments to create many Quests.
     * @example
     * // Create many Quests
     * const quest = await prisma.quest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quest.
     * @param {QuestDeleteArgs} args - Arguments to delete one Quest.
     * @example
     * // Delete one Quest
     * const Quest = await prisma.quest.delete({
     *   where: {
     *     // ... filter to delete one Quest
     *   }
     * })
     * 
     */
    delete<T extends QuestDeleteArgs>(args: SelectSubset<T, QuestDeleteArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quest.
     * @param {QuestUpdateArgs} args - Arguments to update one Quest.
     * @example
     * // Update one Quest
     * const quest = await prisma.quest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestUpdateArgs>(args: SelectSubset<T, QuestUpdateArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quests.
     * @param {QuestDeleteManyArgs} args - Arguments to filter Quests to delete.
     * @example
     * // Delete a few Quests
     * const { count } = await prisma.quest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestDeleteManyArgs>(args?: SelectSubset<T, QuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestUpdateManyArgs>(args: SelectSubset<T, QuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quests and returns the data updated in the database.
     * @param {QuestUpdateManyAndReturnArgs} args - Arguments to update many Quests.
     * @example
     * // Update many Quests
     * const quest = await prisma.quest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quests and only return the `id`
     * const questWithIdOnly = await prisma.quest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quest.
     * @param {QuestUpsertArgs} args - Arguments to update or create a Quest.
     * @example
     * // Update or create a Quest
     * const quest = await prisma.quest.upsert({
     *   create: {
     *     // ... data to create a Quest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quest we want to update
     *   }
     * })
     */
    upsert<T extends QuestUpsertArgs>(args: SelectSubset<T, QuestUpsertArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestCountArgs} args - Arguments to filter Quests to count.
     * @example
     * // Count the number of Quests
     * const count = await prisma.quest.count({
     *   where: {
     *     // ... the filter for the Quests we want to count
     *   }
     * })
    **/
    count<T extends QuestCountArgs>(
      args?: Subset<T, QuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestAggregateArgs>(args: Subset<T, QuestAggregateArgs>): Prisma.PrismaPromise<GetQuestAggregateType<T>>

    /**
     * Group by Quest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestGroupByArgs['orderBy'] }
        : { orderBy?: QuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quest model
   */
  readonly fields: QuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentQuest<T extends Quest$parentQuestArgs<ExtArgs> = {}>(args?: Subset<T, Quest$parentQuestArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subQuests<T extends Quest$subQuestsArgs<ExtArgs> = {}>(args?: Subset<T, Quest$subQuestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questGiver<T extends Quest$questGiverArgs<ExtArgs> = {}>(args?: Subset<T, Quest$questGiverArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    npcs<T extends Quest$npcsArgs<ExtArgs> = {}>(args?: Subset<T, Quest$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Quest$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Quest$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chronicles<T extends Quest$chroniclesArgs<ExtArgs> = {}>(args?: Subset<T, Quest$chroniclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quest model
   */
  interface QuestFieldRefs {
    readonly id: FieldRef<"Quest", 'String'>
    readonly campaignId: FieldRef<"Quest", 'String'>
    readonly parentQuestId: FieldRef<"Quest", 'String'>
    readonly name: FieldRef<"Quest", 'String'>
    readonly description: FieldRef<"Quest", 'String'>
    readonly objectives: FieldRef<"Quest", 'Json'>
    readonly status: FieldRef<"Quest", 'QuestStatus'>
    readonly questGiverNpcId: FieldRef<"Quest", 'String'>
    readonly rewardDescription: FieldRef<"Quest", 'String'>
    readonly rewardItems: FieldRef<"Quest", 'Json'>
    readonly isMilestone: FieldRef<"Quest", 'Boolean'>
    readonly dmNotes: FieldRef<"Quest", 'String'>
    readonly createdAt: FieldRef<"Quest", 'DateTime'>
    readonly startedAt: FieldRef<"Quest", 'DateTime'>
    readonly completedAt: FieldRef<"Quest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quest findUnique
   */
  export type QuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findUniqueOrThrow
   */
  export type QuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest findFirst
   */
  export type QuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findFirstOrThrow
   */
  export type QuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quest to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quests.
     */
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest findMany
   */
  export type QuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter, which Quests to fetch.
     */
    where?: QuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quests to fetch.
     */
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quests.
     */
    cursor?: QuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quests.
     */
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest create
   */
  export type QuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Quest.
     */
    data: XOR<QuestCreateInput, QuestUncheckedCreateInput>
  }

  /**
   * Quest createMany
   */
  export type QuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
  }

  /**
   * Quest createManyAndReturn
   */
  export type QuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * The data used to create many Quests.
     */
    data: QuestCreateManyInput | QuestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quest update
   */
  export type QuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Quest.
     */
    data: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
    /**
     * Choose, which Quest to update.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest updateMany
   */
  export type QuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to update.
     */
    limit?: number
  }

  /**
   * Quest updateManyAndReturn
   */
  export type QuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * The data used to update Quests.
     */
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyInput>
    /**
     * Filter which Quests to update
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quest upsert
   */
  export type QuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Quest to update in case it exists.
     */
    where: QuestWhereUniqueInput
    /**
     * In case the Quest found by the `where` argument doesn't exist, create a new Quest with this data.
     */
    create: XOR<QuestCreateInput, QuestUncheckedCreateInput>
    /**
     * In case the Quest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestUpdateInput, QuestUncheckedUpdateInput>
  }

  /**
   * Quest delete
   */
  export type QuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    /**
     * Filter which Quest to delete.
     */
    where: QuestWhereUniqueInput
  }

  /**
   * Quest deleteMany
   */
  export type QuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quests to delete
     */
    where?: QuestWhereInput
    /**
     * Limit how many Quests to delete.
     */
    limit?: number
  }

  /**
   * Quest.parentQuest
   */
  export type Quest$parentQuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
  }

  /**
   * Quest.subQuests
   */
  export type Quest$subQuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
    where?: QuestWhereInput
    orderBy?: QuestOrderByWithRelationInput | QuestOrderByWithRelationInput[]
    cursor?: QuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestScalarFieldEnum | QuestScalarFieldEnum[]
  }

  /**
   * Quest.questGiver
   */
  export type Quest$questGiverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPC
     */
    omit?: NPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
  }

  /**
   * Quest.npcs
   */
  export type Quest$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    where?: QuestNPCWhereInput
    orderBy?: QuestNPCOrderByWithRelationInput | QuestNPCOrderByWithRelationInput[]
    cursor?: QuestNPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestNPCScalarFieldEnum | QuestNPCScalarFieldEnum[]
  }

  /**
   * Quest.locations
   */
  export type Quest$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    where?: QuestLocationWhereInput
    orderBy?: QuestLocationOrderByWithRelationInput | QuestLocationOrderByWithRelationInput[]
    cursor?: QuestLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestLocationScalarFieldEnum | QuestLocationScalarFieldEnum[]
  }

  /**
   * Quest.chronicles
   */
  export type Quest$chroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    where?: ChronicleQuestWhereInput
    orderBy?: ChronicleQuestOrderByWithRelationInput | ChronicleQuestOrderByWithRelationInput[]
    cursor?: ChronicleQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChronicleQuestScalarFieldEnum | ChronicleQuestScalarFieldEnum[]
  }

  /**
   * Quest without action
   */
  export type QuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quest
     */
    select?: QuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quest
     */
    omit?: QuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    weight: number | null
    quantity: number | null
  }

  export type ItemSumAggregateOutputType = {
    weight: number | null
    quantity: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ItemType | null
    rarity: $Enums.ItemRarity | null
    description: string | null
    mechanicalEffects: string | null
    value: string | null
    weight: number | null
    quantity: number | null
    isMagical: boolean | null
    attunementRequired: boolean | null
    dmNotes: string | null
    createdAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ItemType | null
    rarity: $Enums.ItemRarity | null
    description: string | null
    mechanicalEffects: string | null
    value: string | null
    weight: number | null
    quantity: number | null
    isMagical: boolean | null
    attunementRequired: boolean | null
    dmNotes: string | null
    createdAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    type: number
    rarity: number
    description: number
    mechanicalEffects: number
    grantedAbilities: number
    value: number
    weight: number
    quantity: number
    isMagical: number
    attunementRequired: number
    dmNotes: number
    createdAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    weight?: true
    quantity?: true
  }

  export type ItemSumAggregateInputType = {
    weight?: true
    quantity?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    rarity?: true
    description?: true
    mechanicalEffects?: true
    value?: true
    weight?: true
    quantity?: true
    isMagical?: true
    attunementRequired?: true
    dmNotes?: true
    createdAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    rarity?: true
    description?: true
    mechanicalEffects?: true
    value?: true
    weight?: true
    quantity?: true
    isMagical?: true
    attunementRequired?: true
    dmNotes?: true
    createdAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    rarity?: true
    description?: true
    mechanicalEffects?: true
    grantedAbilities?: true
    value?: true
    weight?: true
    quantity?: true
    isMagical?: true
    attunementRequired?: true
    dmNotes?: true
    createdAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description: string | null
    mechanicalEffects: string | null
    grantedAbilities: JsonValue | null
    value: string | null
    weight: number | null
    quantity: number
    isMagical: boolean
    attunementRequired: boolean
    dmNotes: string | null
    createdAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    rarity?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    grantedAbilities?: boolean
    value?: boolean
    weight?: boolean
    quantity?: boolean
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    campaigns?: boolean | Item$campaignsArgs<ExtArgs>
    locations?: boolean | Item$locationsArgs<ExtArgs>
    npcs?: boolean | Item$npcsArgs<ExtArgs>
    interactions?: boolean | Item$interactionsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    rarity?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    grantedAbilities?: boolean
    value?: boolean
    weight?: boolean
    quantity?: boolean
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    rarity?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    grantedAbilities?: boolean
    value?: boolean
    weight?: boolean
    quantity?: boolean
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    rarity?: boolean
    description?: boolean
    mechanicalEffects?: boolean
    grantedAbilities?: boolean
    value?: boolean
    weight?: boolean
    quantity?: boolean
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: boolean
    createdAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "rarity" | "description" | "mechanicalEffects" | "grantedAbilities" | "value" | "weight" | "quantity" | "isMagical" | "attunementRequired" | "dmNotes" | "createdAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | Item$campaignsArgs<ExtArgs>
    locations?: boolean | Item$locationsArgs<ExtArgs>
    npcs?: boolean | Item$npcsArgs<ExtArgs>
    interactions?: boolean | Item$interactionsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      campaigns: Prisma.$ItemCampaignPayload<ExtArgs>[]
      locations: Prisma.$ItemLocationPayload<ExtArgs>[]
      npcs: Prisma.$ItemNPCPayload<ExtArgs>[]
      interactions: Prisma.$InteractionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ItemType
      rarity: $Enums.ItemRarity
      description: string | null
      mechanicalEffects: string | null
      grantedAbilities: Prisma.JsonValue | null
      value: string | null
      weight: number | null
      quantity: number
      isMagical: boolean
      attunementRequired: boolean
      dmNotes: string | null
      createdAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends Item$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Item$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Item$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Item$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    npcs<T extends Item$npcsArgs<ExtArgs> = {}>(args?: Subset<T, Item$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Item$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Item$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'ItemType'>
    readonly rarity: FieldRef<"Item", 'ItemRarity'>
    readonly description: FieldRef<"Item", 'String'>
    readonly mechanicalEffects: FieldRef<"Item", 'String'>
    readonly grantedAbilities: FieldRef<"Item", 'Json'>
    readonly value: FieldRef<"Item", 'String'>
    readonly weight: FieldRef<"Item", 'Float'>
    readonly quantity: FieldRef<"Item", 'Int'>
    readonly isMagical: FieldRef<"Item", 'Boolean'>
    readonly attunementRequired: FieldRef<"Item", 'Boolean'>
    readonly dmNotes: FieldRef<"Item", 'String'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.campaigns
   */
  export type Item$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    where?: ItemCampaignWhereInput
    orderBy?: ItemCampaignOrderByWithRelationInput | ItemCampaignOrderByWithRelationInput[]
    cursor?: ItemCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCampaignScalarFieldEnum | ItemCampaignScalarFieldEnum[]
  }

  /**
   * Item.locations
   */
  export type Item$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    where?: ItemLocationWhereInput
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    cursor?: ItemLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }

  /**
   * Item.npcs
   */
  export type Item$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    where?: ItemNPCWhereInput
    orderBy?: ItemNPCOrderByWithRelationInput | ItemNPCOrderByWithRelationInput[]
    cursor?: ItemNPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemNPCScalarFieldEnum | ItemNPCScalarFieldEnum[]
  }

  /**
   * Item.interactions
   */
  export type Item$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    where?: InteractionItemWhereInput
    orderBy?: InteractionItemOrderByWithRelationInput | InteractionItemOrderByWithRelationInput[]
    cursor?: InteractionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionItemScalarFieldEnum | InteractionItemScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model Chronicle
   */

  export type AggregateChronicle = {
    _count: ChronicleCountAggregateOutputType | null
    _avg: ChronicleAvgAggregateOutputType | null
    _sum: ChronicleSumAggregateOutputType | null
    _min: ChronicleMinAggregateOutputType | null
    _max: ChronicleMaxAggregateOutputType | null
  }

  export type ChronicleAvgAggregateOutputType = {
    sessionNumber: number | null
  }

  export type ChronicleSumAggregateOutputType = {
    sessionNumber: number | null
  }

  export type ChronicleMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    sessionNumber: number | null
    sessionDate: Date | null
    title: string | null
    summary: string | null
    dmNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChronicleMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    sessionNumber: number | null
    sessionDate: Date | null
    title: string | null
    summary: string | null
    dmNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChronicleCountAggregateOutputType = {
    id: number
    campaignId: number
    sessionNumber: number
    sessionDate: number
    title: number
    summary: number
    playerDeeds: number
    importantDecisions: number
    dmNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChronicleAvgAggregateInputType = {
    sessionNumber?: true
  }

  export type ChronicleSumAggregateInputType = {
    sessionNumber?: true
  }

  export type ChronicleMinAggregateInputType = {
    id?: true
    campaignId?: true
    sessionNumber?: true
    sessionDate?: true
    title?: true
    summary?: true
    dmNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChronicleMaxAggregateInputType = {
    id?: true
    campaignId?: true
    sessionNumber?: true
    sessionDate?: true
    title?: true
    summary?: true
    dmNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChronicleCountAggregateInputType = {
    id?: true
    campaignId?: true
    sessionNumber?: true
    sessionDate?: true
    title?: true
    summary?: true
    playerDeeds?: true
    importantDecisions?: true
    dmNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChronicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chronicle to aggregate.
     */
    where?: ChronicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chronicles to fetch.
     */
    orderBy?: ChronicleOrderByWithRelationInput | ChronicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChronicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chronicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chronicles
    **/
    _count?: true | ChronicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChronicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChronicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChronicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChronicleMaxAggregateInputType
  }

  export type GetChronicleAggregateType<T extends ChronicleAggregateArgs> = {
        [P in keyof T & keyof AggregateChronicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChronicle[P]>
      : GetScalarType<T[P], AggregateChronicle[P]>
  }




  export type ChronicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChronicleWhereInput
    orderBy?: ChronicleOrderByWithAggregationInput | ChronicleOrderByWithAggregationInput[]
    by: ChronicleScalarFieldEnum[] | ChronicleScalarFieldEnum
    having?: ChronicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChronicleCountAggregateInputType | true
    _avg?: ChronicleAvgAggregateInputType
    _sum?: ChronicleSumAggregateInputType
    _min?: ChronicleMinAggregateInputType
    _max?: ChronicleMaxAggregateInputType
  }

  export type ChronicleGroupByOutputType = {
    id: string
    campaignId: string
    sessionNumber: number
    sessionDate: Date
    title: string | null
    summary: string | null
    playerDeeds: JsonValue | null
    importantDecisions: JsonValue | null
    dmNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChronicleCountAggregateOutputType | null
    _avg: ChronicleAvgAggregateOutputType | null
    _sum: ChronicleSumAggregateOutputType | null
    _min: ChronicleMinAggregateOutputType | null
    _max: ChronicleMaxAggregateOutputType | null
  }

  type GetChronicleGroupByPayload<T extends ChronicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChronicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChronicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChronicleGroupByOutputType[P]>
            : GetScalarType<T[P], ChronicleGroupByOutputType[P]>
        }
      >
    >


  export type ChronicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    sessionNumber?: boolean
    sessionDate?: boolean
    title?: boolean
    summary?: boolean
    playerDeeds?: boolean
    importantDecisions?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    quests?: boolean | Chronicle$questsArgs<ExtArgs>
    _count?: boolean | ChronicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicle"]>

  export type ChronicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    sessionNumber?: boolean
    sessionDate?: boolean
    title?: boolean
    summary?: boolean
    playerDeeds?: boolean
    importantDecisions?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicle"]>

  export type ChronicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    sessionNumber?: boolean
    sessionDate?: boolean
    title?: boolean
    summary?: boolean
    playerDeeds?: boolean
    importantDecisions?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicle"]>

  export type ChronicleSelectScalar = {
    id?: boolean
    campaignId?: boolean
    sessionNumber?: boolean
    sessionDate?: boolean
    title?: boolean
    summary?: boolean
    playerDeeds?: boolean
    importantDecisions?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChronicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "sessionNumber" | "sessionDate" | "title" | "summary" | "playerDeeds" | "importantDecisions" | "dmNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["chronicle"]>
  export type ChronicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    quests?: boolean | Chronicle$questsArgs<ExtArgs>
    _count?: boolean | ChronicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChronicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ChronicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ChroniclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chronicle"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      quests: Prisma.$ChronicleQuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      sessionNumber: number
      sessionDate: Date
      title: string | null
      summary: string | null
      playerDeeds: Prisma.JsonValue | null
      importantDecisions: Prisma.JsonValue | null
      dmNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chronicle"]>
    composites: {}
  }

  type ChronicleGetPayload<S extends boolean | null | undefined | ChronicleDefaultArgs> = $Result.GetResult<Prisma.$ChroniclePayload, S>

  type ChronicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChronicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChronicleCountAggregateInputType | true
    }

  export interface ChronicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chronicle'], meta: { name: 'Chronicle' } }
    /**
     * Find zero or one Chronicle that matches the filter.
     * @param {ChronicleFindUniqueArgs} args - Arguments to find a Chronicle
     * @example
     * // Get one Chronicle
     * const chronicle = await prisma.chronicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChronicleFindUniqueArgs>(args: SelectSubset<T, ChronicleFindUniqueArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chronicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChronicleFindUniqueOrThrowArgs} args - Arguments to find a Chronicle
     * @example
     * // Get one Chronicle
     * const chronicle = await prisma.chronicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChronicleFindUniqueOrThrowArgs>(args: SelectSubset<T, ChronicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chronicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleFindFirstArgs} args - Arguments to find a Chronicle
     * @example
     * // Get one Chronicle
     * const chronicle = await prisma.chronicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChronicleFindFirstArgs>(args?: SelectSubset<T, ChronicleFindFirstArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chronicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleFindFirstOrThrowArgs} args - Arguments to find a Chronicle
     * @example
     * // Get one Chronicle
     * const chronicle = await prisma.chronicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChronicleFindFirstOrThrowArgs>(args?: SelectSubset<T, ChronicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chronicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chronicles
     * const chronicles = await prisma.chronicle.findMany()
     * 
     * // Get first 10 Chronicles
     * const chronicles = await prisma.chronicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chronicleWithIdOnly = await prisma.chronicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChronicleFindManyArgs>(args?: SelectSubset<T, ChronicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chronicle.
     * @param {ChronicleCreateArgs} args - Arguments to create a Chronicle.
     * @example
     * // Create one Chronicle
     * const Chronicle = await prisma.chronicle.create({
     *   data: {
     *     // ... data to create a Chronicle
     *   }
     * })
     * 
     */
    create<T extends ChronicleCreateArgs>(args: SelectSubset<T, ChronicleCreateArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chronicles.
     * @param {ChronicleCreateManyArgs} args - Arguments to create many Chronicles.
     * @example
     * // Create many Chronicles
     * const chronicle = await prisma.chronicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChronicleCreateManyArgs>(args?: SelectSubset<T, ChronicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chronicles and returns the data saved in the database.
     * @param {ChronicleCreateManyAndReturnArgs} args - Arguments to create many Chronicles.
     * @example
     * // Create many Chronicles
     * const chronicle = await prisma.chronicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chronicles and only return the `id`
     * const chronicleWithIdOnly = await prisma.chronicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChronicleCreateManyAndReturnArgs>(args?: SelectSubset<T, ChronicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chronicle.
     * @param {ChronicleDeleteArgs} args - Arguments to delete one Chronicle.
     * @example
     * // Delete one Chronicle
     * const Chronicle = await prisma.chronicle.delete({
     *   where: {
     *     // ... filter to delete one Chronicle
     *   }
     * })
     * 
     */
    delete<T extends ChronicleDeleteArgs>(args: SelectSubset<T, ChronicleDeleteArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chronicle.
     * @param {ChronicleUpdateArgs} args - Arguments to update one Chronicle.
     * @example
     * // Update one Chronicle
     * const chronicle = await prisma.chronicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChronicleUpdateArgs>(args: SelectSubset<T, ChronicleUpdateArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chronicles.
     * @param {ChronicleDeleteManyArgs} args - Arguments to filter Chronicles to delete.
     * @example
     * // Delete a few Chronicles
     * const { count } = await prisma.chronicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChronicleDeleteManyArgs>(args?: SelectSubset<T, ChronicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chronicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chronicles
     * const chronicle = await prisma.chronicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChronicleUpdateManyArgs>(args: SelectSubset<T, ChronicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chronicles and returns the data updated in the database.
     * @param {ChronicleUpdateManyAndReturnArgs} args - Arguments to update many Chronicles.
     * @example
     * // Update many Chronicles
     * const chronicle = await prisma.chronicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chronicles and only return the `id`
     * const chronicleWithIdOnly = await prisma.chronicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChronicleUpdateManyAndReturnArgs>(args: SelectSubset<T, ChronicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chronicle.
     * @param {ChronicleUpsertArgs} args - Arguments to update or create a Chronicle.
     * @example
     * // Update or create a Chronicle
     * const chronicle = await prisma.chronicle.upsert({
     *   create: {
     *     // ... data to create a Chronicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chronicle we want to update
     *   }
     * })
     */
    upsert<T extends ChronicleUpsertArgs>(args: SelectSubset<T, ChronicleUpsertArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chronicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleCountArgs} args - Arguments to filter Chronicles to count.
     * @example
     * // Count the number of Chronicles
     * const count = await prisma.chronicle.count({
     *   where: {
     *     // ... the filter for the Chronicles we want to count
     *   }
     * })
    **/
    count<T extends ChronicleCountArgs>(
      args?: Subset<T, ChronicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChronicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chronicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChronicleAggregateArgs>(args: Subset<T, ChronicleAggregateArgs>): Prisma.PrismaPromise<GetChronicleAggregateType<T>>

    /**
     * Group by Chronicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChronicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChronicleGroupByArgs['orderBy'] }
        : { orderBy?: ChronicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChronicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChronicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chronicle model
   */
  readonly fields: ChronicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chronicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChronicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quests<T extends Chronicle$questsArgs<ExtArgs> = {}>(args?: Subset<T, Chronicle$questsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chronicle model
   */
  interface ChronicleFieldRefs {
    readonly id: FieldRef<"Chronicle", 'String'>
    readonly campaignId: FieldRef<"Chronicle", 'String'>
    readonly sessionNumber: FieldRef<"Chronicle", 'Int'>
    readonly sessionDate: FieldRef<"Chronicle", 'DateTime'>
    readonly title: FieldRef<"Chronicle", 'String'>
    readonly summary: FieldRef<"Chronicle", 'String'>
    readonly playerDeeds: FieldRef<"Chronicle", 'Json'>
    readonly importantDecisions: FieldRef<"Chronicle", 'Json'>
    readonly dmNotes: FieldRef<"Chronicle", 'String'>
    readonly createdAt: FieldRef<"Chronicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Chronicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chronicle findUnique
   */
  export type ChronicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * Filter, which Chronicle to fetch.
     */
    where: ChronicleWhereUniqueInput
  }

  /**
   * Chronicle findUniqueOrThrow
   */
  export type ChronicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * Filter, which Chronicle to fetch.
     */
    where: ChronicleWhereUniqueInput
  }

  /**
   * Chronicle findFirst
   */
  export type ChronicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * Filter, which Chronicle to fetch.
     */
    where?: ChronicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chronicles to fetch.
     */
    orderBy?: ChronicleOrderByWithRelationInput | ChronicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chronicles.
     */
    cursor?: ChronicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chronicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chronicles.
     */
    distinct?: ChronicleScalarFieldEnum | ChronicleScalarFieldEnum[]
  }

  /**
   * Chronicle findFirstOrThrow
   */
  export type ChronicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * Filter, which Chronicle to fetch.
     */
    where?: ChronicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chronicles to fetch.
     */
    orderBy?: ChronicleOrderByWithRelationInput | ChronicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chronicles.
     */
    cursor?: ChronicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chronicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chronicles.
     */
    distinct?: ChronicleScalarFieldEnum | ChronicleScalarFieldEnum[]
  }

  /**
   * Chronicle findMany
   */
  export type ChronicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * Filter, which Chronicles to fetch.
     */
    where?: ChronicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chronicles to fetch.
     */
    orderBy?: ChronicleOrderByWithRelationInput | ChronicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chronicles.
     */
    cursor?: ChronicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chronicles.
     */
    skip?: number
    distinct?: ChronicleScalarFieldEnum | ChronicleScalarFieldEnum[]
  }

  /**
   * Chronicle create
   */
  export type ChronicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Chronicle.
     */
    data: XOR<ChronicleCreateInput, ChronicleUncheckedCreateInput>
  }

  /**
   * Chronicle createMany
   */
  export type ChronicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chronicles.
     */
    data: ChronicleCreateManyInput | ChronicleCreateManyInput[]
  }

  /**
   * Chronicle createManyAndReturn
   */
  export type ChronicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * The data used to create many Chronicles.
     */
    data: ChronicleCreateManyInput | ChronicleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chronicle update
   */
  export type ChronicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Chronicle.
     */
    data: XOR<ChronicleUpdateInput, ChronicleUncheckedUpdateInput>
    /**
     * Choose, which Chronicle to update.
     */
    where: ChronicleWhereUniqueInput
  }

  /**
   * Chronicle updateMany
   */
  export type ChronicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chronicles.
     */
    data: XOR<ChronicleUpdateManyMutationInput, ChronicleUncheckedUpdateManyInput>
    /**
     * Filter which Chronicles to update
     */
    where?: ChronicleWhereInput
    /**
     * Limit how many Chronicles to update.
     */
    limit?: number
  }

  /**
   * Chronicle updateManyAndReturn
   */
  export type ChronicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * The data used to update Chronicles.
     */
    data: XOR<ChronicleUpdateManyMutationInput, ChronicleUncheckedUpdateManyInput>
    /**
     * Filter which Chronicles to update
     */
    where?: ChronicleWhereInput
    /**
     * Limit how many Chronicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chronicle upsert
   */
  export type ChronicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Chronicle to update in case it exists.
     */
    where: ChronicleWhereUniqueInput
    /**
     * In case the Chronicle found by the `where` argument doesn't exist, create a new Chronicle with this data.
     */
    create: XOR<ChronicleCreateInput, ChronicleUncheckedCreateInput>
    /**
     * In case the Chronicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChronicleUpdateInput, ChronicleUncheckedUpdateInput>
  }

  /**
   * Chronicle delete
   */
  export type ChronicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
    /**
     * Filter which Chronicle to delete.
     */
    where: ChronicleWhereUniqueInput
  }

  /**
   * Chronicle deleteMany
   */
  export type ChronicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chronicles to delete
     */
    where?: ChronicleWhereInput
    /**
     * Limit how many Chronicles to delete.
     */
    limit?: number
  }

  /**
   * Chronicle.quests
   */
  export type Chronicle$questsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    where?: ChronicleQuestWhereInput
    orderBy?: ChronicleQuestOrderByWithRelationInput | ChronicleQuestOrderByWithRelationInput[]
    cursor?: ChronicleQuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChronicleQuestScalarFieldEnum | ChronicleQuestScalarFieldEnum[]
  }

  /**
   * Chronicle without action
   */
  export type ChronicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chronicle
     */
    select?: ChronicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chronicle
     */
    omit?: ChronicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleInclude<ExtArgs> | null
  }


  /**
   * Model Interaction
   */

  export type AggregateInteraction = {
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  export type InteractionMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    npcId: string | null
    interactionDate: Date | null
    sessionDate: Date | null
    interactionType: $Enums.InteractionType | null
    summary: string | null
    details: string | null
    attitudeChange: $Enums.NPCAttitude | null
    dmNotes: string | null
    createdAt: Date | null
  }

  export type InteractionMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    npcId: string | null
    interactionDate: Date | null
    sessionDate: Date | null
    interactionType: $Enums.InteractionType | null
    summary: string | null
    details: string | null
    attitudeChange: $Enums.NPCAttitude | null
    dmNotes: string | null
    createdAt: Date | null
  }

  export type InteractionCountAggregateOutputType = {
    id: number
    campaignId: number
    npcId: number
    interactionDate: number
    sessionDate: number
    interactionType: number
    summary: number
    details: number
    attitudeChange: number
    involvedPcs: number
    dmNotes: number
    createdAt: number
    _all: number
  }


  export type InteractionMinAggregateInputType = {
    id?: true
    campaignId?: true
    npcId?: true
    interactionDate?: true
    sessionDate?: true
    interactionType?: true
    summary?: true
    details?: true
    attitudeChange?: true
    dmNotes?: true
    createdAt?: true
  }

  export type InteractionMaxAggregateInputType = {
    id?: true
    campaignId?: true
    npcId?: true
    interactionDate?: true
    sessionDate?: true
    interactionType?: true
    summary?: true
    details?: true
    attitudeChange?: true
    dmNotes?: true
    createdAt?: true
  }

  export type InteractionCountAggregateInputType = {
    id?: true
    campaignId?: true
    npcId?: true
    interactionDate?: true
    sessionDate?: true
    interactionType?: true
    summary?: true
    details?: true
    attitudeChange?: true
    involvedPcs?: true
    dmNotes?: true
    createdAt?: true
    _all?: true
  }

  export type InteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interaction to aggregate.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interactions
    **/
    _count?: true | InteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionMaxAggregateInputType
  }

  export type GetInteractionAggregateType<T extends InteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteraction[P]>
      : GetScalarType<T[P], AggregateInteraction[P]>
  }




  export type InteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithAggregationInput | InteractionOrderByWithAggregationInput[]
    by: InteractionScalarFieldEnum[] | InteractionScalarFieldEnum
    having?: InteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionCountAggregateInputType | true
    _min?: InteractionMinAggregateInputType
    _max?: InteractionMaxAggregateInputType
  }

  export type InteractionGroupByOutputType = {
    id: string
    campaignId: string
    npcId: string
    interactionDate: Date
    sessionDate: Date
    interactionType: $Enums.InteractionType
    summary: string | null
    details: string | null
    attitudeChange: $Enums.NPCAttitude | null
    involvedPcs: JsonValue | null
    dmNotes: string | null
    createdAt: Date
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  type GetInteractionGroupByPayload<T extends InteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionGroupByOutputType[P]>
        }
      >
    >


  export type InteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    npcId?: boolean
    interactionDate?: boolean
    sessionDate?: boolean
    interactionType?: boolean
    summary?: boolean
    details?: boolean
    attitudeChange?: boolean
    involvedPcs?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    items?: boolean | Interaction$itemsArgs<ExtArgs>
    _count?: boolean | InteractionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    npcId?: boolean
    interactionDate?: boolean
    sessionDate?: boolean
    interactionType?: boolean
    summary?: boolean
    details?: boolean
    attitudeChange?: boolean
    involvedPcs?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    npcId?: boolean
    interactionDate?: boolean
    sessionDate?: boolean
    interactionType?: boolean
    summary?: boolean
    details?: boolean
    attitudeChange?: boolean
    involvedPcs?: boolean
    dmNotes?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectScalar = {
    id?: boolean
    campaignId?: boolean
    npcId?: boolean
    interactionDate?: boolean
    sessionDate?: boolean
    interactionType?: boolean
    summary?: boolean
    details?: boolean
    attitudeChange?: boolean
    involvedPcs?: boolean
    dmNotes?: boolean
    createdAt?: boolean
  }

  export type InteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "npcId" | "interactionDate" | "sessionDate" | "interactionType" | "summary" | "details" | "attitudeChange" | "involvedPcs" | "dmNotes" | "createdAt", ExtArgs["result"]["interaction"]>
  export type InteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    items?: boolean | Interaction$itemsArgs<ExtArgs>
    _count?: boolean | InteractionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }

  export type $InteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interaction"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      npc: Prisma.$NPCPayload<ExtArgs>
      items: Prisma.$InteractionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      npcId: string
      interactionDate: Date
      sessionDate: Date
      interactionType: $Enums.InteractionType
      summary: string | null
      details: string | null
      attitudeChange: $Enums.NPCAttitude | null
      involvedPcs: Prisma.JsonValue | null
      dmNotes: string | null
      createdAt: Date
    }, ExtArgs["result"]["interaction"]>
    composites: {}
  }

  type InteractionGetPayload<S extends boolean | null | undefined | InteractionDefaultArgs> = $Result.GetResult<Prisma.$InteractionPayload, S>

  type InteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractionCountAggregateInputType | true
    }

  export interface InteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interaction'], meta: { name: 'Interaction' } }
    /**
     * Find zero or one Interaction that matches the filter.
     * @param {InteractionFindUniqueArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionFindUniqueArgs>(args: SelectSubset<T, InteractionFindUniqueArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractionFindUniqueOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionFindFirstArgs>(args?: SelectSubset<T, InteractionFindFirstArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interactions
     * const interactions = await prisma.interaction.findMany()
     * 
     * // Get first 10 Interactions
     * const interactions = await prisma.interaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionWithIdOnly = await prisma.interaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionFindManyArgs>(args?: SelectSubset<T, InteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interaction.
     * @param {InteractionCreateArgs} args - Arguments to create a Interaction.
     * @example
     * // Create one Interaction
     * const Interaction = await prisma.interaction.create({
     *   data: {
     *     // ... data to create a Interaction
     *   }
     * })
     * 
     */
    create<T extends InteractionCreateArgs>(args: SelectSubset<T, InteractionCreateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interactions.
     * @param {InteractionCreateManyArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionCreateManyArgs>(args?: SelectSubset<T, InteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interactions and returns the data saved in the database.
     * @param {InteractionCreateManyAndReturnArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interaction.
     * @param {InteractionDeleteArgs} args - Arguments to delete one Interaction.
     * @example
     * // Delete one Interaction
     * const Interaction = await prisma.interaction.delete({
     *   where: {
     *     // ... filter to delete one Interaction
     *   }
     * })
     * 
     */
    delete<T extends InteractionDeleteArgs>(args: SelectSubset<T, InteractionDeleteArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interaction.
     * @param {InteractionUpdateArgs} args - Arguments to update one Interaction.
     * @example
     * // Update one Interaction
     * const interaction = await prisma.interaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionUpdateArgs>(args: SelectSubset<T, InteractionUpdateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interactions.
     * @param {InteractionDeleteManyArgs} args - Arguments to filter Interactions to delete.
     * @example
     * // Delete a few Interactions
     * const { count } = await prisma.interaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionDeleteManyArgs>(args?: SelectSubset<T, InteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionUpdateManyArgs>(args: SelectSubset<T, InteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions and returns the data updated in the database.
     * @param {InteractionUpdateManyAndReturnArgs} args - Arguments to update many Interactions.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interaction.
     * @param {InteractionUpsertArgs} args - Arguments to update or create a Interaction.
     * @example
     * // Update or create a Interaction
     * const interaction = await prisma.interaction.upsert({
     *   create: {
     *     // ... data to create a Interaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interaction we want to update
     *   }
     * })
     */
    upsert<T extends InteractionUpsertArgs>(args: SelectSubset<T, InteractionUpsertArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionCountArgs} args - Arguments to filter Interactions to count.
     * @example
     * // Count the number of Interactions
     * const count = await prisma.interaction.count({
     *   where: {
     *     // ... the filter for the Interactions we want to count
     *   }
     * })
    **/
    count<T extends InteractionCountArgs>(
      args?: Subset<T, InteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionAggregateArgs>(args: Subset<T, InteractionAggregateArgs>): Prisma.PrismaPromise<GetInteractionAggregateType<T>>

    /**
     * Group by Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionGroupByArgs['orderBy'] }
        : { orderBy?: InteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interaction model
   */
  readonly fields: InteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Interaction$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Interaction$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interaction model
   */
  interface InteractionFieldRefs {
    readonly id: FieldRef<"Interaction", 'String'>
    readonly campaignId: FieldRef<"Interaction", 'String'>
    readonly npcId: FieldRef<"Interaction", 'String'>
    readonly interactionDate: FieldRef<"Interaction", 'DateTime'>
    readonly sessionDate: FieldRef<"Interaction", 'DateTime'>
    readonly interactionType: FieldRef<"Interaction", 'InteractionType'>
    readonly summary: FieldRef<"Interaction", 'String'>
    readonly details: FieldRef<"Interaction", 'String'>
    readonly attitudeChange: FieldRef<"Interaction", 'NPCAttitude'>
    readonly involvedPcs: FieldRef<"Interaction", 'Json'>
    readonly dmNotes: FieldRef<"Interaction", 'String'>
    readonly createdAt: FieldRef<"Interaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interaction findUnique
   */
  export type InteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findUniqueOrThrow
   */
  export type InteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findFirst
   */
  export type InteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findFirstOrThrow
   */
  export type InteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findMany
   */
  export type InteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interactions to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction create
   */
  export type InteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Interaction.
     */
    data: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
  }

  /**
   * Interaction createMany
   */
  export type InteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
  }

  /**
   * Interaction createManyAndReturn
   */
  export type InteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction update
   */
  export type InteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Interaction.
     */
    data: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
    /**
     * Choose, which Interaction to update.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction updateMany
   */
  export type InteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to update.
     */
    limit?: number
  }

  /**
   * Interaction updateManyAndReturn
   */
  export type InteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction upsert
   */
  export type InteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Interaction to update in case it exists.
     */
    where: InteractionWhereUniqueInput
    /**
     * In case the Interaction found by the `where` argument doesn't exist, create a new Interaction with this data.
     */
    create: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
    /**
     * In case the Interaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
  }

  /**
   * Interaction delete
   */
  export type InteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter which Interaction to delete.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction deleteMany
   */
  export type InteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interactions to delete
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to delete.
     */
    limit?: number
  }

  /**
   * Interaction.items
   */
  export type Interaction$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    where?: InteractionItemWhereInput
    orderBy?: InteractionItemOrderByWithRelationInput | InteractionItemOrderByWithRelationInput[]
    cursor?: InteractionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionItemScalarFieldEnum | InteractionItemScalarFieldEnum[]
  }

  /**
   * Interaction without action
   */
  export type InteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
  }


  /**
   * Model MonsterCampaign
   */

  export type AggregateMonsterCampaign = {
    _count: MonsterCampaignCountAggregateOutputType | null
    _min: MonsterCampaignMinAggregateOutputType | null
    _max: MonsterCampaignMaxAggregateOutputType | null
  }

  export type MonsterCampaignMinAggregateOutputType = {
    monsterId: string | null
    campaignId: string | null
  }

  export type MonsterCampaignMaxAggregateOutputType = {
    monsterId: string | null
    campaignId: string | null
  }

  export type MonsterCampaignCountAggregateOutputType = {
    monsterId: number
    campaignId: number
    _all: number
  }


  export type MonsterCampaignMinAggregateInputType = {
    monsterId?: true
    campaignId?: true
  }

  export type MonsterCampaignMaxAggregateInputType = {
    monsterId?: true
    campaignId?: true
  }

  export type MonsterCampaignCountAggregateInputType = {
    monsterId?: true
    campaignId?: true
    _all?: true
  }

  export type MonsterCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonsterCampaign to aggregate.
     */
    where?: MonsterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonsterCampaigns to fetch.
     */
    orderBy?: MonsterCampaignOrderByWithRelationInput | MonsterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonsterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonsterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonsterCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonsterCampaigns
    **/
    _count?: true | MonsterCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonsterCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonsterCampaignMaxAggregateInputType
  }

  export type GetMonsterCampaignAggregateType<T extends MonsterCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateMonsterCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonsterCampaign[P]>
      : GetScalarType<T[P], AggregateMonsterCampaign[P]>
  }




  export type MonsterCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonsterCampaignWhereInput
    orderBy?: MonsterCampaignOrderByWithAggregationInput | MonsterCampaignOrderByWithAggregationInput[]
    by: MonsterCampaignScalarFieldEnum[] | MonsterCampaignScalarFieldEnum
    having?: MonsterCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonsterCampaignCountAggregateInputType | true
    _min?: MonsterCampaignMinAggregateInputType
    _max?: MonsterCampaignMaxAggregateInputType
  }

  export type MonsterCampaignGroupByOutputType = {
    monsterId: string
    campaignId: string
    _count: MonsterCampaignCountAggregateOutputType | null
    _min: MonsterCampaignMinAggregateOutputType | null
    _max: MonsterCampaignMaxAggregateOutputType | null
  }

  type GetMonsterCampaignGroupByPayload<T extends MonsterCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonsterCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonsterCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonsterCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], MonsterCampaignGroupByOutputType[P]>
        }
      >
    >


  export type MonsterCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    monsterId?: boolean
    campaignId?: boolean
    monster?: boolean | MonsterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monsterCampaign"]>

  export type MonsterCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    monsterId?: boolean
    campaignId?: boolean
    monster?: boolean | MonsterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monsterCampaign"]>

  export type MonsterCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    monsterId?: boolean
    campaignId?: boolean
    monster?: boolean | MonsterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monsterCampaign"]>

  export type MonsterCampaignSelectScalar = {
    monsterId?: boolean
    campaignId?: boolean
  }

  export type MonsterCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"monsterId" | "campaignId", ExtArgs["result"]["monsterCampaign"]>
  export type MonsterCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monster?: boolean | MonsterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MonsterCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monster?: boolean | MonsterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MonsterCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monster?: boolean | MonsterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $MonsterCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonsterCampaign"
    objects: {
      monster: Prisma.$MonsterPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      monsterId: string
      campaignId: string
    }, ExtArgs["result"]["monsterCampaign"]>
    composites: {}
  }

  type MonsterCampaignGetPayload<S extends boolean | null | undefined | MonsterCampaignDefaultArgs> = $Result.GetResult<Prisma.$MonsterCampaignPayload, S>

  type MonsterCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonsterCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonsterCampaignCountAggregateInputType | true
    }

  export interface MonsterCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonsterCampaign'], meta: { name: 'MonsterCampaign' } }
    /**
     * Find zero or one MonsterCampaign that matches the filter.
     * @param {MonsterCampaignFindUniqueArgs} args - Arguments to find a MonsterCampaign
     * @example
     * // Get one MonsterCampaign
     * const monsterCampaign = await prisma.monsterCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonsterCampaignFindUniqueArgs>(args: SelectSubset<T, MonsterCampaignFindUniqueArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonsterCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonsterCampaignFindUniqueOrThrowArgs} args - Arguments to find a MonsterCampaign
     * @example
     * // Get one MonsterCampaign
     * const monsterCampaign = await prisma.monsterCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonsterCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, MonsterCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonsterCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignFindFirstArgs} args - Arguments to find a MonsterCampaign
     * @example
     * // Get one MonsterCampaign
     * const monsterCampaign = await prisma.monsterCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonsterCampaignFindFirstArgs>(args?: SelectSubset<T, MonsterCampaignFindFirstArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonsterCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignFindFirstOrThrowArgs} args - Arguments to find a MonsterCampaign
     * @example
     * // Get one MonsterCampaign
     * const monsterCampaign = await prisma.monsterCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonsterCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, MonsterCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonsterCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonsterCampaigns
     * const monsterCampaigns = await prisma.monsterCampaign.findMany()
     * 
     * // Get first 10 MonsterCampaigns
     * const monsterCampaigns = await prisma.monsterCampaign.findMany({ take: 10 })
     * 
     * // Only select the `monsterId`
     * const monsterCampaignWithMonsterIdOnly = await prisma.monsterCampaign.findMany({ select: { monsterId: true } })
     * 
     */
    findMany<T extends MonsterCampaignFindManyArgs>(args?: SelectSubset<T, MonsterCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonsterCampaign.
     * @param {MonsterCampaignCreateArgs} args - Arguments to create a MonsterCampaign.
     * @example
     * // Create one MonsterCampaign
     * const MonsterCampaign = await prisma.monsterCampaign.create({
     *   data: {
     *     // ... data to create a MonsterCampaign
     *   }
     * })
     * 
     */
    create<T extends MonsterCampaignCreateArgs>(args: SelectSubset<T, MonsterCampaignCreateArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonsterCampaigns.
     * @param {MonsterCampaignCreateManyArgs} args - Arguments to create many MonsterCampaigns.
     * @example
     * // Create many MonsterCampaigns
     * const monsterCampaign = await prisma.monsterCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonsterCampaignCreateManyArgs>(args?: SelectSubset<T, MonsterCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonsterCampaigns and returns the data saved in the database.
     * @param {MonsterCampaignCreateManyAndReturnArgs} args - Arguments to create many MonsterCampaigns.
     * @example
     * // Create many MonsterCampaigns
     * const monsterCampaign = await prisma.monsterCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonsterCampaigns and only return the `monsterId`
     * const monsterCampaignWithMonsterIdOnly = await prisma.monsterCampaign.createManyAndReturn({
     *   select: { monsterId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonsterCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, MonsterCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonsterCampaign.
     * @param {MonsterCampaignDeleteArgs} args - Arguments to delete one MonsterCampaign.
     * @example
     * // Delete one MonsterCampaign
     * const MonsterCampaign = await prisma.monsterCampaign.delete({
     *   where: {
     *     // ... filter to delete one MonsterCampaign
     *   }
     * })
     * 
     */
    delete<T extends MonsterCampaignDeleteArgs>(args: SelectSubset<T, MonsterCampaignDeleteArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonsterCampaign.
     * @param {MonsterCampaignUpdateArgs} args - Arguments to update one MonsterCampaign.
     * @example
     * // Update one MonsterCampaign
     * const monsterCampaign = await prisma.monsterCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonsterCampaignUpdateArgs>(args: SelectSubset<T, MonsterCampaignUpdateArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonsterCampaigns.
     * @param {MonsterCampaignDeleteManyArgs} args - Arguments to filter MonsterCampaigns to delete.
     * @example
     * // Delete a few MonsterCampaigns
     * const { count } = await prisma.monsterCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonsterCampaignDeleteManyArgs>(args?: SelectSubset<T, MonsterCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonsterCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonsterCampaigns
     * const monsterCampaign = await prisma.monsterCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonsterCampaignUpdateManyArgs>(args: SelectSubset<T, MonsterCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonsterCampaigns and returns the data updated in the database.
     * @param {MonsterCampaignUpdateManyAndReturnArgs} args - Arguments to update many MonsterCampaigns.
     * @example
     * // Update many MonsterCampaigns
     * const monsterCampaign = await prisma.monsterCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonsterCampaigns and only return the `monsterId`
     * const monsterCampaignWithMonsterIdOnly = await prisma.monsterCampaign.updateManyAndReturn({
     *   select: { monsterId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonsterCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, MonsterCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonsterCampaign.
     * @param {MonsterCampaignUpsertArgs} args - Arguments to update or create a MonsterCampaign.
     * @example
     * // Update or create a MonsterCampaign
     * const monsterCampaign = await prisma.monsterCampaign.upsert({
     *   create: {
     *     // ... data to create a MonsterCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonsterCampaign we want to update
     *   }
     * })
     */
    upsert<T extends MonsterCampaignUpsertArgs>(args: SelectSubset<T, MonsterCampaignUpsertArgs<ExtArgs>>): Prisma__MonsterCampaignClient<$Result.GetResult<Prisma.$MonsterCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonsterCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignCountArgs} args - Arguments to filter MonsterCampaigns to count.
     * @example
     * // Count the number of MonsterCampaigns
     * const count = await prisma.monsterCampaign.count({
     *   where: {
     *     // ... the filter for the MonsterCampaigns we want to count
     *   }
     * })
    **/
    count<T extends MonsterCampaignCountArgs>(
      args?: Subset<T, MonsterCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonsterCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonsterCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonsterCampaignAggregateArgs>(args: Subset<T, MonsterCampaignAggregateArgs>): Prisma.PrismaPromise<GetMonsterCampaignAggregateType<T>>

    /**
     * Group by MonsterCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonsterCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonsterCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonsterCampaignGroupByArgs['orderBy'] }
        : { orderBy?: MonsterCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonsterCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonsterCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonsterCampaign model
   */
  readonly fields: MonsterCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonsterCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonsterCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monster<T extends MonsterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MonsterDefaultArgs<ExtArgs>>): Prisma__MonsterClient<$Result.GetResult<Prisma.$MonsterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonsterCampaign model
   */
  interface MonsterCampaignFieldRefs {
    readonly monsterId: FieldRef<"MonsterCampaign", 'String'>
    readonly campaignId: FieldRef<"MonsterCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MonsterCampaign findUnique
   */
  export type MonsterCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MonsterCampaign to fetch.
     */
    where: MonsterCampaignWhereUniqueInput
  }

  /**
   * MonsterCampaign findUniqueOrThrow
   */
  export type MonsterCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MonsterCampaign to fetch.
     */
    where: MonsterCampaignWhereUniqueInput
  }

  /**
   * MonsterCampaign findFirst
   */
  export type MonsterCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MonsterCampaign to fetch.
     */
    where?: MonsterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonsterCampaigns to fetch.
     */
    orderBy?: MonsterCampaignOrderByWithRelationInput | MonsterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonsterCampaigns.
     */
    cursor?: MonsterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonsterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonsterCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonsterCampaigns.
     */
    distinct?: MonsterCampaignScalarFieldEnum | MonsterCampaignScalarFieldEnum[]
  }

  /**
   * MonsterCampaign findFirstOrThrow
   */
  export type MonsterCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MonsterCampaign to fetch.
     */
    where?: MonsterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonsterCampaigns to fetch.
     */
    orderBy?: MonsterCampaignOrderByWithRelationInput | MonsterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonsterCampaigns.
     */
    cursor?: MonsterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonsterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonsterCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonsterCampaigns.
     */
    distinct?: MonsterCampaignScalarFieldEnum | MonsterCampaignScalarFieldEnum[]
  }

  /**
   * MonsterCampaign findMany
   */
  export type MonsterCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MonsterCampaigns to fetch.
     */
    where?: MonsterCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonsterCampaigns to fetch.
     */
    orderBy?: MonsterCampaignOrderByWithRelationInput | MonsterCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonsterCampaigns.
     */
    cursor?: MonsterCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonsterCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonsterCampaigns.
     */
    skip?: number
    distinct?: MonsterCampaignScalarFieldEnum | MonsterCampaignScalarFieldEnum[]
  }

  /**
   * MonsterCampaign create
   */
  export type MonsterCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a MonsterCampaign.
     */
    data: XOR<MonsterCampaignCreateInput, MonsterCampaignUncheckedCreateInput>
  }

  /**
   * MonsterCampaign createMany
   */
  export type MonsterCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonsterCampaigns.
     */
    data: MonsterCampaignCreateManyInput | MonsterCampaignCreateManyInput[]
  }

  /**
   * MonsterCampaign createManyAndReturn
   */
  export type MonsterCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many MonsterCampaigns.
     */
    data: MonsterCampaignCreateManyInput | MonsterCampaignCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonsterCampaign update
   */
  export type MonsterCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a MonsterCampaign.
     */
    data: XOR<MonsterCampaignUpdateInput, MonsterCampaignUncheckedUpdateInput>
    /**
     * Choose, which MonsterCampaign to update.
     */
    where: MonsterCampaignWhereUniqueInput
  }

  /**
   * MonsterCampaign updateMany
   */
  export type MonsterCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonsterCampaigns.
     */
    data: XOR<MonsterCampaignUpdateManyMutationInput, MonsterCampaignUncheckedUpdateManyInput>
    /**
     * Filter which MonsterCampaigns to update
     */
    where?: MonsterCampaignWhereInput
    /**
     * Limit how many MonsterCampaigns to update.
     */
    limit?: number
  }

  /**
   * MonsterCampaign updateManyAndReturn
   */
  export type MonsterCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * The data used to update MonsterCampaigns.
     */
    data: XOR<MonsterCampaignUpdateManyMutationInput, MonsterCampaignUncheckedUpdateManyInput>
    /**
     * Filter which MonsterCampaigns to update
     */
    where?: MonsterCampaignWhereInput
    /**
     * Limit how many MonsterCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonsterCampaign upsert
   */
  export type MonsterCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the MonsterCampaign to update in case it exists.
     */
    where: MonsterCampaignWhereUniqueInput
    /**
     * In case the MonsterCampaign found by the `where` argument doesn't exist, create a new MonsterCampaign with this data.
     */
    create: XOR<MonsterCampaignCreateInput, MonsterCampaignUncheckedCreateInput>
    /**
     * In case the MonsterCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonsterCampaignUpdateInput, MonsterCampaignUncheckedUpdateInput>
  }

  /**
   * MonsterCampaign delete
   */
  export type MonsterCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
    /**
     * Filter which MonsterCampaign to delete.
     */
    where: MonsterCampaignWhereUniqueInput
  }

  /**
   * MonsterCampaign deleteMany
   */
  export type MonsterCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonsterCampaigns to delete
     */
    where?: MonsterCampaignWhereInput
    /**
     * Limit how many MonsterCampaigns to delete.
     */
    limit?: number
  }

  /**
   * MonsterCampaign without action
   */
  export type MonsterCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonsterCampaign
     */
    select?: MonsterCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonsterCampaign
     */
    omit?: MonsterCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonsterCampaignInclude<ExtArgs> | null
  }


  /**
   * Model ItemCampaign
   */

  export type AggregateItemCampaign = {
    _count: ItemCampaignCountAggregateOutputType | null
    _min: ItemCampaignMinAggregateOutputType | null
    _max: ItemCampaignMaxAggregateOutputType | null
  }

  export type ItemCampaignMinAggregateOutputType = {
    itemId: string | null
    campaignId: string | null
  }

  export type ItemCampaignMaxAggregateOutputType = {
    itemId: string | null
    campaignId: string | null
  }

  export type ItemCampaignCountAggregateOutputType = {
    itemId: number
    campaignId: number
    _all: number
  }


  export type ItemCampaignMinAggregateInputType = {
    itemId?: true
    campaignId?: true
  }

  export type ItemCampaignMaxAggregateInputType = {
    itemId?: true
    campaignId?: true
  }

  export type ItemCampaignCountAggregateInputType = {
    itemId?: true
    campaignId?: true
    _all?: true
  }

  export type ItemCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCampaign to aggregate.
     */
    where?: ItemCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCampaigns to fetch.
     */
    orderBy?: ItemCampaignOrderByWithRelationInput | ItemCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCampaigns
    **/
    _count?: true | ItemCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCampaignMaxAggregateInputType
  }

  export type GetItemCampaignAggregateType<T extends ItemCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCampaign[P]>
      : GetScalarType<T[P], AggregateItemCampaign[P]>
  }




  export type ItemCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCampaignWhereInput
    orderBy?: ItemCampaignOrderByWithAggregationInput | ItemCampaignOrderByWithAggregationInput[]
    by: ItemCampaignScalarFieldEnum[] | ItemCampaignScalarFieldEnum
    having?: ItemCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCampaignCountAggregateInputType | true
    _min?: ItemCampaignMinAggregateInputType
    _max?: ItemCampaignMaxAggregateInputType
  }

  export type ItemCampaignGroupByOutputType = {
    itemId: string
    campaignId: string
    _count: ItemCampaignCountAggregateOutputType | null
    _min: ItemCampaignMinAggregateOutputType | null
    _max: ItemCampaignMaxAggregateOutputType | null
  }

  type GetItemCampaignGroupByPayload<T extends ItemCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCampaignGroupByOutputType[P]>
        }
      >
    >


  export type ItemCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    campaignId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCampaign"]>

  export type ItemCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    campaignId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCampaign"]>

  export type ItemCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    campaignId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCampaign"]>

  export type ItemCampaignSelectScalar = {
    itemId?: boolean
    campaignId?: boolean
  }

  export type ItemCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemId" | "campaignId", ExtArgs["result"]["itemCampaign"]>
  export type ItemCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ItemCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type ItemCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $ItemCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCampaign"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemId: string
      campaignId: string
    }, ExtArgs["result"]["itemCampaign"]>
    composites: {}
  }

  type ItemCampaignGetPayload<S extends boolean | null | undefined | ItemCampaignDefaultArgs> = $Result.GetResult<Prisma.$ItemCampaignPayload, S>

  type ItemCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCampaignCountAggregateInputType | true
    }

  export interface ItemCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCampaign'], meta: { name: 'ItemCampaign' } }
    /**
     * Find zero or one ItemCampaign that matches the filter.
     * @param {ItemCampaignFindUniqueArgs} args - Arguments to find a ItemCampaign
     * @example
     * // Get one ItemCampaign
     * const itemCampaign = await prisma.itemCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCampaignFindUniqueArgs>(args: SelectSubset<T, ItemCampaignFindUniqueArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCampaignFindUniqueOrThrowArgs} args - Arguments to find a ItemCampaign
     * @example
     * // Get one ItemCampaign
     * const itemCampaign = await prisma.itemCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignFindFirstArgs} args - Arguments to find a ItemCampaign
     * @example
     * // Get one ItemCampaign
     * const itemCampaign = await prisma.itemCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCampaignFindFirstArgs>(args?: SelectSubset<T, ItemCampaignFindFirstArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignFindFirstOrThrowArgs} args - Arguments to find a ItemCampaign
     * @example
     * // Get one ItemCampaign
     * const itemCampaign = await prisma.itemCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCampaigns
     * const itemCampaigns = await prisma.itemCampaign.findMany()
     * 
     * // Get first 10 ItemCampaigns
     * const itemCampaigns = await prisma.itemCampaign.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemCampaignWithItemIdOnly = await prisma.itemCampaign.findMany({ select: { itemId: true } })
     * 
     */
    findMany<T extends ItemCampaignFindManyArgs>(args?: SelectSubset<T, ItemCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCampaign.
     * @param {ItemCampaignCreateArgs} args - Arguments to create a ItemCampaign.
     * @example
     * // Create one ItemCampaign
     * const ItemCampaign = await prisma.itemCampaign.create({
     *   data: {
     *     // ... data to create a ItemCampaign
     *   }
     * })
     * 
     */
    create<T extends ItemCampaignCreateArgs>(args: SelectSubset<T, ItemCampaignCreateArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCampaigns.
     * @param {ItemCampaignCreateManyArgs} args - Arguments to create many ItemCampaigns.
     * @example
     * // Create many ItemCampaigns
     * const itemCampaign = await prisma.itemCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCampaignCreateManyArgs>(args?: SelectSubset<T, ItemCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCampaigns and returns the data saved in the database.
     * @param {ItemCampaignCreateManyAndReturnArgs} args - Arguments to create many ItemCampaigns.
     * @example
     * // Create many ItemCampaigns
     * const itemCampaign = await prisma.itemCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCampaigns and only return the `itemId`
     * const itemCampaignWithItemIdOnly = await prisma.itemCampaign.createManyAndReturn({
     *   select: { itemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCampaign.
     * @param {ItemCampaignDeleteArgs} args - Arguments to delete one ItemCampaign.
     * @example
     * // Delete one ItemCampaign
     * const ItemCampaign = await prisma.itemCampaign.delete({
     *   where: {
     *     // ... filter to delete one ItemCampaign
     *   }
     * })
     * 
     */
    delete<T extends ItemCampaignDeleteArgs>(args: SelectSubset<T, ItemCampaignDeleteArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCampaign.
     * @param {ItemCampaignUpdateArgs} args - Arguments to update one ItemCampaign.
     * @example
     * // Update one ItemCampaign
     * const itemCampaign = await prisma.itemCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCampaignUpdateArgs>(args: SelectSubset<T, ItemCampaignUpdateArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCampaigns.
     * @param {ItemCampaignDeleteManyArgs} args - Arguments to filter ItemCampaigns to delete.
     * @example
     * // Delete a few ItemCampaigns
     * const { count } = await prisma.itemCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCampaignDeleteManyArgs>(args?: SelectSubset<T, ItemCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCampaigns
     * const itemCampaign = await prisma.itemCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCampaignUpdateManyArgs>(args: SelectSubset<T, ItemCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCampaigns and returns the data updated in the database.
     * @param {ItemCampaignUpdateManyAndReturnArgs} args - Arguments to update many ItemCampaigns.
     * @example
     * // Update many ItemCampaigns
     * const itemCampaign = await prisma.itemCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCampaigns and only return the `itemId`
     * const itemCampaignWithItemIdOnly = await prisma.itemCampaign.updateManyAndReturn({
     *   select: { itemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCampaign.
     * @param {ItemCampaignUpsertArgs} args - Arguments to update or create a ItemCampaign.
     * @example
     * // Update or create a ItemCampaign
     * const itemCampaign = await prisma.itemCampaign.upsert({
     *   create: {
     *     // ... data to create a ItemCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCampaign we want to update
     *   }
     * })
     */
    upsert<T extends ItemCampaignUpsertArgs>(args: SelectSubset<T, ItemCampaignUpsertArgs<ExtArgs>>): Prisma__ItemCampaignClient<$Result.GetResult<Prisma.$ItemCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignCountArgs} args - Arguments to filter ItemCampaigns to count.
     * @example
     * // Count the number of ItemCampaigns
     * const count = await prisma.itemCampaign.count({
     *   where: {
     *     // ... the filter for the ItemCampaigns we want to count
     *   }
     * })
    **/
    count<T extends ItemCampaignCountArgs>(
      args?: Subset<T, ItemCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCampaignAggregateArgs>(args: Subset<T, ItemCampaignAggregateArgs>): Prisma.PrismaPromise<GetItemCampaignAggregateType<T>>

    /**
     * Group by ItemCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCampaignGroupByArgs['orderBy'] }
        : { orderBy?: ItemCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCampaign model
   */
  readonly fields: ItemCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCampaign model
   */
  interface ItemCampaignFieldRefs {
    readonly itemId: FieldRef<"ItemCampaign", 'String'>
    readonly campaignId: FieldRef<"ItemCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemCampaign findUnique
   */
  export type ItemCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ItemCampaign to fetch.
     */
    where: ItemCampaignWhereUniqueInput
  }

  /**
   * ItemCampaign findUniqueOrThrow
   */
  export type ItemCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ItemCampaign to fetch.
     */
    where: ItemCampaignWhereUniqueInput
  }

  /**
   * ItemCampaign findFirst
   */
  export type ItemCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ItemCampaign to fetch.
     */
    where?: ItemCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCampaigns to fetch.
     */
    orderBy?: ItemCampaignOrderByWithRelationInput | ItemCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCampaigns.
     */
    cursor?: ItemCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCampaigns.
     */
    distinct?: ItemCampaignScalarFieldEnum | ItemCampaignScalarFieldEnum[]
  }

  /**
   * ItemCampaign findFirstOrThrow
   */
  export type ItemCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ItemCampaign to fetch.
     */
    where?: ItemCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCampaigns to fetch.
     */
    orderBy?: ItemCampaignOrderByWithRelationInput | ItemCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCampaigns.
     */
    cursor?: ItemCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCampaigns.
     */
    distinct?: ItemCampaignScalarFieldEnum | ItemCampaignScalarFieldEnum[]
  }

  /**
   * ItemCampaign findMany
   */
  export type ItemCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ItemCampaigns to fetch.
     */
    where?: ItemCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCampaigns to fetch.
     */
    orderBy?: ItemCampaignOrderByWithRelationInput | ItemCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCampaigns.
     */
    cursor?: ItemCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCampaigns.
     */
    skip?: number
    distinct?: ItemCampaignScalarFieldEnum | ItemCampaignScalarFieldEnum[]
  }

  /**
   * ItemCampaign create
   */
  export type ItemCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCampaign.
     */
    data: XOR<ItemCampaignCreateInput, ItemCampaignUncheckedCreateInput>
  }

  /**
   * ItemCampaign createMany
   */
  export type ItemCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCampaigns.
     */
    data: ItemCampaignCreateManyInput | ItemCampaignCreateManyInput[]
  }

  /**
   * ItemCampaign createManyAndReturn
   */
  export type ItemCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCampaigns.
     */
    data: ItemCampaignCreateManyInput | ItemCampaignCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCampaign update
   */
  export type ItemCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCampaign.
     */
    data: XOR<ItemCampaignUpdateInput, ItemCampaignUncheckedUpdateInput>
    /**
     * Choose, which ItemCampaign to update.
     */
    where: ItemCampaignWhereUniqueInput
  }

  /**
   * ItemCampaign updateMany
   */
  export type ItemCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCampaigns.
     */
    data: XOR<ItemCampaignUpdateManyMutationInput, ItemCampaignUncheckedUpdateManyInput>
    /**
     * Filter which ItemCampaigns to update
     */
    where?: ItemCampaignWhereInput
    /**
     * Limit how many ItemCampaigns to update.
     */
    limit?: number
  }

  /**
   * ItemCampaign updateManyAndReturn
   */
  export type ItemCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * The data used to update ItemCampaigns.
     */
    data: XOR<ItemCampaignUpdateManyMutationInput, ItemCampaignUncheckedUpdateManyInput>
    /**
     * Filter which ItemCampaigns to update
     */
    where?: ItemCampaignWhereInput
    /**
     * Limit how many ItemCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCampaign upsert
   */
  export type ItemCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCampaign to update in case it exists.
     */
    where: ItemCampaignWhereUniqueInput
    /**
     * In case the ItemCampaign found by the `where` argument doesn't exist, create a new ItemCampaign with this data.
     */
    create: XOR<ItemCampaignCreateInput, ItemCampaignUncheckedCreateInput>
    /**
     * In case the ItemCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCampaignUpdateInput, ItemCampaignUncheckedUpdateInput>
  }

  /**
   * ItemCampaign delete
   */
  export type ItemCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
    /**
     * Filter which ItemCampaign to delete.
     */
    where: ItemCampaignWhereUniqueInput
  }

  /**
   * ItemCampaign deleteMany
   */
  export type ItemCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCampaigns to delete
     */
    where?: ItemCampaignWhereInput
    /**
     * Limit how many ItemCampaigns to delete.
     */
    limit?: number
  }

  /**
   * ItemCampaign without action
   */
  export type ItemCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCampaign
     */
    select?: ItemCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCampaign
     */
    omit?: ItemCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCampaignInclude<ExtArgs> | null
  }


  /**
   * Model NPCLocation
   */

  export type AggregateNPCLocation = {
    _count: NPCLocationCountAggregateOutputType | null
    _min: NPCLocationMinAggregateOutputType | null
    _max: NPCLocationMaxAggregateOutputType | null
  }

  export type NPCLocationMinAggregateOutputType = {
    npcId: string | null
    locationId: string | null
    isPrimary: boolean | null
  }

  export type NPCLocationMaxAggregateOutputType = {
    npcId: string | null
    locationId: string | null
    isPrimary: boolean | null
  }

  export type NPCLocationCountAggregateOutputType = {
    npcId: number
    locationId: number
    isPrimary: number
    _all: number
  }


  export type NPCLocationMinAggregateInputType = {
    npcId?: true
    locationId?: true
    isPrimary?: true
  }

  export type NPCLocationMaxAggregateInputType = {
    npcId?: true
    locationId?: true
    isPrimary?: true
  }

  export type NPCLocationCountAggregateInputType = {
    npcId?: true
    locationId?: true
    isPrimary?: true
    _all?: true
  }

  export type NPCLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCLocation to aggregate.
     */
    where?: NPCLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCLocations to fetch.
     */
    orderBy?: NPCLocationOrderByWithRelationInput | NPCLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPCLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPCLocations
    **/
    _count?: true | NPCLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPCLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPCLocationMaxAggregateInputType
  }

  export type GetNPCLocationAggregateType<T extends NPCLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateNPCLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPCLocation[P]>
      : GetScalarType<T[P], AggregateNPCLocation[P]>
  }




  export type NPCLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCLocationWhereInput
    orderBy?: NPCLocationOrderByWithAggregationInput | NPCLocationOrderByWithAggregationInput[]
    by: NPCLocationScalarFieldEnum[] | NPCLocationScalarFieldEnum
    having?: NPCLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPCLocationCountAggregateInputType | true
    _min?: NPCLocationMinAggregateInputType
    _max?: NPCLocationMaxAggregateInputType
  }

  export type NPCLocationGroupByOutputType = {
    npcId: string
    locationId: string
    isPrimary: boolean
    _count: NPCLocationCountAggregateOutputType | null
    _min: NPCLocationMinAggregateOutputType | null
    _max: NPCLocationMaxAggregateOutputType | null
  }

  type GetNPCLocationGroupByPayload<T extends NPCLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPCLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPCLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPCLocationGroupByOutputType[P]>
            : GetScalarType<T[P], NPCLocationGroupByOutputType[P]>
        }
      >
    >


  export type NPCLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    npcId?: boolean
    locationId?: boolean
    isPrimary?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPCLocation"]>

  export type NPCLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    npcId?: boolean
    locationId?: boolean
    isPrimary?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPCLocation"]>

  export type NPCLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    npcId?: boolean
    locationId?: boolean
    isPrimary?: boolean
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPCLocation"]>

  export type NPCLocationSelectScalar = {
    npcId?: boolean
    locationId?: boolean
    isPrimary?: boolean
  }

  export type NPCLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"npcId" | "locationId" | "isPrimary", ExtArgs["result"]["nPCLocation"]>
  export type NPCLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type NPCLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type NPCLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npc?: boolean | NPCDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $NPCLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPCLocation"
    objects: {
      npc: Prisma.$NPCPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      npcId: string
      locationId: string
      isPrimary: boolean
    }, ExtArgs["result"]["nPCLocation"]>
    composites: {}
  }

  type NPCLocationGetPayload<S extends boolean | null | undefined | NPCLocationDefaultArgs> = $Result.GetResult<Prisma.$NPCLocationPayload, S>

  type NPCLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NPCLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NPCLocationCountAggregateInputType | true
    }

  export interface NPCLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPCLocation'], meta: { name: 'NPCLocation' } }
    /**
     * Find zero or one NPCLocation that matches the filter.
     * @param {NPCLocationFindUniqueArgs} args - Arguments to find a NPCLocation
     * @example
     * // Get one NPCLocation
     * const nPCLocation = await prisma.nPCLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPCLocationFindUniqueArgs>(args: SelectSubset<T, NPCLocationFindUniqueArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NPCLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NPCLocationFindUniqueOrThrowArgs} args - Arguments to find a NPCLocation
     * @example
     * // Get one NPCLocation
     * const nPCLocation = await prisma.nPCLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPCLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, NPCLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPCLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationFindFirstArgs} args - Arguments to find a NPCLocation
     * @example
     * // Get one NPCLocation
     * const nPCLocation = await prisma.nPCLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPCLocationFindFirstArgs>(args?: SelectSubset<T, NPCLocationFindFirstArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NPCLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationFindFirstOrThrowArgs} args - Arguments to find a NPCLocation
     * @example
     * // Get one NPCLocation
     * const nPCLocation = await prisma.nPCLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPCLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, NPCLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NPCLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPCLocations
     * const nPCLocations = await prisma.nPCLocation.findMany()
     * 
     * // Get first 10 NPCLocations
     * const nPCLocations = await prisma.nPCLocation.findMany({ take: 10 })
     * 
     * // Only select the `npcId`
     * const nPCLocationWithNpcIdOnly = await prisma.nPCLocation.findMany({ select: { npcId: true } })
     * 
     */
    findMany<T extends NPCLocationFindManyArgs>(args?: SelectSubset<T, NPCLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NPCLocation.
     * @param {NPCLocationCreateArgs} args - Arguments to create a NPCLocation.
     * @example
     * // Create one NPCLocation
     * const NPCLocation = await prisma.nPCLocation.create({
     *   data: {
     *     // ... data to create a NPCLocation
     *   }
     * })
     * 
     */
    create<T extends NPCLocationCreateArgs>(args: SelectSubset<T, NPCLocationCreateArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NPCLocations.
     * @param {NPCLocationCreateManyArgs} args - Arguments to create many NPCLocations.
     * @example
     * // Create many NPCLocations
     * const nPCLocation = await prisma.nPCLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPCLocationCreateManyArgs>(args?: SelectSubset<T, NPCLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPCLocations and returns the data saved in the database.
     * @param {NPCLocationCreateManyAndReturnArgs} args - Arguments to create many NPCLocations.
     * @example
     * // Create many NPCLocations
     * const nPCLocation = await prisma.nPCLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPCLocations and only return the `npcId`
     * const nPCLocationWithNpcIdOnly = await prisma.nPCLocation.createManyAndReturn({
     *   select: { npcId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPCLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, NPCLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NPCLocation.
     * @param {NPCLocationDeleteArgs} args - Arguments to delete one NPCLocation.
     * @example
     * // Delete one NPCLocation
     * const NPCLocation = await prisma.nPCLocation.delete({
     *   where: {
     *     // ... filter to delete one NPCLocation
     *   }
     * })
     * 
     */
    delete<T extends NPCLocationDeleteArgs>(args: SelectSubset<T, NPCLocationDeleteArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NPCLocation.
     * @param {NPCLocationUpdateArgs} args - Arguments to update one NPCLocation.
     * @example
     * // Update one NPCLocation
     * const nPCLocation = await prisma.nPCLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPCLocationUpdateArgs>(args: SelectSubset<T, NPCLocationUpdateArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NPCLocations.
     * @param {NPCLocationDeleteManyArgs} args - Arguments to filter NPCLocations to delete.
     * @example
     * // Delete a few NPCLocations
     * const { count } = await prisma.nPCLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPCLocationDeleteManyArgs>(args?: SelectSubset<T, NPCLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPCLocations
     * const nPCLocation = await prisma.nPCLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPCLocationUpdateManyArgs>(args: SelectSubset<T, NPCLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCLocations and returns the data updated in the database.
     * @param {NPCLocationUpdateManyAndReturnArgs} args - Arguments to update many NPCLocations.
     * @example
     * // Update many NPCLocations
     * const nPCLocation = await prisma.nPCLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NPCLocations and only return the `npcId`
     * const nPCLocationWithNpcIdOnly = await prisma.nPCLocation.updateManyAndReturn({
     *   select: { npcId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NPCLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, NPCLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NPCLocation.
     * @param {NPCLocationUpsertArgs} args - Arguments to update or create a NPCLocation.
     * @example
     * // Update or create a NPCLocation
     * const nPCLocation = await prisma.nPCLocation.upsert({
     *   create: {
     *     // ... data to create a NPCLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPCLocation we want to update
     *   }
     * })
     */
    upsert<T extends NPCLocationUpsertArgs>(args: SelectSubset<T, NPCLocationUpsertArgs<ExtArgs>>): Prisma__NPCLocationClient<$Result.GetResult<Prisma.$NPCLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NPCLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationCountArgs} args - Arguments to filter NPCLocations to count.
     * @example
     * // Count the number of NPCLocations
     * const count = await prisma.nPCLocation.count({
     *   where: {
     *     // ... the filter for the NPCLocations we want to count
     *   }
     * })
    **/
    count<T extends NPCLocationCountArgs>(
      args?: Subset<T, NPCLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPCLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPCLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPCLocationAggregateArgs>(args: Subset<T, NPCLocationAggregateArgs>): Prisma.PrismaPromise<GetNPCLocationAggregateType<T>>

    /**
     * Group by NPCLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPCLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPCLocationGroupByArgs['orderBy'] }
        : { orderBy?: NPCLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPCLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPCLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPCLocation model
   */
  readonly fields: NPCLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPCLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPCLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPCLocation model
   */
  interface NPCLocationFieldRefs {
    readonly npcId: FieldRef<"NPCLocation", 'String'>
    readonly locationId: FieldRef<"NPCLocation", 'String'>
    readonly isPrimary: FieldRef<"NPCLocation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NPCLocation findUnique
   */
  export type NPCLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * Filter, which NPCLocation to fetch.
     */
    where: NPCLocationWhereUniqueInput
  }

  /**
   * NPCLocation findUniqueOrThrow
   */
  export type NPCLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * Filter, which NPCLocation to fetch.
     */
    where: NPCLocationWhereUniqueInput
  }

  /**
   * NPCLocation findFirst
   */
  export type NPCLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * Filter, which NPCLocation to fetch.
     */
    where?: NPCLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCLocations to fetch.
     */
    orderBy?: NPCLocationOrderByWithRelationInput | NPCLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCLocations.
     */
    cursor?: NPCLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCLocations.
     */
    distinct?: NPCLocationScalarFieldEnum | NPCLocationScalarFieldEnum[]
  }

  /**
   * NPCLocation findFirstOrThrow
   */
  export type NPCLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * Filter, which NPCLocation to fetch.
     */
    where?: NPCLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCLocations to fetch.
     */
    orderBy?: NPCLocationOrderByWithRelationInput | NPCLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCLocations.
     */
    cursor?: NPCLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCLocations.
     */
    distinct?: NPCLocationScalarFieldEnum | NPCLocationScalarFieldEnum[]
  }

  /**
   * NPCLocation findMany
   */
  export type NPCLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * Filter, which NPCLocations to fetch.
     */
    where?: NPCLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCLocations to fetch.
     */
    orderBy?: NPCLocationOrderByWithRelationInput | NPCLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPCLocations.
     */
    cursor?: NPCLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCLocations.
     */
    skip?: number
    distinct?: NPCLocationScalarFieldEnum | NPCLocationScalarFieldEnum[]
  }

  /**
   * NPCLocation create
   */
  export type NPCLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a NPCLocation.
     */
    data: XOR<NPCLocationCreateInput, NPCLocationUncheckedCreateInput>
  }

  /**
   * NPCLocation createMany
   */
  export type NPCLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPCLocations.
     */
    data: NPCLocationCreateManyInput | NPCLocationCreateManyInput[]
  }

  /**
   * NPCLocation createManyAndReturn
   */
  export type NPCLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * The data used to create many NPCLocations.
     */
    data: NPCLocationCreateManyInput | NPCLocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPCLocation update
   */
  export type NPCLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a NPCLocation.
     */
    data: XOR<NPCLocationUpdateInput, NPCLocationUncheckedUpdateInput>
    /**
     * Choose, which NPCLocation to update.
     */
    where: NPCLocationWhereUniqueInput
  }

  /**
   * NPCLocation updateMany
   */
  export type NPCLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPCLocations.
     */
    data: XOR<NPCLocationUpdateManyMutationInput, NPCLocationUncheckedUpdateManyInput>
    /**
     * Filter which NPCLocations to update
     */
    where?: NPCLocationWhereInput
    /**
     * Limit how many NPCLocations to update.
     */
    limit?: number
  }

  /**
   * NPCLocation updateManyAndReturn
   */
  export type NPCLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * The data used to update NPCLocations.
     */
    data: XOR<NPCLocationUpdateManyMutationInput, NPCLocationUncheckedUpdateManyInput>
    /**
     * Filter which NPCLocations to update
     */
    where?: NPCLocationWhereInput
    /**
     * Limit how many NPCLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPCLocation upsert
   */
  export type NPCLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the NPCLocation to update in case it exists.
     */
    where: NPCLocationWhereUniqueInput
    /**
     * In case the NPCLocation found by the `where` argument doesn't exist, create a new NPCLocation with this data.
     */
    create: XOR<NPCLocationCreateInput, NPCLocationUncheckedCreateInput>
    /**
     * In case the NPCLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPCLocationUpdateInput, NPCLocationUncheckedUpdateInput>
  }

  /**
   * NPCLocation delete
   */
  export type NPCLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
    /**
     * Filter which NPCLocation to delete.
     */
    where: NPCLocationWhereUniqueInput
  }

  /**
   * NPCLocation deleteMany
   */
  export type NPCLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCLocations to delete
     */
    where?: NPCLocationWhereInput
    /**
     * Limit how many NPCLocations to delete.
     */
    limit?: number
  }

  /**
   * NPCLocation without action
   */
  export type NPCLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCLocation
     */
    select?: NPCLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NPCLocation
     */
    omit?: NPCLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCLocationInclude<ExtArgs> | null
  }


  /**
   * Model QuestNPC
   */

  export type AggregateQuestNPC = {
    _count: QuestNPCCountAggregateOutputType | null
    _min: QuestNPCMinAggregateOutputType | null
    _max: QuestNPCMaxAggregateOutputType | null
  }

  export type QuestNPCMinAggregateOutputType = {
    questId: string | null
    npcId: string | null
    role: string | null
  }

  export type QuestNPCMaxAggregateOutputType = {
    questId: string | null
    npcId: string | null
    role: string | null
  }

  export type QuestNPCCountAggregateOutputType = {
    questId: number
    npcId: number
    role: number
    _all: number
  }


  export type QuestNPCMinAggregateInputType = {
    questId?: true
    npcId?: true
    role?: true
  }

  export type QuestNPCMaxAggregateInputType = {
    questId?: true
    npcId?: true
    role?: true
  }

  export type QuestNPCCountAggregateInputType = {
    questId?: true
    npcId?: true
    role?: true
    _all?: true
  }

  export type QuestNPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestNPC to aggregate.
     */
    where?: QuestNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestNPCS to fetch.
     */
    orderBy?: QuestNPCOrderByWithRelationInput | QuestNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestNPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestNPCS
    **/
    _count?: true | QuestNPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestNPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestNPCMaxAggregateInputType
  }

  export type GetQuestNPCAggregateType<T extends QuestNPCAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestNPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestNPC[P]>
      : GetScalarType<T[P], AggregateQuestNPC[P]>
  }




  export type QuestNPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestNPCWhereInput
    orderBy?: QuestNPCOrderByWithAggregationInput | QuestNPCOrderByWithAggregationInput[]
    by: QuestNPCScalarFieldEnum[] | QuestNPCScalarFieldEnum
    having?: QuestNPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestNPCCountAggregateInputType | true
    _min?: QuestNPCMinAggregateInputType
    _max?: QuestNPCMaxAggregateInputType
  }

  export type QuestNPCGroupByOutputType = {
    questId: string
    npcId: string
    role: string | null
    _count: QuestNPCCountAggregateOutputType | null
    _min: QuestNPCMinAggregateOutputType | null
    _max: QuestNPCMaxAggregateOutputType | null
  }

  type GetQuestNPCGroupByPayload<T extends QuestNPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestNPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestNPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestNPCGroupByOutputType[P]>
            : GetScalarType<T[P], QuestNPCGroupByOutputType[P]>
        }
      >
    >


  export type QuestNPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questId?: boolean
    npcId?: boolean
    role?: boolean
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questNPC"]>

  export type QuestNPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questId?: boolean
    npcId?: boolean
    role?: boolean
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questNPC"]>

  export type QuestNPCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questId?: boolean
    npcId?: boolean
    role?: boolean
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questNPC"]>

  export type QuestNPCSelectScalar = {
    questId?: boolean
    npcId?: boolean
    role?: boolean
  }

  export type QuestNPCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"questId" | "npcId" | "role", ExtArgs["result"]["questNPC"]>
  export type QuestNPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type QuestNPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type QuestNPCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }

  export type $QuestNPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestNPC"
    objects: {
      quest: Prisma.$QuestPayload<ExtArgs>
      npc: Prisma.$NPCPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      questId: string
      npcId: string
      role: string | null
    }, ExtArgs["result"]["questNPC"]>
    composites: {}
  }

  type QuestNPCGetPayload<S extends boolean | null | undefined | QuestNPCDefaultArgs> = $Result.GetResult<Prisma.$QuestNPCPayload, S>

  type QuestNPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestNPCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestNPCCountAggregateInputType | true
    }

  export interface QuestNPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestNPC'], meta: { name: 'QuestNPC' } }
    /**
     * Find zero or one QuestNPC that matches the filter.
     * @param {QuestNPCFindUniqueArgs} args - Arguments to find a QuestNPC
     * @example
     * // Get one QuestNPC
     * const questNPC = await prisma.questNPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestNPCFindUniqueArgs>(args: SelectSubset<T, QuestNPCFindUniqueArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestNPC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestNPCFindUniqueOrThrowArgs} args - Arguments to find a QuestNPC
     * @example
     * // Get one QuestNPC
     * const questNPC = await prisma.questNPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestNPCFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestNPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestNPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCFindFirstArgs} args - Arguments to find a QuestNPC
     * @example
     * // Get one QuestNPC
     * const questNPC = await prisma.questNPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestNPCFindFirstArgs>(args?: SelectSubset<T, QuestNPCFindFirstArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestNPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCFindFirstOrThrowArgs} args - Arguments to find a QuestNPC
     * @example
     * // Get one QuestNPC
     * const questNPC = await prisma.questNPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestNPCFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestNPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestNPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestNPCS
     * const questNPCS = await prisma.questNPC.findMany()
     * 
     * // Get first 10 QuestNPCS
     * const questNPCS = await prisma.questNPC.findMany({ take: 10 })
     * 
     * // Only select the `questId`
     * const questNPCWithQuestIdOnly = await prisma.questNPC.findMany({ select: { questId: true } })
     * 
     */
    findMany<T extends QuestNPCFindManyArgs>(args?: SelectSubset<T, QuestNPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestNPC.
     * @param {QuestNPCCreateArgs} args - Arguments to create a QuestNPC.
     * @example
     * // Create one QuestNPC
     * const QuestNPC = await prisma.questNPC.create({
     *   data: {
     *     // ... data to create a QuestNPC
     *   }
     * })
     * 
     */
    create<T extends QuestNPCCreateArgs>(args: SelectSubset<T, QuestNPCCreateArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestNPCS.
     * @param {QuestNPCCreateManyArgs} args - Arguments to create many QuestNPCS.
     * @example
     * // Create many QuestNPCS
     * const questNPC = await prisma.questNPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestNPCCreateManyArgs>(args?: SelectSubset<T, QuestNPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestNPCS and returns the data saved in the database.
     * @param {QuestNPCCreateManyAndReturnArgs} args - Arguments to create many QuestNPCS.
     * @example
     * // Create many QuestNPCS
     * const questNPC = await prisma.questNPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestNPCS and only return the `questId`
     * const questNPCWithQuestIdOnly = await prisma.questNPC.createManyAndReturn({
     *   select: { questId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestNPCCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestNPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestNPC.
     * @param {QuestNPCDeleteArgs} args - Arguments to delete one QuestNPC.
     * @example
     * // Delete one QuestNPC
     * const QuestNPC = await prisma.questNPC.delete({
     *   where: {
     *     // ... filter to delete one QuestNPC
     *   }
     * })
     * 
     */
    delete<T extends QuestNPCDeleteArgs>(args: SelectSubset<T, QuestNPCDeleteArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestNPC.
     * @param {QuestNPCUpdateArgs} args - Arguments to update one QuestNPC.
     * @example
     * // Update one QuestNPC
     * const questNPC = await prisma.questNPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestNPCUpdateArgs>(args: SelectSubset<T, QuestNPCUpdateArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestNPCS.
     * @param {QuestNPCDeleteManyArgs} args - Arguments to filter QuestNPCS to delete.
     * @example
     * // Delete a few QuestNPCS
     * const { count } = await prisma.questNPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestNPCDeleteManyArgs>(args?: SelectSubset<T, QuestNPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestNPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestNPCS
     * const questNPC = await prisma.questNPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestNPCUpdateManyArgs>(args: SelectSubset<T, QuestNPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestNPCS and returns the data updated in the database.
     * @param {QuestNPCUpdateManyAndReturnArgs} args - Arguments to update many QuestNPCS.
     * @example
     * // Update many QuestNPCS
     * const questNPC = await prisma.questNPC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestNPCS and only return the `questId`
     * const questNPCWithQuestIdOnly = await prisma.questNPC.updateManyAndReturn({
     *   select: { questId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestNPCUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestNPCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestNPC.
     * @param {QuestNPCUpsertArgs} args - Arguments to update or create a QuestNPC.
     * @example
     * // Update or create a QuestNPC
     * const questNPC = await prisma.questNPC.upsert({
     *   create: {
     *     // ... data to create a QuestNPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestNPC we want to update
     *   }
     * })
     */
    upsert<T extends QuestNPCUpsertArgs>(args: SelectSubset<T, QuestNPCUpsertArgs<ExtArgs>>): Prisma__QuestNPCClient<$Result.GetResult<Prisma.$QuestNPCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestNPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCCountArgs} args - Arguments to filter QuestNPCS to count.
     * @example
     * // Count the number of QuestNPCS
     * const count = await prisma.questNPC.count({
     *   where: {
     *     // ... the filter for the QuestNPCS we want to count
     *   }
     * })
    **/
    count<T extends QuestNPCCountArgs>(
      args?: Subset<T, QuestNPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestNPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestNPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestNPCAggregateArgs>(args: Subset<T, QuestNPCAggregateArgs>): Prisma.PrismaPromise<GetQuestNPCAggregateType<T>>

    /**
     * Group by QuestNPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestNPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestNPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestNPCGroupByArgs['orderBy'] }
        : { orderBy?: QuestNPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestNPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestNPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestNPC model
   */
  readonly fields: QuestNPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestNPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestNPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quest<T extends QuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestDefaultArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestNPC model
   */
  interface QuestNPCFieldRefs {
    readonly questId: FieldRef<"QuestNPC", 'String'>
    readonly npcId: FieldRef<"QuestNPC", 'String'>
    readonly role: FieldRef<"QuestNPC", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuestNPC findUnique
   */
  export type QuestNPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * Filter, which QuestNPC to fetch.
     */
    where: QuestNPCWhereUniqueInput
  }

  /**
   * QuestNPC findUniqueOrThrow
   */
  export type QuestNPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * Filter, which QuestNPC to fetch.
     */
    where: QuestNPCWhereUniqueInput
  }

  /**
   * QuestNPC findFirst
   */
  export type QuestNPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * Filter, which QuestNPC to fetch.
     */
    where?: QuestNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestNPCS to fetch.
     */
    orderBy?: QuestNPCOrderByWithRelationInput | QuestNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestNPCS.
     */
    cursor?: QuestNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestNPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestNPCS.
     */
    distinct?: QuestNPCScalarFieldEnum | QuestNPCScalarFieldEnum[]
  }

  /**
   * QuestNPC findFirstOrThrow
   */
  export type QuestNPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * Filter, which QuestNPC to fetch.
     */
    where?: QuestNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestNPCS to fetch.
     */
    orderBy?: QuestNPCOrderByWithRelationInput | QuestNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestNPCS.
     */
    cursor?: QuestNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestNPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestNPCS.
     */
    distinct?: QuestNPCScalarFieldEnum | QuestNPCScalarFieldEnum[]
  }

  /**
   * QuestNPC findMany
   */
  export type QuestNPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * Filter, which QuestNPCS to fetch.
     */
    where?: QuestNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestNPCS to fetch.
     */
    orderBy?: QuestNPCOrderByWithRelationInput | QuestNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestNPCS.
     */
    cursor?: QuestNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestNPCS.
     */
    skip?: number
    distinct?: QuestNPCScalarFieldEnum | QuestNPCScalarFieldEnum[]
  }

  /**
   * QuestNPC create
   */
  export type QuestNPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestNPC.
     */
    data: XOR<QuestNPCCreateInput, QuestNPCUncheckedCreateInput>
  }

  /**
   * QuestNPC createMany
   */
  export type QuestNPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestNPCS.
     */
    data: QuestNPCCreateManyInput | QuestNPCCreateManyInput[]
  }

  /**
   * QuestNPC createManyAndReturn
   */
  export type QuestNPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * The data used to create many QuestNPCS.
     */
    data: QuestNPCCreateManyInput | QuestNPCCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestNPC update
   */
  export type QuestNPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestNPC.
     */
    data: XOR<QuestNPCUpdateInput, QuestNPCUncheckedUpdateInput>
    /**
     * Choose, which QuestNPC to update.
     */
    where: QuestNPCWhereUniqueInput
  }

  /**
   * QuestNPC updateMany
   */
  export type QuestNPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestNPCS.
     */
    data: XOR<QuestNPCUpdateManyMutationInput, QuestNPCUncheckedUpdateManyInput>
    /**
     * Filter which QuestNPCS to update
     */
    where?: QuestNPCWhereInput
    /**
     * Limit how many QuestNPCS to update.
     */
    limit?: number
  }

  /**
   * QuestNPC updateManyAndReturn
   */
  export type QuestNPCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * The data used to update QuestNPCS.
     */
    data: XOR<QuestNPCUpdateManyMutationInput, QuestNPCUncheckedUpdateManyInput>
    /**
     * Filter which QuestNPCS to update
     */
    where?: QuestNPCWhereInput
    /**
     * Limit how many QuestNPCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestNPC upsert
   */
  export type QuestNPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestNPC to update in case it exists.
     */
    where: QuestNPCWhereUniqueInput
    /**
     * In case the QuestNPC found by the `where` argument doesn't exist, create a new QuestNPC with this data.
     */
    create: XOR<QuestNPCCreateInput, QuestNPCUncheckedCreateInput>
    /**
     * In case the QuestNPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestNPCUpdateInput, QuestNPCUncheckedUpdateInput>
  }

  /**
   * QuestNPC delete
   */
  export type QuestNPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
    /**
     * Filter which QuestNPC to delete.
     */
    where: QuestNPCWhereUniqueInput
  }

  /**
   * QuestNPC deleteMany
   */
  export type QuestNPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestNPCS to delete
     */
    where?: QuestNPCWhereInput
    /**
     * Limit how many QuestNPCS to delete.
     */
    limit?: number
  }

  /**
   * QuestNPC without action
   */
  export type QuestNPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestNPC
     */
    select?: QuestNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestNPC
     */
    omit?: QuestNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestNPCInclude<ExtArgs> | null
  }


  /**
   * Model QuestLocation
   */

  export type AggregateQuestLocation = {
    _count: QuestLocationCountAggregateOutputType | null
    _min: QuestLocationMinAggregateOutputType | null
    _max: QuestLocationMaxAggregateOutputType | null
  }

  export type QuestLocationMinAggregateOutputType = {
    questId: string | null
    locationId: string | null
  }

  export type QuestLocationMaxAggregateOutputType = {
    questId: string | null
    locationId: string | null
  }

  export type QuestLocationCountAggregateOutputType = {
    questId: number
    locationId: number
    _all: number
  }


  export type QuestLocationMinAggregateInputType = {
    questId?: true
    locationId?: true
  }

  export type QuestLocationMaxAggregateInputType = {
    questId?: true
    locationId?: true
  }

  export type QuestLocationCountAggregateInputType = {
    questId?: true
    locationId?: true
    _all?: true
  }

  export type QuestLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestLocation to aggregate.
     */
    where?: QuestLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestLocations to fetch.
     */
    orderBy?: QuestLocationOrderByWithRelationInput | QuestLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestLocations
    **/
    _count?: true | QuestLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestLocationMaxAggregateInputType
  }

  export type GetQuestLocationAggregateType<T extends QuestLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestLocation[P]>
      : GetScalarType<T[P], AggregateQuestLocation[P]>
  }




  export type QuestLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestLocationWhereInput
    orderBy?: QuestLocationOrderByWithAggregationInput | QuestLocationOrderByWithAggregationInput[]
    by: QuestLocationScalarFieldEnum[] | QuestLocationScalarFieldEnum
    having?: QuestLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestLocationCountAggregateInputType | true
    _min?: QuestLocationMinAggregateInputType
    _max?: QuestLocationMaxAggregateInputType
  }

  export type QuestLocationGroupByOutputType = {
    questId: string
    locationId: string
    _count: QuestLocationCountAggregateOutputType | null
    _min: QuestLocationMinAggregateOutputType | null
    _max: QuestLocationMaxAggregateOutputType | null
  }

  type GetQuestLocationGroupByPayload<T extends QuestLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestLocationGroupByOutputType[P]>
            : GetScalarType<T[P], QuestLocationGroupByOutputType[P]>
        }
      >
    >


  export type QuestLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questId?: boolean
    locationId?: boolean
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questLocation"]>

  export type QuestLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questId?: boolean
    locationId?: boolean
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questLocation"]>

  export type QuestLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questId?: boolean
    locationId?: boolean
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questLocation"]>

  export type QuestLocationSelectScalar = {
    questId?: boolean
    locationId?: boolean
  }

  export type QuestLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"questId" | "locationId", ExtArgs["result"]["questLocation"]>
  export type QuestLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type QuestLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type QuestLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quest?: boolean | QuestDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $QuestLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestLocation"
    objects: {
      quest: Prisma.$QuestPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      questId: string
      locationId: string
    }, ExtArgs["result"]["questLocation"]>
    composites: {}
  }

  type QuestLocationGetPayload<S extends boolean | null | undefined | QuestLocationDefaultArgs> = $Result.GetResult<Prisma.$QuestLocationPayload, S>

  type QuestLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestLocationCountAggregateInputType | true
    }

  export interface QuestLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestLocation'], meta: { name: 'QuestLocation' } }
    /**
     * Find zero or one QuestLocation that matches the filter.
     * @param {QuestLocationFindUniqueArgs} args - Arguments to find a QuestLocation
     * @example
     * // Get one QuestLocation
     * const questLocation = await prisma.questLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestLocationFindUniqueArgs>(args: SelectSubset<T, QuestLocationFindUniqueArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestLocationFindUniqueOrThrowArgs} args - Arguments to find a QuestLocation
     * @example
     * // Get one QuestLocation
     * const questLocation = await prisma.questLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationFindFirstArgs} args - Arguments to find a QuestLocation
     * @example
     * // Get one QuestLocation
     * const questLocation = await prisma.questLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestLocationFindFirstArgs>(args?: SelectSubset<T, QuestLocationFindFirstArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationFindFirstOrThrowArgs} args - Arguments to find a QuestLocation
     * @example
     * // Get one QuestLocation
     * const questLocation = await prisma.questLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestLocations
     * const questLocations = await prisma.questLocation.findMany()
     * 
     * // Get first 10 QuestLocations
     * const questLocations = await prisma.questLocation.findMany({ take: 10 })
     * 
     * // Only select the `questId`
     * const questLocationWithQuestIdOnly = await prisma.questLocation.findMany({ select: { questId: true } })
     * 
     */
    findMany<T extends QuestLocationFindManyArgs>(args?: SelectSubset<T, QuestLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestLocation.
     * @param {QuestLocationCreateArgs} args - Arguments to create a QuestLocation.
     * @example
     * // Create one QuestLocation
     * const QuestLocation = await prisma.questLocation.create({
     *   data: {
     *     // ... data to create a QuestLocation
     *   }
     * })
     * 
     */
    create<T extends QuestLocationCreateArgs>(args: SelectSubset<T, QuestLocationCreateArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestLocations.
     * @param {QuestLocationCreateManyArgs} args - Arguments to create many QuestLocations.
     * @example
     * // Create many QuestLocations
     * const questLocation = await prisma.questLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestLocationCreateManyArgs>(args?: SelectSubset<T, QuestLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestLocations and returns the data saved in the database.
     * @param {QuestLocationCreateManyAndReturnArgs} args - Arguments to create many QuestLocations.
     * @example
     * // Create many QuestLocations
     * const questLocation = await prisma.questLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestLocations and only return the `questId`
     * const questLocationWithQuestIdOnly = await prisma.questLocation.createManyAndReturn({
     *   select: { questId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestLocation.
     * @param {QuestLocationDeleteArgs} args - Arguments to delete one QuestLocation.
     * @example
     * // Delete one QuestLocation
     * const QuestLocation = await prisma.questLocation.delete({
     *   where: {
     *     // ... filter to delete one QuestLocation
     *   }
     * })
     * 
     */
    delete<T extends QuestLocationDeleteArgs>(args: SelectSubset<T, QuestLocationDeleteArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestLocation.
     * @param {QuestLocationUpdateArgs} args - Arguments to update one QuestLocation.
     * @example
     * // Update one QuestLocation
     * const questLocation = await prisma.questLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestLocationUpdateArgs>(args: SelectSubset<T, QuestLocationUpdateArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestLocations.
     * @param {QuestLocationDeleteManyArgs} args - Arguments to filter QuestLocations to delete.
     * @example
     * // Delete a few QuestLocations
     * const { count } = await prisma.questLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestLocationDeleteManyArgs>(args?: SelectSubset<T, QuestLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestLocations
     * const questLocation = await prisma.questLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestLocationUpdateManyArgs>(args: SelectSubset<T, QuestLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestLocations and returns the data updated in the database.
     * @param {QuestLocationUpdateManyAndReturnArgs} args - Arguments to update many QuestLocations.
     * @example
     * // Update many QuestLocations
     * const questLocation = await prisma.questLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestLocations and only return the `questId`
     * const questLocationWithQuestIdOnly = await prisma.questLocation.updateManyAndReturn({
     *   select: { questId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestLocation.
     * @param {QuestLocationUpsertArgs} args - Arguments to update or create a QuestLocation.
     * @example
     * // Update or create a QuestLocation
     * const questLocation = await prisma.questLocation.upsert({
     *   create: {
     *     // ... data to create a QuestLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestLocation we want to update
     *   }
     * })
     */
    upsert<T extends QuestLocationUpsertArgs>(args: SelectSubset<T, QuestLocationUpsertArgs<ExtArgs>>): Prisma__QuestLocationClient<$Result.GetResult<Prisma.$QuestLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationCountArgs} args - Arguments to filter QuestLocations to count.
     * @example
     * // Count the number of QuestLocations
     * const count = await prisma.questLocation.count({
     *   where: {
     *     // ... the filter for the QuestLocations we want to count
     *   }
     * })
    **/
    count<T extends QuestLocationCountArgs>(
      args?: Subset<T, QuestLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestLocationAggregateArgs>(args: Subset<T, QuestLocationAggregateArgs>): Prisma.PrismaPromise<GetQuestLocationAggregateType<T>>

    /**
     * Group by QuestLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestLocationGroupByArgs['orderBy'] }
        : { orderBy?: QuestLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestLocation model
   */
  readonly fields: QuestLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quest<T extends QuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestDefaultArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestLocation model
   */
  interface QuestLocationFieldRefs {
    readonly questId: FieldRef<"QuestLocation", 'String'>
    readonly locationId: FieldRef<"QuestLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuestLocation findUnique
   */
  export type QuestLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * Filter, which QuestLocation to fetch.
     */
    where: QuestLocationWhereUniqueInput
  }

  /**
   * QuestLocation findUniqueOrThrow
   */
  export type QuestLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * Filter, which QuestLocation to fetch.
     */
    where: QuestLocationWhereUniqueInput
  }

  /**
   * QuestLocation findFirst
   */
  export type QuestLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * Filter, which QuestLocation to fetch.
     */
    where?: QuestLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestLocations to fetch.
     */
    orderBy?: QuestLocationOrderByWithRelationInput | QuestLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestLocations.
     */
    cursor?: QuestLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestLocations.
     */
    distinct?: QuestLocationScalarFieldEnum | QuestLocationScalarFieldEnum[]
  }

  /**
   * QuestLocation findFirstOrThrow
   */
  export type QuestLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * Filter, which QuestLocation to fetch.
     */
    where?: QuestLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestLocations to fetch.
     */
    orderBy?: QuestLocationOrderByWithRelationInput | QuestLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestLocations.
     */
    cursor?: QuestLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestLocations.
     */
    distinct?: QuestLocationScalarFieldEnum | QuestLocationScalarFieldEnum[]
  }

  /**
   * QuestLocation findMany
   */
  export type QuestLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * Filter, which QuestLocations to fetch.
     */
    where?: QuestLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestLocations to fetch.
     */
    orderBy?: QuestLocationOrderByWithRelationInput | QuestLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestLocations.
     */
    cursor?: QuestLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestLocations.
     */
    skip?: number
    distinct?: QuestLocationScalarFieldEnum | QuestLocationScalarFieldEnum[]
  }

  /**
   * QuestLocation create
   */
  export type QuestLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestLocation.
     */
    data: XOR<QuestLocationCreateInput, QuestLocationUncheckedCreateInput>
  }

  /**
   * QuestLocation createMany
   */
  export type QuestLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestLocations.
     */
    data: QuestLocationCreateManyInput | QuestLocationCreateManyInput[]
  }

  /**
   * QuestLocation createManyAndReturn
   */
  export type QuestLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * The data used to create many QuestLocations.
     */
    data: QuestLocationCreateManyInput | QuestLocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestLocation update
   */
  export type QuestLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestLocation.
     */
    data: XOR<QuestLocationUpdateInput, QuestLocationUncheckedUpdateInput>
    /**
     * Choose, which QuestLocation to update.
     */
    where: QuestLocationWhereUniqueInput
  }

  /**
   * QuestLocation updateMany
   */
  export type QuestLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestLocations.
     */
    data: XOR<QuestLocationUpdateManyMutationInput, QuestLocationUncheckedUpdateManyInput>
    /**
     * Filter which QuestLocations to update
     */
    where?: QuestLocationWhereInput
    /**
     * Limit how many QuestLocations to update.
     */
    limit?: number
  }

  /**
   * QuestLocation updateManyAndReturn
   */
  export type QuestLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * The data used to update QuestLocations.
     */
    data: XOR<QuestLocationUpdateManyMutationInput, QuestLocationUncheckedUpdateManyInput>
    /**
     * Filter which QuestLocations to update
     */
    where?: QuestLocationWhereInput
    /**
     * Limit how many QuestLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestLocation upsert
   */
  export type QuestLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestLocation to update in case it exists.
     */
    where: QuestLocationWhereUniqueInput
    /**
     * In case the QuestLocation found by the `where` argument doesn't exist, create a new QuestLocation with this data.
     */
    create: XOR<QuestLocationCreateInput, QuestLocationUncheckedCreateInput>
    /**
     * In case the QuestLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestLocationUpdateInput, QuestLocationUncheckedUpdateInput>
  }

  /**
   * QuestLocation delete
   */
  export type QuestLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
    /**
     * Filter which QuestLocation to delete.
     */
    where: QuestLocationWhereUniqueInput
  }

  /**
   * QuestLocation deleteMany
   */
  export type QuestLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestLocations to delete
     */
    where?: QuestLocationWhereInput
    /**
     * Limit how many QuestLocations to delete.
     */
    limit?: number
  }

  /**
   * QuestLocation without action
   */
  export type QuestLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestLocation
     */
    select?: QuestLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestLocation
     */
    omit?: QuestLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestLocationInclude<ExtArgs> | null
  }


  /**
   * Model ChronicleQuest
   */

  export type AggregateChronicleQuest = {
    _count: ChronicleQuestCountAggregateOutputType | null
    _min: ChronicleQuestMinAggregateOutputType | null
    _max: ChronicleQuestMaxAggregateOutputType | null
  }

  export type ChronicleQuestMinAggregateOutputType = {
    chronicleId: string | null
    questId: string | null
    statusChange: string | null
  }

  export type ChronicleQuestMaxAggregateOutputType = {
    chronicleId: string | null
    questId: string | null
    statusChange: string | null
  }

  export type ChronicleQuestCountAggregateOutputType = {
    chronicleId: number
    questId: number
    statusChange: number
    _all: number
  }


  export type ChronicleQuestMinAggregateInputType = {
    chronicleId?: true
    questId?: true
    statusChange?: true
  }

  export type ChronicleQuestMaxAggregateInputType = {
    chronicleId?: true
    questId?: true
    statusChange?: true
  }

  export type ChronicleQuestCountAggregateInputType = {
    chronicleId?: true
    questId?: true
    statusChange?: true
    _all?: true
  }

  export type ChronicleQuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChronicleQuest to aggregate.
     */
    where?: ChronicleQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChronicleQuests to fetch.
     */
    orderBy?: ChronicleQuestOrderByWithRelationInput | ChronicleQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChronicleQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChronicleQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChronicleQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChronicleQuests
    **/
    _count?: true | ChronicleQuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChronicleQuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChronicleQuestMaxAggregateInputType
  }

  export type GetChronicleQuestAggregateType<T extends ChronicleQuestAggregateArgs> = {
        [P in keyof T & keyof AggregateChronicleQuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChronicleQuest[P]>
      : GetScalarType<T[P], AggregateChronicleQuest[P]>
  }




  export type ChronicleQuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChronicleQuestWhereInput
    orderBy?: ChronicleQuestOrderByWithAggregationInput | ChronicleQuestOrderByWithAggregationInput[]
    by: ChronicleQuestScalarFieldEnum[] | ChronicleQuestScalarFieldEnum
    having?: ChronicleQuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChronicleQuestCountAggregateInputType | true
    _min?: ChronicleQuestMinAggregateInputType
    _max?: ChronicleQuestMaxAggregateInputType
  }

  export type ChronicleQuestGroupByOutputType = {
    chronicleId: string
    questId: string
    statusChange: string
    _count: ChronicleQuestCountAggregateOutputType | null
    _min: ChronicleQuestMinAggregateOutputType | null
    _max: ChronicleQuestMaxAggregateOutputType | null
  }

  type GetChronicleQuestGroupByPayload<T extends ChronicleQuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChronicleQuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChronicleQuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChronicleQuestGroupByOutputType[P]>
            : GetScalarType<T[P], ChronicleQuestGroupByOutputType[P]>
        }
      >
    >


  export type ChronicleQuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chronicleId?: boolean
    questId?: boolean
    statusChange?: boolean
    chronicle?: boolean | ChronicleDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicleQuest"]>

  export type ChronicleQuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chronicleId?: boolean
    questId?: boolean
    statusChange?: boolean
    chronicle?: boolean | ChronicleDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicleQuest"]>

  export type ChronicleQuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chronicleId?: boolean
    questId?: boolean
    statusChange?: boolean
    chronicle?: boolean | ChronicleDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicleQuest"]>

  export type ChronicleQuestSelectScalar = {
    chronicleId?: boolean
    questId?: boolean
    statusChange?: boolean
  }

  export type ChronicleQuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chronicleId" | "questId" | "statusChange", ExtArgs["result"]["chronicleQuest"]>
  export type ChronicleQuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chronicle?: boolean | ChronicleDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }
  export type ChronicleQuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chronicle?: boolean | ChronicleDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }
  export type ChronicleQuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chronicle?: boolean | ChronicleDefaultArgs<ExtArgs>
    quest?: boolean | QuestDefaultArgs<ExtArgs>
  }

  export type $ChronicleQuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChronicleQuest"
    objects: {
      chronicle: Prisma.$ChroniclePayload<ExtArgs>
      quest: Prisma.$QuestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      chronicleId: string
      questId: string
      statusChange: string
    }, ExtArgs["result"]["chronicleQuest"]>
    composites: {}
  }

  type ChronicleQuestGetPayload<S extends boolean | null | undefined | ChronicleQuestDefaultArgs> = $Result.GetResult<Prisma.$ChronicleQuestPayload, S>

  type ChronicleQuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChronicleQuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChronicleQuestCountAggregateInputType | true
    }

  export interface ChronicleQuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChronicleQuest'], meta: { name: 'ChronicleQuest' } }
    /**
     * Find zero or one ChronicleQuest that matches the filter.
     * @param {ChronicleQuestFindUniqueArgs} args - Arguments to find a ChronicleQuest
     * @example
     * // Get one ChronicleQuest
     * const chronicleQuest = await prisma.chronicleQuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChronicleQuestFindUniqueArgs>(args: SelectSubset<T, ChronicleQuestFindUniqueArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChronicleQuest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChronicleQuestFindUniqueOrThrowArgs} args - Arguments to find a ChronicleQuest
     * @example
     * // Get one ChronicleQuest
     * const chronicleQuest = await prisma.chronicleQuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChronicleQuestFindUniqueOrThrowArgs>(args: SelectSubset<T, ChronicleQuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChronicleQuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestFindFirstArgs} args - Arguments to find a ChronicleQuest
     * @example
     * // Get one ChronicleQuest
     * const chronicleQuest = await prisma.chronicleQuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChronicleQuestFindFirstArgs>(args?: SelectSubset<T, ChronicleQuestFindFirstArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChronicleQuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestFindFirstOrThrowArgs} args - Arguments to find a ChronicleQuest
     * @example
     * // Get one ChronicleQuest
     * const chronicleQuest = await prisma.chronicleQuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChronicleQuestFindFirstOrThrowArgs>(args?: SelectSubset<T, ChronicleQuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChronicleQuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChronicleQuests
     * const chronicleQuests = await prisma.chronicleQuest.findMany()
     * 
     * // Get first 10 ChronicleQuests
     * const chronicleQuests = await prisma.chronicleQuest.findMany({ take: 10 })
     * 
     * // Only select the `chronicleId`
     * const chronicleQuestWithChronicleIdOnly = await prisma.chronicleQuest.findMany({ select: { chronicleId: true } })
     * 
     */
    findMany<T extends ChronicleQuestFindManyArgs>(args?: SelectSubset<T, ChronicleQuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChronicleQuest.
     * @param {ChronicleQuestCreateArgs} args - Arguments to create a ChronicleQuest.
     * @example
     * // Create one ChronicleQuest
     * const ChronicleQuest = await prisma.chronicleQuest.create({
     *   data: {
     *     // ... data to create a ChronicleQuest
     *   }
     * })
     * 
     */
    create<T extends ChronicleQuestCreateArgs>(args: SelectSubset<T, ChronicleQuestCreateArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChronicleQuests.
     * @param {ChronicleQuestCreateManyArgs} args - Arguments to create many ChronicleQuests.
     * @example
     * // Create many ChronicleQuests
     * const chronicleQuest = await prisma.chronicleQuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChronicleQuestCreateManyArgs>(args?: SelectSubset<T, ChronicleQuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChronicleQuests and returns the data saved in the database.
     * @param {ChronicleQuestCreateManyAndReturnArgs} args - Arguments to create many ChronicleQuests.
     * @example
     * // Create many ChronicleQuests
     * const chronicleQuest = await prisma.chronicleQuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChronicleQuests and only return the `chronicleId`
     * const chronicleQuestWithChronicleIdOnly = await prisma.chronicleQuest.createManyAndReturn({
     *   select: { chronicleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChronicleQuestCreateManyAndReturnArgs>(args?: SelectSubset<T, ChronicleQuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChronicleQuest.
     * @param {ChronicleQuestDeleteArgs} args - Arguments to delete one ChronicleQuest.
     * @example
     * // Delete one ChronicleQuest
     * const ChronicleQuest = await prisma.chronicleQuest.delete({
     *   where: {
     *     // ... filter to delete one ChronicleQuest
     *   }
     * })
     * 
     */
    delete<T extends ChronicleQuestDeleteArgs>(args: SelectSubset<T, ChronicleQuestDeleteArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChronicleQuest.
     * @param {ChronicleQuestUpdateArgs} args - Arguments to update one ChronicleQuest.
     * @example
     * // Update one ChronicleQuest
     * const chronicleQuest = await prisma.chronicleQuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChronicleQuestUpdateArgs>(args: SelectSubset<T, ChronicleQuestUpdateArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChronicleQuests.
     * @param {ChronicleQuestDeleteManyArgs} args - Arguments to filter ChronicleQuests to delete.
     * @example
     * // Delete a few ChronicleQuests
     * const { count } = await prisma.chronicleQuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChronicleQuestDeleteManyArgs>(args?: SelectSubset<T, ChronicleQuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChronicleQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChronicleQuests
     * const chronicleQuest = await prisma.chronicleQuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChronicleQuestUpdateManyArgs>(args: SelectSubset<T, ChronicleQuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChronicleQuests and returns the data updated in the database.
     * @param {ChronicleQuestUpdateManyAndReturnArgs} args - Arguments to update many ChronicleQuests.
     * @example
     * // Update many ChronicleQuests
     * const chronicleQuest = await prisma.chronicleQuest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChronicleQuests and only return the `chronicleId`
     * const chronicleQuestWithChronicleIdOnly = await prisma.chronicleQuest.updateManyAndReturn({
     *   select: { chronicleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChronicleQuestUpdateManyAndReturnArgs>(args: SelectSubset<T, ChronicleQuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChronicleQuest.
     * @param {ChronicleQuestUpsertArgs} args - Arguments to update or create a ChronicleQuest.
     * @example
     * // Update or create a ChronicleQuest
     * const chronicleQuest = await prisma.chronicleQuest.upsert({
     *   create: {
     *     // ... data to create a ChronicleQuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChronicleQuest we want to update
     *   }
     * })
     */
    upsert<T extends ChronicleQuestUpsertArgs>(args: SelectSubset<T, ChronicleQuestUpsertArgs<ExtArgs>>): Prisma__ChronicleQuestClient<$Result.GetResult<Prisma.$ChronicleQuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChronicleQuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestCountArgs} args - Arguments to filter ChronicleQuests to count.
     * @example
     * // Count the number of ChronicleQuests
     * const count = await prisma.chronicleQuest.count({
     *   where: {
     *     // ... the filter for the ChronicleQuests we want to count
     *   }
     * })
    **/
    count<T extends ChronicleQuestCountArgs>(
      args?: Subset<T, ChronicleQuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChronicleQuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChronicleQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChronicleQuestAggregateArgs>(args: Subset<T, ChronicleQuestAggregateArgs>): Prisma.PrismaPromise<GetChronicleQuestAggregateType<T>>

    /**
     * Group by ChronicleQuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChronicleQuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChronicleQuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChronicleQuestGroupByArgs['orderBy'] }
        : { orderBy?: ChronicleQuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChronicleQuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChronicleQuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChronicleQuest model
   */
  readonly fields: ChronicleQuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChronicleQuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChronicleQuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chronicle<T extends ChronicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChronicleDefaultArgs<ExtArgs>>): Prisma__ChronicleClient<$Result.GetResult<Prisma.$ChroniclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quest<T extends QuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestDefaultArgs<ExtArgs>>): Prisma__QuestClient<$Result.GetResult<Prisma.$QuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChronicleQuest model
   */
  interface ChronicleQuestFieldRefs {
    readonly chronicleId: FieldRef<"ChronicleQuest", 'String'>
    readonly questId: FieldRef<"ChronicleQuest", 'String'>
    readonly statusChange: FieldRef<"ChronicleQuest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChronicleQuest findUnique
   */
  export type ChronicleQuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * Filter, which ChronicleQuest to fetch.
     */
    where: ChronicleQuestWhereUniqueInput
  }

  /**
   * ChronicleQuest findUniqueOrThrow
   */
  export type ChronicleQuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * Filter, which ChronicleQuest to fetch.
     */
    where: ChronicleQuestWhereUniqueInput
  }

  /**
   * ChronicleQuest findFirst
   */
  export type ChronicleQuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * Filter, which ChronicleQuest to fetch.
     */
    where?: ChronicleQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChronicleQuests to fetch.
     */
    orderBy?: ChronicleQuestOrderByWithRelationInput | ChronicleQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChronicleQuests.
     */
    cursor?: ChronicleQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChronicleQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChronicleQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChronicleQuests.
     */
    distinct?: ChronicleQuestScalarFieldEnum | ChronicleQuestScalarFieldEnum[]
  }

  /**
   * ChronicleQuest findFirstOrThrow
   */
  export type ChronicleQuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * Filter, which ChronicleQuest to fetch.
     */
    where?: ChronicleQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChronicleQuests to fetch.
     */
    orderBy?: ChronicleQuestOrderByWithRelationInput | ChronicleQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChronicleQuests.
     */
    cursor?: ChronicleQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChronicleQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChronicleQuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChronicleQuests.
     */
    distinct?: ChronicleQuestScalarFieldEnum | ChronicleQuestScalarFieldEnum[]
  }

  /**
   * ChronicleQuest findMany
   */
  export type ChronicleQuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * Filter, which ChronicleQuests to fetch.
     */
    where?: ChronicleQuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChronicleQuests to fetch.
     */
    orderBy?: ChronicleQuestOrderByWithRelationInput | ChronicleQuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChronicleQuests.
     */
    cursor?: ChronicleQuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChronicleQuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChronicleQuests.
     */
    skip?: number
    distinct?: ChronicleQuestScalarFieldEnum | ChronicleQuestScalarFieldEnum[]
  }

  /**
   * ChronicleQuest create
   */
  export type ChronicleQuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * The data needed to create a ChronicleQuest.
     */
    data: XOR<ChronicleQuestCreateInput, ChronicleQuestUncheckedCreateInput>
  }

  /**
   * ChronicleQuest createMany
   */
  export type ChronicleQuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChronicleQuests.
     */
    data: ChronicleQuestCreateManyInput | ChronicleQuestCreateManyInput[]
  }

  /**
   * ChronicleQuest createManyAndReturn
   */
  export type ChronicleQuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * The data used to create many ChronicleQuests.
     */
    data: ChronicleQuestCreateManyInput | ChronicleQuestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChronicleQuest update
   */
  export type ChronicleQuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * The data needed to update a ChronicleQuest.
     */
    data: XOR<ChronicleQuestUpdateInput, ChronicleQuestUncheckedUpdateInput>
    /**
     * Choose, which ChronicleQuest to update.
     */
    where: ChronicleQuestWhereUniqueInput
  }

  /**
   * ChronicleQuest updateMany
   */
  export type ChronicleQuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChronicleQuests.
     */
    data: XOR<ChronicleQuestUpdateManyMutationInput, ChronicleQuestUncheckedUpdateManyInput>
    /**
     * Filter which ChronicleQuests to update
     */
    where?: ChronicleQuestWhereInput
    /**
     * Limit how many ChronicleQuests to update.
     */
    limit?: number
  }

  /**
   * ChronicleQuest updateManyAndReturn
   */
  export type ChronicleQuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * The data used to update ChronicleQuests.
     */
    data: XOR<ChronicleQuestUpdateManyMutationInput, ChronicleQuestUncheckedUpdateManyInput>
    /**
     * Filter which ChronicleQuests to update
     */
    where?: ChronicleQuestWhereInput
    /**
     * Limit how many ChronicleQuests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChronicleQuest upsert
   */
  export type ChronicleQuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * The filter to search for the ChronicleQuest to update in case it exists.
     */
    where: ChronicleQuestWhereUniqueInput
    /**
     * In case the ChronicleQuest found by the `where` argument doesn't exist, create a new ChronicleQuest with this data.
     */
    create: XOR<ChronicleQuestCreateInput, ChronicleQuestUncheckedCreateInput>
    /**
     * In case the ChronicleQuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChronicleQuestUpdateInput, ChronicleQuestUncheckedUpdateInput>
  }

  /**
   * ChronicleQuest delete
   */
  export type ChronicleQuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
    /**
     * Filter which ChronicleQuest to delete.
     */
    where: ChronicleQuestWhereUniqueInput
  }

  /**
   * ChronicleQuest deleteMany
   */
  export type ChronicleQuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChronicleQuests to delete
     */
    where?: ChronicleQuestWhereInput
    /**
     * Limit how many ChronicleQuests to delete.
     */
    limit?: number
  }

  /**
   * ChronicleQuest without action
   */
  export type ChronicleQuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChronicleQuest
     */
    select?: ChronicleQuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChronicleQuest
     */
    omit?: ChronicleQuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChronicleQuestInclude<ExtArgs> | null
  }


  /**
   * Model ItemLocation
   */

  export type AggregateItemLocation = {
    _count: ItemLocationCountAggregateOutputType | null
    _min: ItemLocationMinAggregateOutputType | null
    _max: ItemLocationMaxAggregateOutputType | null
  }

  export type ItemLocationMinAggregateOutputType = {
    itemId: string | null
    locationId: string | null
    isHidden: boolean | null
    notes: string | null
  }

  export type ItemLocationMaxAggregateOutputType = {
    itemId: string | null
    locationId: string | null
    isHidden: boolean | null
    notes: string | null
  }

  export type ItemLocationCountAggregateOutputType = {
    itemId: number
    locationId: number
    isHidden: number
    notes: number
    _all: number
  }


  export type ItemLocationMinAggregateInputType = {
    itemId?: true
    locationId?: true
    isHidden?: true
    notes?: true
  }

  export type ItemLocationMaxAggregateInputType = {
    itemId?: true
    locationId?: true
    isHidden?: true
    notes?: true
  }

  export type ItemLocationCountAggregateInputType = {
    itemId?: true
    locationId?: true
    isHidden?: true
    notes?: true
    _all?: true
  }

  export type ItemLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLocation to aggregate.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemLocations
    **/
    _count?: true | ItemLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemLocationMaxAggregateInputType
  }

  export type GetItemLocationAggregateType<T extends ItemLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateItemLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemLocation[P]>
      : GetScalarType<T[P], AggregateItemLocation[P]>
  }




  export type ItemLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLocationWhereInput
    orderBy?: ItemLocationOrderByWithAggregationInput | ItemLocationOrderByWithAggregationInput[]
    by: ItemLocationScalarFieldEnum[] | ItemLocationScalarFieldEnum
    having?: ItemLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemLocationCountAggregateInputType | true
    _min?: ItemLocationMinAggregateInputType
    _max?: ItemLocationMaxAggregateInputType
  }

  export type ItemLocationGroupByOutputType = {
    itemId: string
    locationId: string
    isHidden: boolean
    notes: string | null
    _count: ItemLocationCountAggregateOutputType | null
    _min: ItemLocationMinAggregateOutputType | null
    _max: ItemLocationMaxAggregateOutputType | null
  }

  type GetItemLocationGroupByPayload<T extends ItemLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemLocationGroupByOutputType[P]>
            : GetScalarType<T[P], ItemLocationGroupByOutputType[P]>
        }
      >
    >


  export type ItemLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    locationId?: boolean
    isHidden?: boolean
    notes?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLocation"]>

  export type ItemLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    locationId?: boolean
    isHidden?: boolean
    notes?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLocation"]>

  export type ItemLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    locationId?: boolean
    isHidden?: boolean
    notes?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLocation"]>

  export type ItemLocationSelectScalar = {
    itemId?: boolean
    locationId?: boolean
    isHidden?: boolean
    notes?: boolean
  }

  export type ItemLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemId" | "locationId" | "isHidden" | "notes", ExtArgs["result"]["itemLocation"]>
  export type ItemLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ItemLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ItemLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ItemLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemLocation"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemId: string
      locationId: string
      isHidden: boolean
      notes: string | null
    }, ExtArgs["result"]["itemLocation"]>
    composites: {}
  }

  type ItemLocationGetPayload<S extends boolean | null | undefined | ItemLocationDefaultArgs> = $Result.GetResult<Prisma.$ItemLocationPayload, S>

  type ItemLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemLocationCountAggregateInputType | true
    }

  export interface ItemLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemLocation'], meta: { name: 'ItemLocation' } }
    /**
     * Find zero or one ItemLocation that matches the filter.
     * @param {ItemLocationFindUniqueArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemLocationFindUniqueArgs>(args: SelectSubset<T, ItemLocationFindUniqueArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemLocationFindUniqueOrThrowArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationFindFirstArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemLocationFindFirstArgs>(args?: SelectSubset<T, ItemLocationFindFirstArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationFindFirstOrThrowArgs} args - Arguments to find a ItemLocation
     * @example
     * // Get one ItemLocation
     * const itemLocation = await prisma.itemLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemLocations
     * const itemLocations = await prisma.itemLocation.findMany()
     * 
     * // Get first 10 ItemLocations
     * const itemLocations = await prisma.itemLocation.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemLocationWithItemIdOnly = await prisma.itemLocation.findMany({ select: { itemId: true } })
     * 
     */
    findMany<T extends ItemLocationFindManyArgs>(args?: SelectSubset<T, ItemLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemLocation.
     * @param {ItemLocationCreateArgs} args - Arguments to create a ItemLocation.
     * @example
     * // Create one ItemLocation
     * const ItemLocation = await prisma.itemLocation.create({
     *   data: {
     *     // ... data to create a ItemLocation
     *   }
     * })
     * 
     */
    create<T extends ItemLocationCreateArgs>(args: SelectSubset<T, ItemLocationCreateArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemLocations.
     * @param {ItemLocationCreateManyArgs} args - Arguments to create many ItemLocations.
     * @example
     * // Create many ItemLocations
     * const itemLocation = await prisma.itemLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemLocationCreateManyArgs>(args?: SelectSubset<T, ItemLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemLocations and returns the data saved in the database.
     * @param {ItemLocationCreateManyAndReturnArgs} args - Arguments to create many ItemLocations.
     * @example
     * // Create many ItemLocations
     * const itemLocation = await prisma.itemLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemLocations and only return the `itemId`
     * const itemLocationWithItemIdOnly = await prisma.itemLocation.createManyAndReturn({
     *   select: { itemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemLocation.
     * @param {ItemLocationDeleteArgs} args - Arguments to delete one ItemLocation.
     * @example
     * // Delete one ItemLocation
     * const ItemLocation = await prisma.itemLocation.delete({
     *   where: {
     *     // ... filter to delete one ItemLocation
     *   }
     * })
     * 
     */
    delete<T extends ItemLocationDeleteArgs>(args: SelectSubset<T, ItemLocationDeleteArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemLocation.
     * @param {ItemLocationUpdateArgs} args - Arguments to update one ItemLocation.
     * @example
     * // Update one ItemLocation
     * const itemLocation = await prisma.itemLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemLocationUpdateArgs>(args: SelectSubset<T, ItemLocationUpdateArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemLocations.
     * @param {ItemLocationDeleteManyArgs} args - Arguments to filter ItemLocations to delete.
     * @example
     * // Delete a few ItemLocations
     * const { count } = await prisma.itemLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemLocationDeleteManyArgs>(args?: SelectSubset<T, ItemLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemLocations
     * const itemLocation = await prisma.itemLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemLocationUpdateManyArgs>(args: SelectSubset<T, ItemLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemLocations and returns the data updated in the database.
     * @param {ItemLocationUpdateManyAndReturnArgs} args - Arguments to update many ItemLocations.
     * @example
     * // Update many ItemLocations
     * const itemLocation = await prisma.itemLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemLocations and only return the `itemId`
     * const itemLocationWithItemIdOnly = await prisma.itemLocation.updateManyAndReturn({
     *   select: { itemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemLocation.
     * @param {ItemLocationUpsertArgs} args - Arguments to update or create a ItemLocation.
     * @example
     * // Update or create a ItemLocation
     * const itemLocation = await prisma.itemLocation.upsert({
     *   create: {
     *     // ... data to create a ItemLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemLocation we want to update
     *   }
     * })
     */
    upsert<T extends ItemLocationUpsertArgs>(args: SelectSubset<T, ItemLocationUpsertArgs<ExtArgs>>): Prisma__ItemLocationClient<$Result.GetResult<Prisma.$ItemLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationCountArgs} args - Arguments to filter ItemLocations to count.
     * @example
     * // Count the number of ItemLocations
     * const count = await prisma.itemLocation.count({
     *   where: {
     *     // ... the filter for the ItemLocations we want to count
     *   }
     * })
    **/
    count<T extends ItemLocationCountArgs>(
      args?: Subset<T, ItemLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemLocationAggregateArgs>(args: Subset<T, ItemLocationAggregateArgs>): Prisma.PrismaPromise<GetItemLocationAggregateType<T>>

    /**
     * Group by ItemLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemLocationGroupByArgs['orderBy'] }
        : { orderBy?: ItemLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemLocation model
   */
  readonly fields: ItemLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemLocation model
   */
  interface ItemLocationFieldRefs {
    readonly itemId: FieldRef<"ItemLocation", 'String'>
    readonly locationId: FieldRef<"ItemLocation", 'String'>
    readonly isHidden: FieldRef<"ItemLocation", 'Boolean'>
    readonly notes: FieldRef<"ItemLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemLocation findUnique
   */
  export type ItemLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where: ItemLocationWhereUniqueInput
  }

  /**
   * ItemLocation findUniqueOrThrow
   */
  export type ItemLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where: ItemLocationWhereUniqueInput
  }

  /**
   * ItemLocation findFirst
   */
  export type ItemLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLocations.
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLocations.
     */
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }

  /**
   * ItemLocation findFirstOrThrow
   */
  export type ItemLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocation to fetch.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLocations.
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLocations.
     */
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }

  /**
   * ItemLocation findMany
   */
  export type ItemLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter, which ItemLocations to fetch.
     */
    where?: ItemLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLocations to fetch.
     */
    orderBy?: ItemLocationOrderByWithRelationInput | ItemLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemLocations.
     */
    cursor?: ItemLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLocations.
     */
    skip?: number
    distinct?: ItemLocationScalarFieldEnum | ItemLocationScalarFieldEnum[]
  }

  /**
   * ItemLocation create
   */
  export type ItemLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemLocation.
     */
    data: XOR<ItemLocationCreateInput, ItemLocationUncheckedCreateInput>
  }

  /**
   * ItemLocation createMany
   */
  export type ItemLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemLocations.
     */
    data: ItemLocationCreateManyInput | ItemLocationCreateManyInput[]
  }

  /**
   * ItemLocation createManyAndReturn
   */
  export type ItemLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * The data used to create many ItemLocations.
     */
    data: ItemLocationCreateManyInput | ItemLocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemLocation update
   */
  export type ItemLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemLocation.
     */
    data: XOR<ItemLocationUpdateInput, ItemLocationUncheckedUpdateInput>
    /**
     * Choose, which ItemLocation to update.
     */
    where: ItemLocationWhereUniqueInput
  }

  /**
   * ItemLocation updateMany
   */
  export type ItemLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemLocations.
     */
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyInput>
    /**
     * Filter which ItemLocations to update
     */
    where?: ItemLocationWhereInput
    /**
     * Limit how many ItemLocations to update.
     */
    limit?: number
  }

  /**
   * ItemLocation updateManyAndReturn
   */
  export type ItemLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * The data used to update ItemLocations.
     */
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyInput>
    /**
     * Filter which ItemLocations to update
     */
    where?: ItemLocationWhereInput
    /**
     * Limit how many ItemLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemLocation upsert
   */
  export type ItemLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemLocation to update in case it exists.
     */
    where: ItemLocationWhereUniqueInput
    /**
     * In case the ItemLocation found by the `where` argument doesn't exist, create a new ItemLocation with this data.
     */
    create: XOR<ItemLocationCreateInput, ItemLocationUncheckedCreateInput>
    /**
     * In case the ItemLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemLocationUpdateInput, ItemLocationUncheckedUpdateInput>
  }

  /**
   * ItemLocation delete
   */
  export type ItemLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
    /**
     * Filter which ItemLocation to delete.
     */
    where: ItemLocationWhereUniqueInput
  }

  /**
   * ItemLocation deleteMany
   */
  export type ItemLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLocations to delete
     */
    where?: ItemLocationWhereInput
    /**
     * Limit how many ItemLocations to delete.
     */
    limit?: number
  }

  /**
   * ItemLocation without action
   */
  export type ItemLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLocation
     */
    select?: ItemLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLocation
     */
    omit?: ItemLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLocationInclude<ExtArgs> | null
  }


  /**
   * Model ItemNPC
   */

  export type AggregateItemNPC = {
    _count: ItemNPCCountAggregateOutputType | null
    _min: ItemNPCMinAggregateOutputType | null
    _max: ItemNPCMaxAggregateOutputType | null
  }

  export type ItemNPCMinAggregateOutputType = {
    itemId: string | null
    npcId: string | null
  }

  export type ItemNPCMaxAggregateOutputType = {
    itemId: string | null
    npcId: string | null
  }

  export type ItemNPCCountAggregateOutputType = {
    itemId: number
    npcId: number
    _all: number
  }


  export type ItemNPCMinAggregateInputType = {
    itemId?: true
    npcId?: true
  }

  export type ItemNPCMaxAggregateInputType = {
    itemId?: true
    npcId?: true
  }

  export type ItemNPCCountAggregateInputType = {
    itemId?: true
    npcId?: true
    _all?: true
  }

  export type ItemNPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemNPC to aggregate.
     */
    where?: ItemNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemNPCS to fetch.
     */
    orderBy?: ItemNPCOrderByWithRelationInput | ItemNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemNPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemNPCS
    **/
    _count?: true | ItemNPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemNPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemNPCMaxAggregateInputType
  }

  export type GetItemNPCAggregateType<T extends ItemNPCAggregateArgs> = {
        [P in keyof T & keyof AggregateItemNPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemNPC[P]>
      : GetScalarType<T[P], AggregateItemNPC[P]>
  }




  export type ItemNPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemNPCWhereInput
    orderBy?: ItemNPCOrderByWithAggregationInput | ItemNPCOrderByWithAggregationInput[]
    by: ItemNPCScalarFieldEnum[] | ItemNPCScalarFieldEnum
    having?: ItemNPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemNPCCountAggregateInputType | true
    _min?: ItemNPCMinAggregateInputType
    _max?: ItemNPCMaxAggregateInputType
  }

  export type ItemNPCGroupByOutputType = {
    itemId: string
    npcId: string
    _count: ItemNPCCountAggregateOutputType | null
    _min: ItemNPCMinAggregateOutputType | null
    _max: ItemNPCMaxAggregateOutputType | null
  }

  type GetItemNPCGroupByPayload<T extends ItemNPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemNPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemNPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemNPCGroupByOutputType[P]>
            : GetScalarType<T[P], ItemNPCGroupByOutputType[P]>
        }
      >
    >


  export type ItemNPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    npcId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemNPC"]>

  export type ItemNPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    npcId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemNPC"]>

  export type ItemNPCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    npcId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemNPC"]>

  export type ItemNPCSelectScalar = {
    itemId?: boolean
    npcId?: boolean
  }

  export type ItemNPCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemId" | "npcId", ExtArgs["result"]["itemNPC"]>
  export type ItemNPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type ItemNPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type ItemNPCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }

  export type $ItemNPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemNPC"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      npc: Prisma.$NPCPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemId: string
      npcId: string
    }, ExtArgs["result"]["itemNPC"]>
    composites: {}
  }

  type ItemNPCGetPayload<S extends boolean | null | undefined | ItemNPCDefaultArgs> = $Result.GetResult<Prisma.$ItemNPCPayload, S>

  type ItemNPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemNPCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemNPCCountAggregateInputType | true
    }

  export interface ItemNPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemNPC'], meta: { name: 'ItemNPC' } }
    /**
     * Find zero or one ItemNPC that matches the filter.
     * @param {ItemNPCFindUniqueArgs} args - Arguments to find a ItemNPC
     * @example
     * // Get one ItemNPC
     * const itemNPC = await prisma.itemNPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemNPCFindUniqueArgs>(args: SelectSubset<T, ItemNPCFindUniqueArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemNPC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemNPCFindUniqueOrThrowArgs} args - Arguments to find a ItemNPC
     * @example
     * // Get one ItemNPC
     * const itemNPC = await prisma.itemNPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemNPCFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemNPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemNPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCFindFirstArgs} args - Arguments to find a ItemNPC
     * @example
     * // Get one ItemNPC
     * const itemNPC = await prisma.itemNPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemNPCFindFirstArgs>(args?: SelectSubset<T, ItemNPCFindFirstArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemNPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCFindFirstOrThrowArgs} args - Arguments to find a ItemNPC
     * @example
     * // Get one ItemNPC
     * const itemNPC = await prisma.itemNPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemNPCFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemNPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemNPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemNPCS
     * const itemNPCS = await prisma.itemNPC.findMany()
     * 
     * // Get first 10 ItemNPCS
     * const itemNPCS = await prisma.itemNPC.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const itemNPCWithItemIdOnly = await prisma.itemNPC.findMany({ select: { itemId: true } })
     * 
     */
    findMany<T extends ItemNPCFindManyArgs>(args?: SelectSubset<T, ItemNPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemNPC.
     * @param {ItemNPCCreateArgs} args - Arguments to create a ItemNPC.
     * @example
     * // Create one ItemNPC
     * const ItemNPC = await prisma.itemNPC.create({
     *   data: {
     *     // ... data to create a ItemNPC
     *   }
     * })
     * 
     */
    create<T extends ItemNPCCreateArgs>(args: SelectSubset<T, ItemNPCCreateArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemNPCS.
     * @param {ItemNPCCreateManyArgs} args - Arguments to create many ItemNPCS.
     * @example
     * // Create many ItemNPCS
     * const itemNPC = await prisma.itemNPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemNPCCreateManyArgs>(args?: SelectSubset<T, ItemNPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemNPCS and returns the data saved in the database.
     * @param {ItemNPCCreateManyAndReturnArgs} args - Arguments to create many ItemNPCS.
     * @example
     * // Create many ItemNPCS
     * const itemNPC = await prisma.itemNPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemNPCS and only return the `itemId`
     * const itemNPCWithItemIdOnly = await prisma.itemNPC.createManyAndReturn({
     *   select: { itemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemNPCCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemNPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemNPC.
     * @param {ItemNPCDeleteArgs} args - Arguments to delete one ItemNPC.
     * @example
     * // Delete one ItemNPC
     * const ItemNPC = await prisma.itemNPC.delete({
     *   where: {
     *     // ... filter to delete one ItemNPC
     *   }
     * })
     * 
     */
    delete<T extends ItemNPCDeleteArgs>(args: SelectSubset<T, ItemNPCDeleteArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemNPC.
     * @param {ItemNPCUpdateArgs} args - Arguments to update one ItemNPC.
     * @example
     * // Update one ItemNPC
     * const itemNPC = await prisma.itemNPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemNPCUpdateArgs>(args: SelectSubset<T, ItemNPCUpdateArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemNPCS.
     * @param {ItemNPCDeleteManyArgs} args - Arguments to filter ItemNPCS to delete.
     * @example
     * // Delete a few ItemNPCS
     * const { count } = await prisma.itemNPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemNPCDeleteManyArgs>(args?: SelectSubset<T, ItemNPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemNPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemNPCS
     * const itemNPC = await prisma.itemNPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemNPCUpdateManyArgs>(args: SelectSubset<T, ItemNPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemNPCS and returns the data updated in the database.
     * @param {ItemNPCUpdateManyAndReturnArgs} args - Arguments to update many ItemNPCS.
     * @example
     * // Update many ItemNPCS
     * const itemNPC = await prisma.itemNPC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemNPCS and only return the `itemId`
     * const itemNPCWithItemIdOnly = await prisma.itemNPC.updateManyAndReturn({
     *   select: { itemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemNPCUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemNPCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemNPC.
     * @param {ItemNPCUpsertArgs} args - Arguments to update or create a ItemNPC.
     * @example
     * // Update or create a ItemNPC
     * const itemNPC = await prisma.itemNPC.upsert({
     *   create: {
     *     // ... data to create a ItemNPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemNPC we want to update
     *   }
     * })
     */
    upsert<T extends ItemNPCUpsertArgs>(args: SelectSubset<T, ItemNPCUpsertArgs<ExtArgs>>): Prisma__ItemNPCClient<$Result.GetResult<Prisma.$ItemNPCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemNPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCCountArgs} args - Arguments to filter ItemNPCS to count.
     * @example
     * // Count the number of ItemNPCS
     * const count = await prisma.itemNPC.count({
     *   where: {
     *     // ... the filter for the ItemNPCS we want to count
     *   }
     * })
    **/
    count<T extends ItemNPCCountArgs>(
      args?: Subset<T, ItemNPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemNPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemNPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemNPCAggregateArgs>(args: Subset<T, ItemNPCAggregateArgs>): Prisma.PrismaPromise<GetItemNPCAggregateType<T>>

    /**
     * Group by ItemNPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemNPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemNPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemNPCGroupByArgs['orderBy'] }
        : { orderBy?: ItemNPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemNPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemNPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemNPC model
   */
  readonly fields: ItemNPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemNPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemNPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemNPC model
   */
  interface ItemNPCFieldRefs {
    readonly itemId: FieldRef<"ItemNPC", 'String'>
    readonly npcId: FieldRef<"ItemNPC", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ItemNPC findUnique
   */
  export type ItemNPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * Filter, which ItemNPC to fetch.
     */
    where: ItemNPCWhereUniqueInput
  }

  /**
   * ItemNPC findUniqueOrThrow
   */
  export type ItemNPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * Filter, which ItemNPC to fetch.
     */
    where: ItemNPCWhereUniqueInput
  }

  /**
   * ItemNPC findFirst
   */
  export type ItemNPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * Filter, which ItemNPC to fetch.
     */
    where?: ItemNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemNPCS to fetch.
     */
    orderBy?: ItemNPCOrderByWithRelationInput | ItemNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemNPCS.
     */
    cursor?: ItemNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemNPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemNPCS.
     */
    distinct?: ItemNPCScalarFieldEnum | ItemNPCScalarFieldEnum[]
  }

  /**
   * ItemNPC findFirstOrThrow
   */
  export type ItemNPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * Filter, which ItemNPC to fetch.
     */
    where?: ItemNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemNPCS to fetch.
     */
    orderBy?: ItemNPCOrderByWithRelationInput | ItemNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemNPCS.
     */
    cursor?: ItemNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemNPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemNPCS.
     */
    distinct?: ItemNPCScalarFieldEnum | ItemNPCScalarFieldEnum[]
  }

  /**
   * ItemNPC findMany
   */
  export type ItemNPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * Filter, which ItemNPCS to fetch.
     */
    where?: ItemNPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemNPCS to fetch.
     */
    orderBy?: ItemNPCOrderByWithRelationInput | ItemNPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemNPCS.
     */
    cursor?: ItemNPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemNPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemNPCS.
     */
    skip?: number
    distinct?: ItemNPCScalarFieldEnum | ItemNPCScalarFieldEnum[]
  }

  /**
   * ItemNPC create
   */
  export type ItemNPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemNPC.
     */
    data: XOR<ItemNPCCreateInput, ItemNPCUncheckedCreateInput>
  }

  /**
   * ItemNPC createMany
   */
  export type ItemNPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemNPCS.
     */
    data: ItemNPCCreateManyInput | ItemNPCCreateManyInput[]
  }

  /**
   * ItemNPC createManyAndReturn
   */
  export type ItemNPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * The data used to create many ItemNPCS.
     */
    data: ItemNPCCreateManyInput | ItemNPCCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemNPC update
   */
  export type ItemNPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemNPC.
     */
    data: XOR<ItemNPCUpdateInput, ItemNPCUncheckedUpdateInput>
    /**
     * Choose, which ItemNPC to update.
     */
    where: ItemNPCWhereUniqueInput
  }

  /**
   * ItemNPC updateMany
   */
  export type ItemNPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemNPCS.
     */
    data: XOR<ItemNPCUpdateManyMutationInput, ItemNPCUncheckedUpdateManyInput>
    /**
     * Filter which ItemNPCS to update
     */
    where?: ItemNPCWhereInput
    /**
     * Limit how many ItemNPCS to update.
     */
    limit?: number
  }

  /**
   * ItemNPC updateManyAndReturn
   */
  export type ItemNPCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * The data used to update ItemNPCS.
     */
    data: XOR<ItemNPCUpdateManyMutationInput, ItemNPCUncheckedUpdateManyInput>
    /**
     * Filter which ItemNPCS to update
     */
    where?: ItemNPCWhereInput
    /**
     * Limit how many ItemNPCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemNPC upsert
   */
  export type ItemNPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemNPC to update in case it exists.
     */
    where: ItemNPCWhereUniqueInput
    /**
     * In case the ItemNPC found by the `where` argument doesn't exist, create a new ItemNPC with this data.
     */
    create: XOR<ItemNPCCreateInput, ItemNPCUncheckedCreateInput>
    /**
     * In case the ItemNPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemNPCUpdateInput, ItemNPCUncheckedUpdateInput>
  }

  /**
   * ItemNPC delete
   */
  export type ItemNPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
    /**
     * Filter which ItemNPC to delete.
     */
    where: ItemNPCWhereUniqueInput
  }

  /**
   * ItemNPC deleteMany
   */
  export type ItemNPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemNPCS to delete
     */
    where?: ItemNPCWhereInput
    /**
     * Limit how many ItemNPCS to delete.
     */
    limit?: number
  }

  /**
   * ItemNPC without action
   */
  export type ItemNPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemNPC
     */
    select?: ItemNPCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemNPC
     */
    omit?: ItemNPCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemNPCInclude<ExtArgs> | null
  }


  /**
   * Model InteractionItem
   */

  export type AggregateInteractionItem = {
    _count: InteractionItemCountAggregateOutputType | null
    _min: InteractionItemMinAggregateOutputType | null
    _max: InteractionItemMaxAggregateOutputType | null
  }

  export type InteractionItemMinAggregateOutputType = {
    interactionId: string | null
    itemId: string | null
    transactionType: $Enums.TransactionType | null
  }

  export type InteractionItemMaxAggregateOutputType = {
    interactionId: string | null
    itemId: string | null
    transactionType: $Enums.TransactionType | null
  }

  export type InteractionItemCountAggregateOutputType = {
    interactionId: number
    itemId: number
    transactionType: number
    _all: number
  }


  export type InteractionItemMinAggregateInputType = {
    interactionId?: true
    itemId?: true
    transactionType?: true
  }

  export type InteractionItemMaxAggregateInputType = {
    interactionId?: true
    itemId?: true
    transactionType?: true
  }

  export type InteractionItemCountAggregateInputType = {
    interactionId?: true
    itemId?: true
    transactionType?: true
    _all?: true
  }

  export type InteractionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionItem to aggregate.
     */
    where?: InteractionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionItems to fetch.
     */
    orderBy?: InteractionItemOrderByWithRelationInput | InteractionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InteractionItems
    **/
    _count?: true | InteractionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionItemMaxAggregateInputType
  }

  export type GetInteractionItemAggregateType<T extends InteractionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInteractionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteractionItem[P]>
      : GetScalarType<T[P], AggregateInteractionItem[P]>
  }




  export type InteractionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionItemWhereInput
    orderBy?: InteractionItemOrderByWithAggregationInput | InteractionItemOrderByWithAggregationInput[]
    by: InteractionItemScalarFieldEnum[] | InteractionItemScalarFieldEnum
    having?: InteractionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionItemCountAggregateInputType | true
    _min?: InteractionItemMinAggregateInputType
    _max?: InteractionItemMaxAggregateInputType
  }

  export type InteractionItemGroupByOutputType = {
    interactionId: string
    itemId: string
    transactionType: $Enums.TransactionType
    _count: InteractionItemCountAggregateOutputType | null
    _min: InteractionItemMinAggregateOutputType | null
    _max: InteractionItemMaxAggregateOutputType | null
  }

  type GetInteractionItemGroupByPayload<T extends InteractionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionItemGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionItemGroupByOutputType[P]>
        }
      >
    >


  export type InteractionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interactionId?: boolean
    itemId?: boolean
    transactionType?: boolean
    interaction?: boolean | InteractionDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionItem"]>

  export type InteractionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interactionId?: boolean
    itemId?: boolean
    transactionType?: boolean
    interaction?: boolean | InteractionDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionItem"]>

  export type InteractionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interactionId?: boolean
    itemId?: boolean
    transactionType?: boolean
    interaction?: boolean | InteractionDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interactionItem"]>

  export type InteractionItemSelectScalar = {
    interactionId?: boolean
    itemId?: boolean
    transactionType?: boolean
  }

  export type InteractionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"interactionId" | "itemId" | "transactionType", ExtArgs["result"]["interactionItem"]>
  export type InteractionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interaction?: boolean | InteractionDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InteractionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interaction?: boolean | InteractionDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InteractionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interaction?: boolean | InteractionDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $InteractionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InteractionItem"
    objects: {
      interaction: Prisma.$InteractionPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      interactionId: string
      itemId: string
      transactionType: $Enums.TransactionType
    }, ExtArgs["result"]["interactionItem"]>
    composites: {}
  }

  type InteractionItemGetPayload<S extends boolean | null | undefined | InteractionItemDefaultArgs> = $Result.GetResult<Prisma.$InteractionItemPayload, S>

  type InteractionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractionItemCountAggregateInputType | true
    }

  export interface InteractionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InteractionItem'], meta: { name: 'InteractionItem' } }
    /**
     * Find zero or one InteractionItem that matches the filter.
     * @param {InteractionItemFindUniqueArgs} args - Arguments to find a InteractionItem
     * @example
     * // Get one InteractionItem
     * const interactionItem = await prisma.interactionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionItemFindUniqueArgs>(args: SelectSubset<T, InteractionItemFindUniqueArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InteractionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractionItemFindUniqueOrThrowArgs} args - Arguments to find a InteractionItem
     * @example
     * // Get one InteractionItem
     * const interactionItem = await prisma.interactionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteractionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemFindFirstArgs} args - Arguments to find a InteractionItem
     * @example
     * // Get one InteractionItem
     * const interactionItem = await prisma.interactionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionItemFindFirstArgs>(args?: SelectSubset<T, InteractionItemFindFirstArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteractionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemFindFirstOrThrowArgs} args - Arguments to find a InteractionItem
     * @example
     * // Get one InteractionItem
     * const interactionItem = await prisma.interactionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InteractionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InteractionItems
     * const interactionItems = await prisma.interactionItem.findMany()
     * 
     * // Get first 10 InteractionItems
     * const interactionItems = await prisma.interactionItem.findMany({ take: 10 })
     * 
     * // Only select the `interactionId`
     * const interactionItemWithInteractionIdOnly = await prisma.interactionItem.findMany({ select: { interactionId: true } })
     * 
     */
    findMany<T extends InteractionItemFindManyArgs>(args?: SelectSubset<T, InteractionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InteractionItem.
     * @param {InteractionItemCreateArgs} args - Arguments to create a InteractionItem.
     * @example
     * // Create one InteractionItem
     * const InteractionItem = await prisma.interactionItem.create({
     *   data: {
     *     // ... data to create a InteractionItem
     *   }
     * })
     * 
     */
    create<T extends InteractionItemCreateArgs>(args: SelectSubset<T, InteractionItemCreateArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InteractionItems.
     * @param {InteractionItemCreateManyArgs} args - Arguments to create many InteractionItems.
     * @example
     * // Create many InteractionItems
     * const interactionItem = await prisma.interactionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionItemCreateManyArgs>(args?: SelectSubset<T, InteractionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InteractionItems and returns the data saved in the database.
     * @param {InteractionItemCreateManyAndReturnArgs} args - Arguments to create many InteractionItems.
     * @example
     * // Create many InteractionItems
     * const interactionItem = await prisma.interactionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InteractionItems and only return the `interactionId`
     * const interactionItemWithInteractionIdOnly = await prisma.interactionItem.createManyAndReturn({
     *   select: { interactionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InteractionItem.
     * @param {InteractionItemDeleteArgs} args - Arguments to delete one InteractionItem.
     * @example
     * // Delete one InteractionItem
     * const InteractionItem = await prisma.interactionItem.delete({
     *   where: {
     *     // ... filter to delete one InteractionItem
     *   }
     * })
     * 
     */
    delete<T extends InteractionItemDeleteArgs>(args: SelectSubset<T, InteractionItemDeleteArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InteractionItem.
     * @param {InteractionItemUpdateArgs} args - Arguments to update one InteractionItem.
     * @example
     * // Update one InteractionItem
     * const interactionItem = await prisma.interactionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionItemUpdateArgs>(args: SelectSubset<T, InteractionItemUpdateArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InteractionItems.
     * @param {InteractionItemDeleteManyArgs} args - Arguments to filter InteractionItems to delete.
     * @example
     * // Delete a few InteractionItems
     * const { count } = await prisma.interactionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionItemDeleteManyArgs>(args?: SelectSubset<T, InteractionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InteractionItems
     * const interactionItem = await prisma.interactionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionItemUpdateManyArgs>(args: SelectSubset<T, InteractionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteractionItems and returns the data updated in the database.
     * @param {InteractionItemUpdateManyAndReturnArgs} args - Arguments to update many InteractionItems.
     * @example
     * // Update many InteractionItems
     * const interactionItem = await prisma.interactionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InteractionItems and only return the `interactionId`
     * const interactionItemWithInteractionIdOnly = await prisma.interactionItem.updateManyAndReturn({
     *   select: { interactionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InteractionItem.
     * @param {InteractionItemUpsertArgs} args - Arguments to update or create a InteractionItem.
     * @example
     * // Update or create a InteractionItem
     * const interactionItem = await prisma.interactionItem.upsert({
     *   create: {
     *     // ... data to create a InteractionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InteractionItem we want to update
     *   }
     * })
     */
    upsert<T extends InteractionItemUpsertArgs>(args: SelectSubset<T, InteractionItemUpsertArgs<ExtArgs>>): Prisma__InteractionItemClient<$Result.GetResult<Prisma.$InteractionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InteractionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemCountArgs} args - Arguments to filter InteractionItems to count.
     * @example
     * // Count the number of InteractionItems
     * const count = await prisma.interactionItem.count({
     *   where: {
     *     // ... the filter for the InteractionItems we want to count
     *   }
     * })
    **/
    count<T extends InteractionItemCountArgs>(
      args?: Subset<T, InteractionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InteractionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionItemAggregateArgs>(args: Subset<T, InteractionItemAggregateArgs>): Prisma.PrismaPromise<GetInteractionItemAggregateType<T>>

    /**
     * Group by InteractionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionItemGroupByArgs['orderBy'] }
        : { orderBy?: InteractionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InteractionItem model
   */
  readonly fields: InteractionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InteractionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interaction<T extends InteractionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InteractionDefaultArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InteractionItem model
   */
  interface InteractionItemFieldRefs {
    readonly interactionId: FieldRef<"InteractionItem", 'String'>
    readonly itemId: FieldRef<"InteractionItem", 'String'>
    readonly transactionType: FieldRef<"InteractionItem", 'TransactionType'>
  }
    

  // Custom InputTypes
  /**
   * InteractionItem findUnique
   */
  export type InteractionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * Filter, which InteractionItem to fetch.
     */
    where: InteractionItemWhereUniqueInput
  }

  /**
   * InteractionItem findUniqueOrThrow
   */
  export type InteractionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * Filter, which InteractionItem to fetch.
     */
    where: InteractionItemWhereUniqueInput
  }

  /**
   * InteractionItem findFirst
   */
  export type InteractionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * Filter, which InteractionItem to fetch.
     */
    where?: InteractionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionItems to fetch.
     */
    orderBy?: InteractionItemOrderByWithRelationInput | InteractionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionItems.
     */
    cursor?: InteractionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionItems.
     */
    distinct?: InteractionItemScalarFieldEnum | InteractionItemScalarFieldEnum[]
  }

  /**
   * InteractionItem findFirstOrThrow
   */
  export type InteractionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * Filter, which InteractionItem to fetch.
     */
    where?: InteractionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionItems to fetch.
     */
    orderBy?: InteractionItemOrderByWithRelationInput | InteractionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteractionItems.
     */
    cursor?: InteractionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteractionItems.
     */
    distinct?: InteractionItemScalarFieldEnum | InteractionItemScalarFieldEnum[]
  }

  /**
   * InteractionItem findMany
   */
  export type InteractionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * Filter, which InteractionItems to fetch.
     */
    where?: InteractionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteractionItems to fetch.
     */
    orderBy?: InteractionItemOrderByWithRelationInput | InteractionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InteractionItems.
     */
    cursor?: InteractionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteractionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteractionItems.
     */
    skip?: number
    distinct?: InteractionItemScalarFieldEnum | InteractionItemScalarFieldEnum[]
  }

  /**
   * InteractionItem create
   */
  export type InteractionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InteractionItem.
     */
    data: XOR<InteractionItemCreateInput, InteractionItemUncheckedCreateInput>
  }

  /**
   * InteractionItem createMany
   */
  export type InteractionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InteractionItems.
     */
    data: InteractionItemCreateManyInput | InteractionItemCreateManyInput[]
  }

  /**
   * InteractionItem createManyAndReturn
   */
  export type InteractionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * The data used to create many InteractionItems.
     */
    data: InteractionItemCreateManyInput | InteractionItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteractionItem update
   */
  export type InteractionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InteractionItem.
     */
    data: XOR<InteractionItemUpdateInput, InteractionItemUncheckedUpdateInput>
    /**
     * Choose, which InteractionItem to update.
     */
    where: InteractionItemWhereUniqueInput
  }

  /**
   * InteractionItem updateMany
   */
  export type InteractionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InteractionItems.
     */
    data: XOR<InteractionItemUpdateManyMutationInput, InteractionItemUncheckedUpdateManyInput>
    /**
     * Filter which InteractionItems to update
     */
    where?: InteractionItemWhereInput
    /**
     * Limit how many InteractionItems to update.
     */
    limit?: number
  }

  /**
   * InteractionItem updateManyAndReturn
   */
  export type InteractionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * The data used to update InteractionItems.
     */
    data: XOR<InteractionItemUpdateManyMutationInput, InteractionItemUncheckedUpdateManyInput>
    /**
     * Filter which InteractionItems to update
     */
    where?: InteractionItemWhereInput
    /**
     * Limit how many InteractionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteractionItem upsert
   */
  export type InteractionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InteractionItem to update in case it exists.
     */
    where: InteractionItemWhereUniqueInput
    /**
     * In case the InteractionItem found by the `where` argument doesn't exist, create a new InteractionItem with this data.
     */
    create: XOR<InteractionItemCreateInput, InteractionItemUncheckedCreateInput>
    /**
     * In case the InteractionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionItemUpdateInput, InteractionItemUncheckedUpdateInput>
  }

  /**
   * InteractionItem delete
   */
  export type InteractionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
    /**
     * Filter which InteractionItem to delete.
     */
    where: InteractionItemWhereUniqueInput
  }

  /**
   * InteractionItem deleteMany
   */
  export type InteractionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteractionItems to delete
     */
    where?: InteractionItemWhereInput
    /**
     * Limit how many InteractionItems to delete.
     */
    limit?: number
  }

  /**
   * InteractionItem without action
   */
  export type InteractionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionItem
     */
    select?: InteractionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteractionItem
     */
    omit?: InteractionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    coverImagePath: 'coverImagePath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastPlayedAt: 'lastPlayedAt',
    settings: 'settings'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const NPCScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    name: 'name',
    title: 'title',
    race: 'race',
    creatureType: 'creatureType',
    role: 'role',
    class: 'class',
    alignment: 'alignment',
    attitudeToParty: 'attitudeToParty',
    languages: 'languages',
    appearance: 'appearance',
    personality: 'personality',
    motivations: 'motivations',
    backstory: 'backstory',
    dmNotes: 'dmNotes',
    portraitPath: 'portraitPath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NPCScalarFieldEnum = (typeof NPCScalarFieldEnum)[keyof typeof NPCScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    parentLocationId: 'parentLocationId',
    name: 'name',
    type: 'type',
    description: 'description',
    notableFeatures: 'notableFeatures',
    coverImagePath: 'coverImagePath',
    dmNotes: 'dmNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const MapScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    locationId: 'locationId',
    name: 'name',
    imagePath: 'imagePath',
    gridSize: 'gridSize',
    gridEnabled: 'gridEnabled',
    scale: 'scale',
    width: 'width',
    height: 'height',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MapScalarFieldEnum = (typeof MapScalarFieldEnum)[keyof typeof MapScalarFieldEnum]


  export const MapAnnotationScalarFieldEnum: {
    id: 'id',
    mapId: 'mapId',
    type: 'type',
    x: 'x',
    y: 'y',
    title: 'title',
    content: 'content',
    isHidden: 'isHidden'
  };

  export type MapAnnotationScalarFieldEnum = (typeof MapAnnotationScalarFieldEnum)[keyof typeof MapAnnotationScalarFieldEnum]


  export const MonsterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    size: 'size',
    creatureType: 'creatureType',
    alignment: 'alignment',
    portraitPath: 'portraitPath',
    hpMax: 'hpMax',
    hpDice: 'hpDice',
    ac: 'ac',
    acDescription: 'acDescription',
    speed: 'speed',
    abilities: 'abilities',
    savingThrows: 'savingThrows',
    skills: 'skills',
    damageResistances: 'damageResistances',
    damageImmunities: 'damageImmunities',
    conditionImmunities: 'conditionImmunities',
    senses: 'senses',
    languages: 'languages',
    challengeRating: 'challengeRating',
    actions: 'actions',
    reactions: 'reactions',
    legendaryActions: 'legendaryActions',
    description: 'description',
    dmNotes: 'dmNotes',
    isTemplate: 'isTemplate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MonsterScalarFieldEnum = (typeof MonsterScalarFieldEnum)[keyof typeof MonsterScalarFieldEnum]


  export const ConditionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    description: 'description',
    mechanicalEffects: 'mechanicalEffects',
    isCustom: 'isCustom'
  };

  export type ConditionScalarFieldEnum = (typeof ConditionScalarFieldEnum)[keyof typeof ConditionScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    mapId: 'mapId',
    locationId: 'locationId',
    name: 'name',
    description: 'description',
    difficulty: 'difficulty',
    status: 'status',
    dmNotes: 'dmNotes',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const EncounterParticipantScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    participantType: 'participantType',
    monsterId: 'monsterId',
    playerCharacterId: 'playerCharacterId',
    customName: 'customName',
    initiative: 'initiative',
    hpCurrent: 'hpCurrent',
    hpMax: 'hpMax',
    ac: 'ac',
    conditions: 'conditions',
    positionX: 'positionX',
    positionY: 'positionY',
    isVisible: 'isVisible',
    dmNotes: 'dmNotes'
  };

  export type EncounterParticipantScalarFieldEnum = (typeof EncounterParticipantScalarFieldEnum)[keyof typeof EncounterParticipantScalarFieldEnum]


  export const PlayerCharacterScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    playerName: 'playerName',
    characterName: 'characterName',
    race: 'race',
    class: 'class',
    level: 'level',
    alignment: 'alignment',
    backgroundType: 'backgroundType',
    background: 'background',
    languages: 'languages',
    portraitPath: 'portraitPath',
    hpMax: 'hpMax',
    ac: 'ac',
    passivePerception: 'passivePerception',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerCharacterScalarFieldEnum = (typeof PlayerCharacterScalarFieldEnum)[keyof typeof PlayerCharacterScalarFieldEnum]


  export const QuestScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    parentQuestId: 'parentQuestId',
    name: 'name',
    description: 'description',
    objectives: 'objectives',
    status: 'status',
    questGiverNpcId: 'questGiverNpcId',
    rewardDescription: 'rewardDescription',
    rewardItems: 'rewardItems',
    isMilestone: 'isMilestone',
    dmNotes: 'dmNotes',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type QuestScalarFieldEnum = (typeof QuestScalarFieldEnum)[keyof typeof QuestScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    rarity: 'rarity',
    description: 'description',
    mechanicalEffects: 'mechanicalEffects',
    grantedAbilities: 'grantedAbilities',
    value: 'value',
    weight: 'weight',
    quantity: 'quantity',
    isMagical: 'isMagical',
    attunementRequired: 'attunementRequired',
    dmNotes: 'dmNotes',
    createdAt: 'createdAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const ChronicleScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    sessionNumber: 'sessionNumber',
    sessionDate: 'sessionDate',
    title: 'title',
    summary: 'summary',
    playerDeeds: 'playerDeeds',
    importantDecisions: 'importantDecisions',
    dmNotes: 'dmNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChronicleScalarFieldEnum = (typeof ChronicleScalarFieldEnum)[keyof typeof ChronicleScalarFieldEnum]


  export const InteractionScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    npcId: 'npcId',
    interactionDate: 'interactionDate',
    sessionDate: 'sessionDate',
    interactionType: 'interactionType',
    summary: 'summary',
    details: 'details',
    attitudeChange: 'attitudeChange',
    involvedPcs: 'involvedPcs',
    dmNotes: 'dmNotes',
    createdAt: 'createdAt'
  };

  export type InteractionScalarFieldEnum = (typeof InteractionScalarFieldEnum)[keyof typeof InteractionScalarFieldEnum]


  export const MonsterCampaignScalarFieldEnum: {
    monsterId: 'monsterId',
    campaignId: 'campaignId'
  };

  export type MonsterCampaignScalarFieldEnum = (typeof MonsterCampaignScalarFieldEnum)[keyof typeof MonsterCampaignScalarFieldEnum]


  export const ItemCampaignScalarFieldEnum: {
    itemId: 'itemId',
    campaignId: 'campaignId'
  };

  export type ItemCampaignScalarFieldEnum = (typeof ItemCampaignScalarFieldEnum)[keyof typeof ItemCampaignScalarFieldEnum]


  export const NPCLocationScalarFieldEnum: {
    npcId: 'npcId',
    locationId: 'locationId',
    isPrimary: 'isPrimary'
  };

  export type NPCLocationScalarFieldEnum = (typeof NPCLocationScalarFieldEnum)[keyof typeof NPCLocationScalarFieldEnum]


  export const QuestNPCScalarFieldEnum: {
    questId: 'questId',
    npcId: 'npcId',
    role: 'role'
  };

  export type QuestNPCScalarFieldEnum = (typeof QuestNPCScalarFieldEnum)[keyof typeof QuestNPCScalarFieldEnum]


  export const QuestLocationScalarFieldEnum: {
    questId: 'questId',
    locationId: 'locationId'
  };

  export type QuestLocationScalarFieldEnum = (typeof QuestLocationScalarFieldEnum)[keyof typeof QuestLocationScalarFieldEnum]


  export const ChronicleQuestScalarFieldEnum: {
    chronicleId: 'chronicleId',
    questId: 'questId',
    statusChange: 'statusChange'
  };

  export type ChronicleQuestScalarFieldEnum = (typeof ChronicleQuestScalarFieldEnum)[keyof typeof ChronicleQuestScalarFieldEnum]


  export const ItemLocationScalarFieldEnum: {
    itemId: 'itemId',
    locationId: 'locationId',
    isHidden: 'isHidden',
    notes: 'notes'
  };

  export type ItemLocationScalarFieldEnum = (typeof ItemLocationScalarFieldEnum)[keyof typeof ItemLocationScalarFieldEnum]


  export const ItemNPCScalarFieldEnum: {
    itemId: 'itemId',
    npcId: 'npcId'
  };

  export type ItemNPCScalarFieldEnum = (typeof ItemNPCScalarFieldEnum)[keyof typeof ItemNPCScalarFieldEnum]


  export const InteractionItemScalarFieldEnum: {
    interactionId: 'interactionId',
    itemId: 'itemId',
    transactionType: 'transactionType'
  };

  export type InteractionItemScalarFieldEnum = (typeof InteractionItemScalarFieldEnum)[keyof typeof InteractionItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Race'
   */
  export type EnumRaceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Race'>
    


  /**
   * Reference to a field of type 'CreatureType'
   */
  export type EnumCreatureTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatureType'>
    


  /**
   * Reference to a field of type 'NPCRole'
   */
  export type EnumNPCRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NPCRole'>
    


  /**
   * Reference to a field of type 'CharacterClass'
   */
  export type EnumCharacterClassFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CharacterClass'>
    


  /**
   * Reference to a field of type 'Alignment'
   */
  export type EnumAlignmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Alignment'>
    


  /**
   * Reference to a field of type 'NPCAttitude'
   */
  export type EnumNPCAttitudeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NPCAttitude'>
    


  /**
   * Reference to a field of type 'LocationType'
   */
  export type EnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'MapAnnotationType'
   */
  export type EnumMapAnnotationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MapAnnotationType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Size'
   */
  export type EnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size'>
    


  /**
   * Reference to a field of type 'Difficulty'
   */
  export type EnumDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Difficulty'>
    


  /**
   * Reference to a field of type 'EncounterStatus'
   */
  export type EnumEncounterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterStatus'>
    


  /**
   * Reference to a field of type 'ParticipantType'
   */
  export type EnumParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantType'>
    


  /**
   * Reference to a field of type 'BackgroundType'
   */
  export type EnumBackgroundTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackgroundType'>
    


  /**
   * Reference to a field of type 'QuestStatus'
   */
  export type EnumQuestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestStatus'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemRarity'
   */
  export type EnumItemRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRarity'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    
  /**
   * Deep Input Types
   */


  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    coverImagePath?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    lastPlayedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    settings?: JsonNullableFilter<"Campaign">
    npcs?: NPCListRelationFilter
    locations?: LocationListRelationFilter
    maps?: MapListRelationFilter
    encounters?: EncounterListRelationFilter
    playerCharacters?: PlayerCharacterListRelationFilter
    quests?: QuestListRelationFilter
    chronicles?: ChronicleListRelationFilter
    interactions?: InteractionListRelationFilter
    monsterCampaigns?: MonsterCampaignListRelationFilter
    itemCampaigns?: ItemCampaignListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImagePath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    npcs?: NPCOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
    maps?: MapOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
    playerCharacters?: PlayerCharacterOrderByRelationAggregateInput
    quests?: QuestOrderByRelationAggregateInput
    chronicles?: ChronicleOrderByRelationAggregateInput
    interactions?: InteractionOrderByRelationAggregateInput
    monsterCampaigns?: MonsterCampaignOrderByRelationAggregateInput
    itemCampaigns?: ItemCampaignOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    coverImagePath?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    lastPlayedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    settings?: JsonNullableFilter<"Campaign">
    npcs?: NPCListRelationFilter
    locations?: LocationListRelationFilter
    maps?: MapListRelationFilter
    encounters?: EncounterListRelationFilter
    playerCharacters?: PlayerCharacterListRelationFilter
    quests?: QuestListRelationFilter
    chronicles?: ChronicleListRelationFilter
    interactions?: InteractionListRelationFilter
    monsterCampaigns?: MonsterCampaignListRelationFilter
    itemCampaigns?: ItemCampaignListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImagePath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    coverImagePath?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    settings?: JsonNullableWithAggregatesFilter<"Campaign">
  }

  export type NPCWhereInput = {
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    id?: StringFilter<"NPC"> | string
    campaignId?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    title?: StringNullableFilter<"NPC"> | string | null
    race?: EnumRaceNullableFilter<"NPC"> | $Enums.Race | null
    creatureType?: EnumCreatureTypeNullableFilter<"NPC"> | $Enums.CreatureType | null
    role?: EnumNPCRoleNullableFilter<"NPC"> | $Enums.NPCRole | null
    class?: EnumCharacterClassNullableFilter<"NPC"> | $Enums.CharacterClass | null
    alignment?: EnumAlignmentNullableFilter<"NPC"> | $Enums.Alignment | null
    attitudeToParty?: EnumNPCAttitudeNullableFilter<"NPC"> | $Enums.NPCAttitude | null
    languages?: JsonNullableFilter<"NPC">
    appearance?: StringNullableFilter<"NPC"> | string | null
    personality?: StringNullableFilter<"NPC"> | string | null
    motivations?: StringNullableFilter<"NPC"> | string | null
    backstory?: StringNullableFilter<"NPC"> | string | null
    dmNotes?: StringNullableFilter<"NPC"> | string | null
    portraitPath?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    updatedAt?: DateTimeFilter<"NPC"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    locations?: NPCLocationListRelationFilter
    questsGiven?: QuestListRelationFilter
    questsInvolved?: QuestNPCListRelationFilter
    interactions?: InteractionListRelationFilter
    items?: ItemNPCListRelationFilter
  }

  export type NPCOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    title?: SortOrderInput | SortOrder
    race?: SortOrderInput | SortOrder
    creatureType?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    alignment?: SortOrderInput | SortOrder
    attitudeToParty?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    appearance?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    motivations?: SortOrderInput | SortOrder
    backstory?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    portraitPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    locations?: NPCLocationOrderByRelationAggregateInput
    questsGiven?: QuestOrderByRelationAggregateInput
    questsInvolved?: QuestNPCOrderByRelationAggregateInput
    interactions?: InteractionOrderByRelationAggregateInput
    items?: ItemNPCOrderByRelationAggregateInput
  }

  export type NPCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    campaignId?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    title?: StringNullableFilter<"NPC"> | string | null
    race?: EnumRaceNullableFilter<"NPC"> | $Enums.Race | null
    creatureType?: EnumCreatureTypeNullableFilter<"NPC"> | $Enums.CreatureType | null
    role?: EnumNPCRoleNullableFilter<"NPC"> | $Enums.NPCRole | null
    class?: EnumCharacterClassNullableFilter<"NPC"> | $Enums.CharacterClass | null
    alignment?: EnumAlignmentNullableFilter<"NPC"> | $Enums.Alignment | null
    attitudeToParty?: EnumNPCAttitudeNullableFilter<"NPC"> | $Enums.NPCAttitude | null
    languages?: JsonNullableFilter<"NPC">
    appearance?: StringNullableFilter<"NPC"> | string | null
    personality?: StringNullableFilter<"NPC"> | string | null
    motivations?: StringNullableFilter<"NPC"> | string | null
    backstory?: StringNullableFilter<"NPC"> | string | null
    dmNotes?: StringNullableFilter<"NPC"> | string | null
    portraitPath?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    updatedAt?: DateTimeFilter<"NPC"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    locations?: NPCLocationListRelationFilter
    questsGiven?: QuestListRelationFilter
    questsInvolved?: QuestNPCListRelationFilter
    interactions?: InteractionListRelationFilter
    items?: ItemNPCListRelationFilter
  }, "id">

  export type NPCOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    title?: SortOrderInput | SortOrder
    race?: SortOrderInput | SortOrder
    creatureType?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    class?: SortOrderInput | SortOrder
    alignment?: SortOrderInput | SortOrder
    attitudeToParty?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    appearance?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    motivations?: SortOrderInput | SortOrder
    backstory?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    portraitPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NPCCountOrderByAggregateInput
    _max?: NPCMaxOrderByAggregateInput
    _min?: NPCMinOrderByAggregateInput
  }

  export type NPCScalarWhereWithAggregatesInput = {
    AND?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    OR?: NPCScalarWhereWithAggregatesInput[]
    NOT?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NPC"> | string
    campaignId?: StringWithAggregatesFilter<"NPC"> | string
    name?: StringWithAggregatesFilter<"NPC"> | string
    title?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    race?: EnumRaceNullableWithAggregatesFilter<"NPC"> | $Enums.Race | null
    creatureType?: EnumCreatureTypeNullableWithAggregatesFilter<"NPC"> | $Enums.CreatureType | null
    role?: EnumNPCRoleNullableWithAggregatesFilter<"NPC"> | $Enums.NPCRole | null
    class?: EnumCharacterClassNullableWithAggregatesFilter<"NPC"> | $Enums.CharacterClass | null
    alignment?: EnumAlignmentNullableWithAggregatesFilter<"NPC"> | $Enums.Alignment | null
    attitudeToParty?: EnumNPCAttitudeNullableWithAggregatesFilter<"NPC"> | $Enums.NPCAttitude | null
    languages?: JsonNullableWithAggregatesFilter<"NPC">
    appearance?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    personality?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    motivations?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    backstory?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    dmNotes?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    portraitPath?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NPC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NPC"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    campaignId?: StringFilter<"Location"> | string
    parentLocationId?: StringNullableFilter<"Location"> | string | null
    name?: StringFilter<"Location"> | string
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    description?: StringNullableFilter<"Location"> | string | null
    notableFeatures?: JsonNullableFilter<"Location">
    coverImagePath?: StringNullableFilter<"Location"> | string | null
    dmNotes?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    parentLocation?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    childLocations?: LocationListRelationFilter
    maps?: MapListRelationFilter
    encounters?: EncounterListRelationFilter
    npcs?: NPCLocationListRelationFilter
    quests?: QuestLocationListRelationFilter
    items?: ItemLocationListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentLocationId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    notableFeatures?: SortOrderInput | SortOrder
    coverImagePath?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    parentLocation?: LocationOrderByWithRelationInput
    childLocations?: LocationOrderByRelationAggregateInput
    maps?: MapOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
    npcs?: NPCLocationOrderByRelationAggregateInput
    quests?: QuestLocationOrderByRelationAggregateInput
    items?: ItemLocationOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    campaignId?: StringFilter<"Location"> | string
    parentLocationId?: StringNullableFilter<"Location"> | string | null
    name?: StringFilter<"Location"> | string
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    description?: StringNullableFilter<"Location"> | string | null
    notableFeatures?: JsonNullableFilter<"Location">
    coverImagePath?: StringNullableFilter<"Location"> | string | null
    dmNotes?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    parentLocation?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    childLocations?: LocationListRelationFilter
    maps?: MapListRelationFilter
    encounters?: EncounterListRelationFilter
    npcs?: NPCLocationListRelationFilter
    quests?: QuestLocationListRelationFilter
    items?: ItemLocationListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentLocationId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    notableFeatures?: SortOrderInput | SortOrder
    coverImagePath?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    campaignId?: StringWithAggregatesFilter<"Location"> | string
    parentLocationId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    name?: StringWithAggregatesFilter<"Location"> | string
    type?: EnumLocationTypeWithAggregatesFilter<"Location"> | $Enums.LocationType
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    notableFeatures?: JsonNullableWithAggregatesFilter<"Location">
    coverImagePath?: StringNullableWithAggregatesFilter<"Location"> | string | null
    dmNotes?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type MapWhereInput = {
    AND?: MapWhereInput | MapWhereInput[]
    OR?: MapWhereInput[]
    NOT?: MapWhereInput | MapWhereInput[]
    id?: StringFilter<"Map"> | string
    campaignId?: StringFilter<"Map"> | string
    locationId?: StringNullableFilter<"Map"> | string | null
    name?: StringFilter<"Map"> | string
    imagePath?: StringFilter<"Map"> | string
    gridSize?: IntNullableFilter<"Map"> | number | null
    gridEnabled?: BoolFilter<"Map"> | boolean
    scale?: StringNullableFilter<"Map"> | string | null
    width?: IntNullableFilter<"Map"> | number | null
    height?: IntNullableFilter<"Map"> | number | null
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    annotations?: MapAnnotationListRelationFilter
    encounters?: EncounterListRelationFilter
  }

  export type MapOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    gridSize?: SortOrderInput | SortOrder
    gridEnabled?: SortOrder
    scale?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    annotations?: MapAnnotationOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
  }

  export type MapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MapWhereInput | MapWhereInput[]
    OR?: MapWhereInput[]
    NOT?: MapWhereInput | MapWhereInput[]
    campaignId?: StringFilter<"Map"> | string
    locationId?: StringNullableFilter<"Map"> | string | null
    name?: StringFilter<"Map"> | string
    imagePath?: StringFilter<"Map"> | string
    gridSize?: IntNullableFilter<"Map"> | number | null
    gridEnabled?: BoolFilter<"Map"> | boolean
    scale?: StringNullableFilter<"Map"> | string | null
    width?: IntNullableFilter<"Map"> | number | null
    height?: IntNullableFilter<"Map"> | number | null
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    annotations?: MapAnnotationListRelationFilter
    encounters?: EncounterListRelationFilter
  }, "id">

  export type MapOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locationId?: SortOrderInput | SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    gridSize?: SortOrderInput | SortOrder
    gridEnabled?: SortOrder
    scale?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MapCountOrderByAggregateInput
    _avg?: MapAvgOrderByAggregateInput
    _max?: MapMaxOrderByAggregateInput
    _min?: MapMinOrderByAggregateInput
    _sum?: MapSumOrderByAggregateInput
  }

  export type MapScalarWhereWithAggregatesInput = {
    AND?: MapScalarWhereWithAggregatesInput | MapScalarWhereWithAggregatesInput[]
    OR?: MapScalarWhereWithAggregatesInput[]
    NOT?: MapScalarWhereWithAggregatesInput | MapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Map"> | string
    campaignId?: StringWithAggregatesFilter<"Map"> | string
    locationId?: StringNullableWithAggregatesFilter<"Map"> | string | null
    name?: StringWithAggregatesFilter<"Map"> | string
    imagePath?: StringWithAggregatesFilter<"Map"> | string
    gridSize?: IntNullableWithAggregatesFilter<"Map"> | number | null
    gridEnabled?: BoolWithAggregatesFilter<"Map"> | boolean
    scale?: StringNullableWithAggregatesFilter<"Map"> | string | null
    width?: IntNullableWithAggregatesFilter<"Map"> | number | null
    height?: IntNullableWithAggregatesFilter<"Map"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Map"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Map"> | Date | string
  }

  export type MapAnnotationWhereInput = {
    AND?: MapAnnotationWhereInput | MapAnnotationWhereInput[]
    OR?: MapAnnotationWhereInput[]
    NOT?: MapAnnotationWhereInput | MapAnnotationWhereInput[]
    id?: StringFilter<"MapAnnotation"> | string
    mapId?: StringFilter<"MapAnnotation"> | string
    type?: EnumMapAnnotationTypeFilter<"MapAnnotation"> | $Enums.MapAnnotationType
    x?: FloatFilter<"MapAnnotation"> | number
    y?: FloatFilter<"MapAnnotation"> | number
    title?: StringNullableFilter<"MapAnnotation"> | string | null
    content?: StringNullableFilter<"MapAnnotation"> | string | null
    isHidden?: BoolFilter<"MapAnnotation"> | boolean
    map?: XOR<MapScalarRelationFilter, MapWhereInput>
  }

  export type MapAnnotationOrderByWithRelationInput = {
    id?: SortOrder
    mapId?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    isHidden?: SortOrder
    map?: MapOrderByWithRelationInput
  }

  export type MapAnnotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MapAnnotationWhereInput | MapAnnotationWhereInput[]
    OR?: MapAnnotationWhereInput[]
    NOT?: MapAnnotationWhereInput | MapAnnotationWhereInput[]
    mapId?: StringFilter<"MapAnnotation"> | string
    type?: EnumMapAnnotationTypeFilter<"MapAnnotation"> | $Enums.MapAnnotationType
    x?: FloatFilter<"MapAnnotation"> | number
    y?: FloatFilter<"MapAnnotation"> | number
    title?: StringNullableFilter<"MapAnnotation"> | string | null
    content?: StringNullableFilter<"MapAnnotation"> | string | null
    isHidden?: BoolFilter<"MapAnnotation"> | boolean
    map?: XOR<MapScalarRelationFilter, MapWhereInput>
  }, "id">

  export type MapAnnotationOrderByWithAggregationInput = {
    id?: SortOrder
    mapId?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    isHidden?: SortOrder
    _count?: MapAnnotationCountOrderByAggregateInput
    _avg?: MapAnnotationAvgOrderByAggregateInput
    _max?: MapAnnotationMaxOrderByAggregateInput
    _min?: MapAnnotationMinOrderByAggregateInput
    _sum?: MapAnnotationSumOrderByAggregateInput
  }

  export type MapAnnotationScalarWhereWithAggregatesInput = {
    AND?: MapAnnotationScalarWhereWithAggregatesInput | MapAnnotationScalarWhereWithAggregatesInput[]
    OR?: MapAnnotationScalarWhereWithAggregatesInput[]
    NOT?: MapAnnotationScalarWhereWithAggregatesInput | MapAnnotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MapAnnotation"> | string
    mapId?: StringWithAggregatesFilter<"MapAnnotation"> | string
    type?: EnumMapAnnotationTypeWithAggregatesFilter<"MapAnnotation"> | $Enums.MapAnnotationType
    x?: FloatWithAggregatesFilter<"MapAnnotation"> | number
    y?: FloatWithAggregatesFilter<"MapAnnotation"> | number
    title?: StringNullableWithAggregatesFilter<"MapAnnotation"> | string | null
    content?: StringNullableWithAggregatesFilter<"MapAnnotation"> | string | null
    isHidden?: BoolWithAggregatesFilter<"MapAnnotation"> | boolean
  }

  export type MonsterWhereInput = {
    AND?: MonsterWhereInput | MonsterWhereInput[]
    OR?: MonsterWhereInput[]
    NOT?: MonsterWhereInput | MonsterWhereInput[]
    id?: StringFilter<"Monster"> | string
    name?: StringFilter<"Monster"> | string
    size?: EnumSizeFilter<"Monster"> | $Enums.Size
    creatureType?: EnumCreatureTypeFilter<"Monster"> | $Enums.CreatureType
    alignment?: EnumAlignmentFilter<"Monster"> | $Enums.Alignment
    portraitPath?: StringNullableFilter<"Monster"> | string | null
    hpMax?: IntFilter<"Monster"> | number
    hpDice?: StringNullableFilter<"Monster"> | string | null
    ac?: IntFilter<"Monster"> | number
    acDescription?: StringNullableFilter<"Monster"> | string | null
    speed?: JsonFilter<"Monster">
    abilities?: JsonFilter<"Monster">
    savingThrows?: JsonNullableFilter<"Monster">
    skills?: JsonNullableFilter<"Monster">
    damageResistances?: JsonNullableFilter<"Monster">
    damageImmunities?: JsonNullableFilter<"Monster">
    conditionImmunities?: JsonNullableFilter<"Monster">
    senses?: StringNullableFilter<"Monster"> | string | null
    languages?: JsonNullableFilter<"Monster">
    challengeRating?: FloatFilter<"Monster"> | number
    actions?: JsonNullableFilter<"Monster">
    reactions?: JsonNullableFilter<"Monster">
    legendaryActions?: JsonNullableFilter<"Monster">
    description?: StringNullableFilter<"Monster"> | string | null
    dmNotes?: StringNullableFilter<"Monster"> | string | null
    isTemplate?: BoolFilter<"Monster"> | boolean
    createdAt?: DateTimeFilter<"Monster"> | Date | string
    updatedAt?: DateTimeFilter<"Monster"> | Date | string
    campaigns?: MonsterCampaignListRelationFilter
    encounterParticipants?: EncounterParticipantListRelationFilter
  }

  export type MonsterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    size?: SortOrder
    creatureType?: SortOrder
    alignment?: SortOrder
    portraitPath?: SortOrderInput | SortOrder
    hpMax?: SortOrder
    hpDice?: SortOrderInput | SortOrder
    ac?: SortOrder
    acDescription?: SortOrderInput | SortOrder
    speed?: SortOrder
    abilities?: SortOrder
    savingThrows?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    damageResistances?: SortOrderInput | SortOrder
    damageImmunities?: SortOrderInput | SortOrder
    conditionImmunities?: SortOrderInput | SortOrder
    senses?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    challengeRating?: SortOrder
    actions?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    legendaryActions?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaigns?: MonsterCampaignOrderByRelationAggregateInput
    encounterParticipants?: EncounterParticipantOrderByRelationAggregateInput
  }

  export type MonsterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MonsterWhereInput | MonsterWhereInput[]
    OR?: MonsterWhereInput[]
    NOT?: MonsterWhereInput | MonsterWhereInput[]
    name?: StringFilter<"Monster"> | string
    size?: EnumSizeFilter<"Monster"> | $Enums.Size
    creatureType?: EnumCreatureTypeFilter<"Monster"> | $Enums.CreatureType
    alignment?: EnumAlignmentFilter<"Monster"> | $Enums.Alignment
    portraitPath?: StringNullableFilter<"Monster"> | string | null
    hpMax?: IntFilter<"Monster"> | number
    hpDice?: StringNullableFilter<"Monster"> | string | null
    ac?: IntFilter<"Monster"> | number
    acDescription?: StringNullableFilter<"Monster"> | string | null
    speed?: JsonFilter<"Monster">
    abilities?: JsonFilter<"Monster">
    savingThrows?: JsonNullableFilter<"Monster">
    skills?: JsonNullableFilter<"Monster">
    damageResistances?: JsonNullableFilter<"Monster">
    damageImmunities?: JsonNullableFilter<"Monster">
    conditionImmunities?: JsonNullableFilter<"Monster">
    senses?: StringNullableFilter<"Monster"> | string | null
    languages?: JsonNullableFilter<"Monster">
    challengeRating?: FloatFilter<"Monster"> | number
    actions?: JsonNullableFilter<"Monster">
    reactions?: JsonNullableFilter<"Monster">
    legendaryActions?: JsonNullableFilter<"Monster">
    description?: StringNullableFilter<"Monster"> | string | null
    dmNotes?: StringNullableFilter<"Monster"> | string | null
    isTemplate?: BoolFilter<"Monster"> | boolean
    createdAt?: DateTimeFilter<"Monster"> | Date | string
    updatedAt?: DateTimeFilter<"Monster"> | Date | string
    campaigns?: MonsterCampaignListRelationFilter
    encounterParticipants?: EncounterParticipantListRelationFilter
  }, "id">

  export type MonsterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    size?: SortOrder
    creatureType?: SortOrder
    alignment?: SortOrder
    portraitPath?: SortOrderInput | SortOrder
    hpMax?: SortOrder
    hpDice?: SortOrderInput | SortOrder
    ac?: SortOrder
    acDescription?: SortOrderInput | SortOrder
    speed?: SortOrder
    abilities?: SortOrder
    savingThrows?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    damageResistances?: SortOrderInput | SortOrder
    damageImmunities?: SortOrderInput | SortOrder
    conditionImmunities?: SortOrderInput | SortOrder
    senses?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    challengeRating?: SortOrder
    actions?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    legendaryActions?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MonsterCountOrderByAggregateInput
    _avg?: MonsterAvgOrderByAggregateInput
    _max?: MonsterMaxOrderByAggregateInput
    _min?: MonsterMinOrderByAggregateInput
    _sum?: MonsterSumOrderByAggregateInput
  }

  export type MonsterScalarWhereWithAggregatesInput = {
    AND?: MonsterScalarWhereWithAggregatesInput | MonsterScalarWhereWithAggregatesInput[]
    OR?: MonsterScalarWhereWithAggregatesInput[]
    NOT?: MonsterScalarWhereWithAggregatesInput | MonsterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Monster"> | string
    name?: StringWithAggregatesFilter<"Monster"> | string
    size?: EnumSizeWithAggregatesFilter<"Monster"> | $Enums.Size
    creatureType?: EnumCreatureTypeWithAggregatesFilter<"Monster"> | $Enums.CreatureType
    alignment?: EnumAlignmentWithAggregatesFilter<"Monster"> | $Enums.Alignment
    portraitPath?: StringNullableWithAggregatesFilter<"Monster"> | string | null
    hpMax?: IntWithAggregatesFilter<"Monster"> | number
    hpDice?: StringNullableWithAggregatesFilter<"Monster"> | string | null
    ac?: IntWithAggregatesFilter<"Monster"> | number
    acDescription?: StringNullableWithAggregatesFilter<"Monster"> | string | null
    speed?: JsonWithAggregatesFilter<"Monster">
    abilities?: JsonWithAggregatesFilter<"Monster">
    savingThrows?: JsonNullableWithAggregatesFilter<"Monster">
    skills?: JsonNullableWithAggregatesFilter<"Monster">
    damageResistances?: JsonNullableWithAggregatesFilter<"Monster">
    damageImmunities?: JsonNullableWithAggregatesFilter<"Monster">
    conditionImmunities?: JsonNullableWithAggregatesFilter<"Monster">
    senses?: StringNullableWithAggregatesFilter<"Monster"> | string | null
    languages?: JsonNullableWithAggregatesFilter<"Monster">
    challengeRating?: FloatWithAggregatesFilter<"Monster"> | number
    actions?: JsonNullableWithAggregatesFilter<"Monster">
    reactions?: JsonNullableWithAggregatesFilter<"Monster">
    legendaryActions?: JsonNullableWithAggregatesFilter<"Monster">
    description?: StringNullableWithAggregatesFilter<"Monster"> | string | null
    dmNotes?: StringNullableWithAggregatesFilter<"Monster"> | string | null
    isTemplate?: BoolWithAggregatesFilter<"Monster"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Monster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Monster"> | Date | string
  }

  export type ConditionWhereInput = {
    AND?: ConditionWhereInput | ConditionWhereInput[]
    OR?: ConditionWhereInput[]
    NOT?: ConditionWhereInput | ConditionWhereInput[]
    id?: StringFilter<"Condition"> | string
    name?: StringFilter<"Condition"> | string
    icon?: StringNullableFilter<"Condition"> | string | null
    description?: StringNullableFilter<"Condition"> | string | null
    mechanicalEffects?: StringNullableFilter<"Condition"> | string | null
    isCustom?: BoolFilter<"Condition"> | boolean
  }

  export type ConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    mechanicalEffects?: SortOrderInput | SortOrder
    isCustom?: SortOrder
  }

  export type ConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ConditionWhereInput | ConditionWhereInput[]
    OR?: ConditionWhereInput[]
    NOT?: ConditionWhereInput | ConditionWhereInput[]
    icon?: StringNullableFilter<"Condition"> | string | null
    description?: StringNullableFilter<"Condition"> | string | null
    mechanicalEffects?: StringNullableFilter<"Condition"> | string | null
    isCustom?: BoolFilter<"Condition"> | boolean
  }, "id" | "name">

  export type ConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    mechanicalEffects?: SortOrderInput | SortOrder
    isCustom?: SortOrder
    _count?: ConditionCountOrderByAggregateInput
    _max?: ConditionMaxOrderByAggregateInput
    _min?: ConditionMinOrderByAggregateInput
  }

  export type ConditionScalarWhereWithAggregatesInput = {
    AND?: ConditionScalarWhereWithAggregatesInput | ConditionScalarWhereWithAggregatesInput[]
    OR?: ConditionScalarWhereWithAggregatesInput[]
    NOT?: ConditionScalarWhereWithAggregatesInput | ConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Condition"> | string
    name?: StringWithAggregatesFilter<"Condition"> | string
    icon?: StringNullableWithAggregatesFilter<"Condition"> | string | null
    description?: StringNullableWithAggregatesFilter<"Condition"> | string | null
    mechanicalEffects?: StringNullableWithAggregatesFilter<"Condition"> | string | null
    isCustom?: BoolWithAggregatesFilter<"Condition"> | boolean
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    campaignId?: StringFilter<"Encounter"> | string
    mapId?: StringNullableFilter<"Encounter"> | string | null
    locationId?: StringNullableFilter<"Encounter"> | string | null
    name?: StringFilter<"Encounter"> | string
    description?: StringNullableFilter<"Encounter"> | string | null
    difficulty?: EnumDifficultyFilter<"Encounter"> | $Enums.Difficulty
    status?: EnumEncounterStatusFilter<"Encounter"> | $Enums.EncounterStatus
    dmNotes?: StringNullableFilter<"Encounter"> | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    startedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    map?: XOR<MapNullableScalarRelationFilter, MapWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    participants?: EncounterParticipantListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mapId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    map?: MapOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    participants?: EncounterParticipantOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    campaignId?: StringFilter<"Encounter"> | string
    mapId?: StringNullableFilter<"Encounter"> | string | null
    locationId?: StringNullableFilter<"Encounter"> | string | null
    name?: StringFilter<"Encounter"> | string
    description?: StringNullableFilter<"Encounter"> | string | null
    difficulty?: EnumDifficultyFilter<"Encounter"> | $Enums.Difficulty
    status?: EnumEncounterStatusFilter<"Encounter"> | $Enums.EncounterStatus
    dmNotes?: StringNullableFilter<"Encounter"> | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    startedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    map?: XOR<MapNullableScalarRelationFilter, MapWhereInput> | null
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    participants?: EncounterParticipantListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mapId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    campaignId?: StringWithAggregatesFilter<"Encounter"> | string
    mapId?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    name?: StringWithAggregatesFilter<"Encounter"> | string
    description?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    difficulty?: EnumDifficultyWithAggregatesFilter<"Encounter"> | $Enums.Difficulty
    status?: EnumEncounterStatusWithAggregatesFilter<"Encounter"> | $Enums.EncounterStatus
    dmNotes?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
  }

  export type EncounterParticipantWhereInput = {
    AND?: EncounterParticipantWhereInput | EncounterParticipantWhereInput[]
    OR?: EncounterParticipantWhereInput[]
    NOT?: EncounterParticipantWhereInput | EncounterParticipantWhereInput[]
    id?: StringFilter<"EncounterParticipant"> | string
    encounterId?: StringFilter<"EncounterParticipant"> | string
    participantType?: EnumParticipantTypeFilter<"EncounterParticipant"> | $Enums.ParticipantType
    monsterId?: StringNullableFilter<"EncounterParticipant"> | string | null
    playerCharacterId?: StringNullableFilter<"EncounterParticipant"> | string | null
    customName?: StringNullableFilter<"EncounterParticipant"> | string | null
    initiative?: IntNullableFilter<"EncounterParticipant"> | number | null
    hpCurrent?: IntFilter<"EncounterParticipant"> | number
    hpMax?: IntFilter<"EncounterParticipant"> | number
    ac?: IntFilter<"EncounterParticipant"> | number
    conditions?: JsonNullableFilter<"EncounterParticipant">
    positionX?: FloatNullableFilter<"EncounterParticipant"> | number | null
    positionY?: FloatNullableFilter<"EncounterParticipant"> | number | null
    isVisible?: BoolFilter<"EncounterParticipant"> | boolean
    dmNotes?: StringNullableFilter<"EncounterParticipant"> | string | null
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    monster?: XOR<MonsterNullableScalarRelationFilter, MonsterWhereInput> | null
    playerCharacter?: XOR<PlayerCharacterNullableScalarRelationFilter, PlayerCharacterWhereInput> | null
  }

  export type EncounterParticipantOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    participantType?: SortOrder
    monsterId?: SortOrderInput | SortOrder
    playerCharacterId?: SortOrderInput | SortOrder
    customName?: SortOrderInput | SortOrder
    initiative?: SortOrderInput | SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    conditions?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    encounter?: EncounterOrderByWithRelationInput
    monster?: MonsterOrderByWithRelationInput
    playerCharacter?: PlayerCharacterOrderByWithRelationInput
  }

  export type EncounterParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncounterParticipantWhereInput | EncounterParticipantWhereInput[]
    OR?: EncounterParticipantWhereInput[]
    NOT?: EncounterParticipantWhereInput | EncounterParticipantWhereInput[]
    encounterId?: StringFilter<"EncounterParticipant"> | string
    participantType?: EnumParticipantTypeFilter<"EncounterParticipant"> | $Enums.ParticipantType
    monsterId?: StringNullableFilter<"EncounterParticipant"> | string | null
    playerCharacterId?: StringNullableFilter<"EncounterParticipant"> | string | null
    customName?: StringNullableFilter<"EncounterParticipant"> | string | null
    initiative?: IntNullableFilter<"EncounterParticipant"> | number | null
    hpCurrent?: IntFilter<"EncounterParticipant"> | number
    hpMax?: IntFilter<"EncounterParticipant"> | number
    ac?: IntFilter<"EncounterParticipant"> | number
    conditions?: JsonNullableFilter<"EncounterParticipant">
    positionX?: FloatNullableFilter<"EncounterParticipant"> | number | null
    positionY?: FloatNullableFilter<"EncounterParticipant"> | number | null
    isVisible?: BoolFilter<"EncounterParticipant"> | boolean
    dmNotes?: StringNullableFilter<"EncounterParticipant"> | string | null
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    monster?: XOR<MonsterNullableScalarRelationFilter, MonsterWhereInput> | null
    playerCharacter?: XOR<PlayerCharacterNullableScalarRelationFilter, PlayerCharacterWhereInput> | null
  }, "id">

  export type EncounterParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    participantType?: SortOrder
    monsterId?: SortOrderInput | SortOrder
    playerCharacterId?: SortOrderInput | SortOrder
    customName?: SortOrderInput | SortOrder
    initiative?: SortOrderInput | SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    conditions?: SortOrderInput | SortOrder
    positionX?: SortOrderInput | SortOrder
    positionY?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    _count?: EncounterParticipantCountOrderByAggregateInput
    _avg?: EncounterParticipantAvgOrderByAggregateInput
    _max?: EncounterParticipantMaxOrderByAggregateInput
    _min?: EncounterParticipantMinOrderByAggregateInput
    _sum?: EncounterParticipantSumOrderByAggregateInput
  }

  export type EncounterParticipantScalarWhereWithAggregatesInput = {
    AND?: EncounterParticipantScalarWhereWithAggregatesInput | EncounterParticipantScalarWhereWithAggregatesInput[]
    OR?: EncounterParticipantScalarWhereWithAggregatesInput[]
    NOT?: EncounterParticipantScalarWhereWithAggregatesInput | EncounterParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EncounterParticipant"> | string
    encounterId?: StringWithAggregatesFilter<"EncounterParticipant"> | string
    participantType?: EnumParticipantTypeWithAggregatesFilter<"EncounterParticipant"> | $Enums.ParticipantType
    monsterId?: StringNullableWithAggregatesFilter<"EncounterParticipant"> | string | null
    playerCharacterId?: StringNullableWithAggregatesFilter<"EncounterParticipant"> | string | null
    customName?: StringNullableWithAggregatesFilter<"EncounterParticipant"> | string | null
    initiative?: IntNullableWithAggregatesFilter<"EncounterParticipant"> | number | null
    hpCurrent?: IntWithAggregatesFilter<"EncounterParticipant"> | number
    hpMax?: IntWithAggregatesFilter<"EncounterParticipant"> | number
    ac?: IntWithAggregatesFilter<"EncounterParticipant"> | number
    conditions?: JsonNullableWithAggregatesFilter<"EncounterParticipant">
    positionX?: FloatNullableWithAggregatesFilter<"EncounterParticipant"> | number | null
    positionY?: FloatNullableWithAggregatesFilter<"EncounterParticipant"> | number | null
    isVisible?: BoolWithAggregatesFilter<"EncounterParticipant"> | boolean
    dmNotes?: StringNullableWithAggregatesFilter<"EncounterParticipant"> | string | null
  }

  export type PlayerCharacterWhereInput = {
    AND?: PlayerCharacterWhereInput | PlayerCharacterWhereInput[]
    OR?: PlayerCharacterWhereInput[]
    NOT?: PlayerCharacterWhereInput | PlayerCharacterWhereInput[]
    id?: StringFilter<"PlayerCharacter"> | string
    campaignId?: StringFilter<"PlayerCharacter"> | string
    playerName?: StringFilter<"PlayerCharacter"> | string
    characterName?: StringFilter<"PlayerCharacter"> | string
    race?: EnumRaceFilter<"PlayerCharacter"> | $Enums.Race
    class?: EnumCharacterClassFilter<"PlayerCharacter"> | $Enums.CharacterClass
    level?: IntFilter<"PlayerCharacter"> | number
    alignment?: EnumAlignmentFilter<"PlayerCharacter"> | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFilter<"PlayerCharacter"> | $Enums.BackgroundType
    background?: StringNullableFilter<"PlayerCharacter"> | string | null
    languages?: JsonNullableFilter<"PlayerCharacter">
    portraitPath?: StringNullableFilter<"PlayerCharacter"> | string | null
    hpMax?: IntFilter<"PlayerCharacter"> | number
    ac?: IntFilter<"PlayerCharacter"> | number
    passivePerception?: IntFilter<"PlayerCharacter"> | number
    isActive?: BoolFilter<"PlayerCharacter"> | boolean
    createdAt?: DateTimeFilter<"PlayerCharacter"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCharacter"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    encounterParticipants?: EncounterParticipantListRelationFilter
  }

  export type PlayerCharacterOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    playerName?: SortOrder
    characterName?: SortOrder
    race?: SortOrder
    class?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    backgroundType?: SortOrder
    background?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    portraitPath?: SortOrderInput | SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    encounterParticipants?: EncounterParticipantOrderByRelationAggregateInput
  }

  export type PlayerCharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayerCharacterWhereInput | PlayerCharacterWhereInput[]
    OR?: PlayerCharacterWhereInput[]
    NOT?: PlayerCharacterWhereInput | PlayerCharacterWhereInput[]
    campaignId?: StringFilter<"PlayerCharacter"> | string
    playerName?: StringFilter<"PlayerCharacter"> | string
    characterName?: StringFilter<"PlayerCharacter"> | string
    race?: EnumRaceFilter<"PlayerCharacter"> | $Enums.Race
    class?: EnumCharacterClassFilter<"PlayerCharacter"> | $Enums.CharacterClass
    level?: IntFilter<"PlayerCharacter"> | number
    alignment?: EnumAlignmentFilter<"PlayerCharacter"> | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFilter<"PlayerCharacter"> | $Enums.BackgroundType
    background?: StringNullableFilter<"PlayerCharacter"> | string | null
    languages?: JsonNullableFilter<"PlayerCharacter">
    portraitPath?: StringNullableFilter<"PlayerCharacter"> | string | null
    hpMax?: IntFilter<"PlayerCharacter"> | number
    ac?: IntFilter<"PlayerCharacter"> | number
    passivePerception?: IntFilter<"PlayerCharacter"> | number
    isActive?: BoolFilter<"PlayerCharacter"> | boolean
    createdAt?: DateTimeFilter<"PlayerCharacter"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCharacter"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    encounterParticipants?: EncounterParticipantListRelationFilter
  }, "id">

  export type PlayerCharacterOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    playerName?: SortOrder
    characterName?: SortOrder
    race?: SortOrder
    class?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    backgroundType?: SortOrder
    background?: SortOrderInput | SortOrder
    languages?: SortOrderInput | SortOrder
    portraitPath?: SortOrderInput | SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCharacterCountOrderByAggregateInput
    _avg?: PlayerCharacterAvgOrderByAggregateInput
    _max?: PlayerCharacterMaxOrderByAggregateInput
    _min?: PlayerCharacterMinOrderByAggregateInput
    _sum?: PlayerCharacterSumOrderByAggregateInput
  }

  export type PlayerCharacterScalarWhereWithAggregatesInput = {
    AND?: PlayerCharacterScalarWhereWithAggregatesInput | PlayerCharacterScalarWhereWithAggregatesInput[]
    OR?: PlayerCharacterScalarWhereWithAggregatesInput[]
    NOT?: PlayerCharacterScalarWhereWithAggregatesInput | PlayerCharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerCharacter"> | string
    campaignId?: StringWithAggregatesFilter<"PlayerCharacter"> | string
    playerName?: StringWithAggregatesFilter<"PlayerCharacter"> | string
    characterName?: StringWithAggregatesFilter<"PlayerCharacter"> | string
    race?: EnumRaceWithAggregatesFilter<"PlayerCharacter"> | $Enums.Race
    class?: EnumCharacterClassWithAggregatesFilter<"PlayerCharacter"> | $Enums.CharacterClass
    level?: IntWithAggregatesFilter<"PlayerCharacter"> | number
    alignment?: EnumAlignmentWithAggregatesFilter<"PlayerCharacter"> | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeWithAggregatesFilter<"PlayerCharacter"> | $Enums.BackgroundType
    background?: StringNullableWithAggregatesFilter<"PlayerCharacter"> | string | null
    languages?: JsonNullableWithAggregatesFilter<"PlayerCharacter">
    portraitPath?: StringNullableWithAggregatesFilter<"PlayerCharacter"> | string | null
    hpMax?: IntWithAggregatesFilter<"PlayerCharacter"> | number
    ac?: IntWithAggregatesFilter<"PlayerCharacter"> | number
    passivePerception?: IntWithAggregatesFilter<"PlayerCharacter"> | number
    isActive?: BoolWithAggregatesFilter<"PlayerCharacter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlayerCharacter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlayerCharacter"> | Date | string
  }

  export type QuestWhereInput = {
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    id?: StringFilter<"Quest"> | string
    campaignId?: StringFilter<"Quest"> | string
    parentQuestId?: StringNullableFilter<"Quest"> | string | null
    name?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    objectives?: JsonNullableFilter<"Quest">
    status?: EnumQuestStatusFilter<"Quest"> | $Enums.QuestStatus
    questGiverNpcId?: StringNullableFilter<"Quest"> | string | null
    rewardDescription?: StringNullableFilter<"Quest"> | string | null
    rewardItems?: JsonNullableFilter<"Quest">
    isMilestone?: BoolFilter<"Quest"> | boolean
    dmNotes?: StringNullableFilter<"Quest"> | string | null
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    startedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    parentQuest?: XOR<QuestNullableScalarRelationFilter, QuestWhereInput> | null
    subQuests?: QuestListRelationFilter
    questGiver?: XOR<NPCNullableScalarRelationFilter, NPCWhereInput> | null
    npcs?: QuestNPCListRelationFilter
    locations?: QuestLocationListRelationFilter
    chronicles?: ChronicleQuestListRelationFilter
  }

  export type QuestOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentQuestId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    status?: SortOrder
    questGiverNpcId?: SortOrderInput | SortOrder
    rewardDescription?: SortOrderInput | SortOrder
    rewardItems?: SortOrderInput | SortOrder
    isMilestone?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    parentQuest?: QuestOrderByWithRelationInput
    subQuests?: QuestOrderByRelationAggregateInput
    questGiver?: NPCOrderByWithRelationInput
    npcs?: QuestNPCOrderByRelationAggregateInput
    locations?: QuestLocationOrderByRelationAggregateInput
    chronicles?: ChronicleQuestOrderByRelationAggregateInput
  }

  export type QuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestWhereInput | QuestWhereInput[]
    OR?: QuestWhereInput[]
    NOT?: QuestWhereInput | QuestWhereInput[]
    campaignId?: StringFilter<"Quest"> | string
    parentQuestId?: StringNullableFilter<"Quest"> | string | null
    name?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    objectives?: JsonNullableFilter<"Quest">
    status?: EnumQuestStatusFilter<"Quest"> | $Enums.QuestStatus
    questGiverNpcId?: StringNullableFilter<"Quest"> | string | null
    rewardDescription?: StringNullableFilter<"Quest"> | string | null
    rewardItems?: JsonNullableFilter<"Quest">
    isMilestone?: BoolFilter<"Quest"> | boolean
    dmNotes?: StringNullableFilter<"Quest"> | string | null
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    startedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    parentQuest?: XOR<QuestNullableScalarRelationFilter, QuestWhereInput> | null
    subQuests?: QuestListRelationFilter
    questGiver?: XOR<NPCNullableScalarRelationFilter, NPCWhereInput> | null
    npcs?: QuestNPCListRelationFilter
    locations?: QuestLocationListRelationFilter
    chronicles?: ChronicleQuestListRelationFilter
  }, "id">

  export type QuestOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentQuestId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objectives?: SortOrderInput | SortOrder
    status?: SortOrder
    questGiverNpcId?: SortOrderInput | SortOrder
    rewardDescription?: SortOrderInput | SortOrder
    rewardItems?: SortOrderInput | SortOrder
    isMilestone?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: QuestCountOrderByAggregateInput
    _max?: QuestMaxOrderByAggregateInput
    _min?: QuestMinOrderByAggregateInput
  }

  export type QuestScalarWhereWithAggregatesInput = {
    AND?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    OR?: QuestScalarWhereWithAggregatesInput[]
    NOT?: QuestScalarWhereWithAggregatesInput | QuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quest"> | string
    campaignId?: StringWithAggregatesFilter<"Quest"> | string
    parentQuestId?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    name?: StringWithAggregatesFilter<"Quest"> | string
    description?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    objectives?: JsonNullableWithAggregatesFilter<"Quest">
    status?: EnumQuestStatusWithAggregatesFilter<"Quest"> | $Enums.QuestStatus
    questGiverNpcId?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    rewardDescription?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    rewardItems?: JsonNullableWithAggregatesFilter<"Quest">
    isMilestone?: BoolWithAggregatesFilter<"Quest"> | boolean
    dmNotes?: StringNullableWithAggregatesFilter<"Quest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quest"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Quest"> | Date | string | null
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    rarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    description?: StringNullableFilter<"Item"> | string | null
    mechanicalEffects?: StringNullableFilter<"Item"> | string | null
    grantedAbilities?: JsonNullableFilter<"Item">
    value?: StringNullableFilter<"Item"> | string | null
    weight?: FloatNullableFilter<"Item"> | number | null
    quantity?: IntFilter<"Item"> | number
    isMagical?: BoolFilter<"Item"> | boolean
    attunementRequired?: BoolFilter<"Item"> | boolean
    dmNotes?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    campaigns?: ItemCampaignListRelationFilter
    locations?: ItemLocationListRelationFilter
    npcs?: ItemNPCListRelationFilter
    interactions?: InteractionItemListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    description?: SortOrderInput | SortOrder
    mechanicalEffects?: SortOrderInput | SortOrder
    grantedAbilities?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    quantity?: SortOrder
    isMagical?: SortOrder
    attunementRequired?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaigns?: ItemCampaignOrderByRelationAggregateInput
    locations?: ItemLocationOrderByRelationAggregateInput
    npcs?: ItemNPCOrderByRelationAggregateInput
    interactions?: InteractionItemOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    rarity?: EnumItemRarityFilter<"Item"> | $Enums.ItemRarity
    description?: StringNullableFilter<"Item"> | string | null
    mechanicalEffects?: StringNullableFilter<"Item"> | string | null
    grantedAbilities?: JsonNullableFilter<"Item">
    value?: StringNullableFilter<"Item"> | string | null
    weight?: FloatNullableFilter<"Item"> | number | null
    quantity?: IntFilter<"Item"> | number
    isMagical?: BoolFilter<"Item"> | boolean
    attunementRequired?: BoolFilter<"Item"> | boolean
    dmNotes?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    campaigns?: ItemCampaignListRelationFilter
    locations?: ItemLocationListRelationFilter
    npcs?: ItemNPCListRelationFilter
    interactions?: InteractionItemListRelationFilter
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    description?: SortOrderInput | SortOrder
    mechanicalEffects?: SortOrderInput | SortOrder
    grantedAbilities?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    quantity?: SortOrder
    isMagical?: SortOrder
    attunementRequired?: SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    type?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    rarity?: EnumItemRarityWithAggregatesFilter<"Item"> | $Enums.ItemRarity
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    mechanicalEffects?: StringNullableWithAggregatesFilter<"Item"> | string | null
    grantedAbilities?: JsonNullableWithAggregatesFilter<"Item">
    value?: StringNullableWithAggregatesFilter<"Item"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    quantity?: IntWithAggregatesFilter<"Item"> | number
    isMagical?: BoolWithAggregatesFilter<"Item"> | boolean
    attunementRequired?: BoolWithAggregatesFilter<"Item"> | boolean
    dmNotes?: StringNullableWithAggregatesFilter<"Item"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type ChronicleWhereInput = {
    AND?: ChronicleWhereInput | ChronicleWhereInput[]
    OR?: ChronicleWhereInput[]
    NOT?: ChronicleWhereInput | ChronicleWhereInput[]
    id?: StringFilter<"Chronicle"> | string
    campaignId?: StringFilter<"Chronicle"> | string
    sessionNumber?: IntFilter<"Chronicle"> | number
    sessionDate?: DateTimeFilter<"Chronicle"> | Date | string
    title?: StringNullableFilter<"Chronicle"> | string | null
    summary?: StringNullableFilter<"Chronicle"> | string | null
    playerDeeds?: JsonNullableFilter<"Chronicle">
    importantDecisions?: JsonNullableFilter<"Chronicle">
    dmNotes?: StringNullableFilter<"Chronicle"> | string | null
    createdAt?: DateTimeFilter<"Chronicle"> | Date | string
    updatedAt?: DateTimeFilter<"Chronicle"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    quests?: ChronicleQuestListRelationFilter
  }

  export type ChronicleOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sessionNumber?: SortOrder
    sessionDate?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    playerDeeds?: SortOrderInput | SortOrder
    importantDecisions?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    quests?: ChronicleQuestOrderByRelationAggregateInput
  }

  export type ChronicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_sessionNumber?: ChronicleCampaignIdSessionNumberCompoundUniqueInput
    AND?: ChronicleWhereInput | ChronicleWhereInput[]
    OR?: ChronicleWhereInput[]
    NOT?: ChronicleWhereInput | ChronicleWhereInput[]
    campaignId?: StringFilter<"Chronicle"> | string
    sessionNumber?: IntFilter<"Chronicle"> | number
    sessionDate?: DateTimeFilter<"Chronicle"> | Date | string
    title?: StringNullableFilter<"Chronicle"> | string | null
    summary?: StringNullableFilter<"Chronicle"> | string | null
    playerDeeds?: JsonNullableFilter<"Chronicle">
    importantDecisions?: JsonNullableFilter<"Chronicle">
    dmNotes?: StringNullableFilter<"Chronicle"> | string | null
    createdAt?: DateTimeFilter<"Chronicle"> | Date | string
    updatedAt?: DateTimeFilter<"Chronicle"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    quests?: ChronicleQuestListRelationFilter
  }, "id" | "campaignId_sessionNumber">

  export type ChronicleOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sessionNumber?: SortOrder
    sessionDate?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    playerDeeds?: SortOrderInput | SortOrder
    importantDecisions?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChronicleCountOrderByAggregateInput
    _avg?: ChronicleAvgOrderByAggregateInput
    _max?: ChronicleMaxOrderByAggregateInput
    _min?: ChronicleMinOrderByAggregateInput
    _sum?: ChronicleSumOrderByAggregateInput
  }

  export type ChronicleScalarWhereWithAggregatesInput = {
    AND?: ChronicleScalarWhereWithAggregatesInput | ChronicleScalarWhereWithAggregatesInput[]
    OR?: ChronicleScalarWhereWithAggregatesInput[]
    NOT?: ChronicleScalarWhereWithAggregatesInput | ChronicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chronicle"> | string
    campaignId?: StringWithAggregatesFilter<"Chronicle"> | string
    sessionNumber?: IntWithAggregatesFilter<"Chronicle"> | number
    sessionDate?: DateTimeWithAggregatesFilter<"Chronicle"> | Date | string
    title?: StringNullableWithAggregatesFilter<"Chronicle"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Chronicle"> | string | null
    playerDeeds?: JsonNullableWithAggregatesFilter<"Chronicle">
    importantDecisions?: JsonNullableWithAggregatesFilter<"Chronicle">
    dmNotes?: StringNullableWithAggregatesFilter<"Chronicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Chronicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chronicle"> | Date | string
  }

  export type InteractionWhereInput = {
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    id?: StringFilter<"Interaction"> | string
    campaignId?: StringFilter<"Interaction"> | string
    npcId?: StringFilter<"Interaction"> | string
    interactionDate?: DateTimeFilter<"Interaction"> | Date | string
    sessionDate?: DateTimeFilter<"Interaction"> | Date | string
    interactionType?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    summary?: StringNullableFilter<"Interaction"> | string | null
    details?: StringNullableFilter<"Interaction"> | string | null
    attitudeChange?: EnumNPCAttitudeNullableFilter<"Interaction"> | $Enums.NPCAttitude | null
    involvedPcs?: JsonNullableFilter<"Interaction">
    dmNotes?: StringNullableFilter<"Interaction"> | string | null
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
    items?: InteractionItemListRelationFilter
  }

  export type InteractionOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    npcId?: SortOrder
    interactionDate?: SortOrder
    sessionDate?: SortOrder
    interactionType?: SortOrder
    summary?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    attitudeChange?: SortOrderInput | SortOrder
    involvedPcs?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    npc?: NPCOrderByWithRelationInput
    items?: InteractionItemOrderByRelationAggregateInput
  }

  export type InteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    campaignId?: StringFilter<"Interaction"> | string
    npcId?: StringFilter<"Interaction"> | string
    interactionDate?: DateTimeFilter<"Interaction"> | Date | string
    sessionDate?: DateTimeFilter<"Interaction"> | Date | string
    interactionType?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    summary?: StringNullableFilter<"Interaction"> | string | null
    details?: StringNullableFilter<"Interaction"> | string | null
    attitudeChange?: EnumNPCAttitudeNullableFilter<"Interaction"> | $Enums.NPCAttitude | null
    involvedPcs?: JsonNullableFilter<"Interaction">
    dmNotes?: StringNullableFilter<"Interaction"> | string | null
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
    items?: InteractionItemListRelationFilter
  }, "id">

  export type InteractionOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    npcId?: SortOrder
    interactionDate?: SortOrder
    sessionDate?: SortOrder
    interactionType?: SortOrder
    summary?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    attitudeChange?: SortOrderInput | SortOrder
    involvedPcs?: SortOrderInput | SortOrder
    dmNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InteractionCountOrderByAggregateInput
    _max?: InteractionMaxOrderByAggregateInput
    _min?: InteractionMinOrderByAggregateInput
  }

  export type InteractionScalarWhereWithAggregatesInput = {
    AND?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    OR?: InteractionScalarWhereWithAggregatesInput[]
    NOT?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interaction"> | string
    campaignId?: StringWithAggregatesFilter<"Interaction"> | string
    npcId?: StringWithAggregatesFilter<"Interaction"> | string
    interactionDate?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    sessionDate?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    interactionType?: EnumInteractionTypeWithAggregatesFilter<"Interaction"> | $Enums.InteractionType
    summary?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    details?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    attitudeChange?: EnumNPCAttitudeNullableWithAggregatesFilter<"Interaction"> | $Enums.NPCAttitude | null
    involvedPcs?: JsonNullableWithAggregatesFilter<"Interaction">
    dmNotes?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
  }

  export type MonsterCampaignWhereInput = {
    AND?: MonsterCampaignWhereInput | MonsterCampaignWhereInput[]
    OR?: MonsterCampaignWhereInput[]
    NOT?: MonsterCampaignWhereInput | MonsterCampaignWhereInput[]
    monsterId?: StringFilter<"MonsterCampaign"> | string
    campaignId?: StringFilter<"MonsterCampaign"> | string
    monster?: XOR<MonsterScalarRelationFilter, MonsterWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type MonsterCampaignOrderByWithRelationInput = {
    monsterId?: SortOrder
    campaignId?: SortOrder
    monster?: MonsterOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type MonsterCampaignWhereUniqueInput = Prisma.AtLeast<{
    monsterId_campaignId?: MonsterCampaignMonsterIdCampaignIdCompoundUniqueInput
    AND?: MonsterCampaignWhereInput | MonsterCampaignWhereInput[]
    OR?: MonsterCampaignWhereInput[]
    NOT?: MonsterCampaignWhereInput | MonsterCampaignWhereInput[]
    monsterId?: StringFilter<"MonsterCampaign"> | string
    campaignId?: StringFilter<"MonsterCampaign"> | string
    monster?: XOR<MonsterScalarRelationFilter, MonsterWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "monsterId_campaignId">

  export type MonsterCampaignOrderByWithAggregationInput = {
    monsterId?: SortOrder
    campaignId?: SortOrder
    _count?: MonsterCampaignCountOrderByAggregateInput
    _max?: MonsterCampaignMaxOrderByAggregateInput
    _min?: MonsterCampaignMinOrderByAggregateInput
  }

  export type MonsterCampaignScalarWhereWithAggregatesInput = {
    AND?: MonsterCampaignScalarWhereWithAggregatesInput | MonsterCampaignScalarWhereWithAggregatesInput[]
    OR?: MonsterCampaignScalarWhereWithAggregatesInput[]
    NOT?: MonsterCampaignScalarWhereWithAggregatesInput | MonsterCampaignScalarWhereWithAggregatesInput[]
    monsterId?: StringWithAggregatesFilter<"MonsterCampaign"> | string
    campaignId?: StringWithAggregatesFilter<"MonsterCampaign"> | string
  }

  export type ItemCampaignWhereInput = {
    AND?: ItemCampaignWhereInput | ItemCampaignWhereInput[]
    OR?: ItemCampaignWhereInput[]
    NOT?: ItemCampaignWhereInput | ItemCampaignWhereInput[]
    itemId?: StringFilter<"ItemCampaign"> | string
    campaignId?: StringFilter<"ItemCampaign"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type ItemCampaignOrderByWithRelationInput = {
    itemId?: SortOrder
    campaignId?: SortOrder
    item?: ItemOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type ItemCampaignWhereUniqueInput = Prisma.AtLeast<{
    itemId_campaignId?: ItemCampaignItemIdCampaignIdCompoundUniqueInput
    AND?: ItemCampaignWhereInput | ItemCampaignWhereInput[]
    OR?: ItemCampaignWhereInput[]
    NOT?: ItemCampaignWhereInput | ItemCampaignWhereInput[]
    itemId?: StringFilter<"ItemCampaign"> | string
    campaignId?: StringFilter<"ItemCampaign"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "itemId_campaignId">

  export type ItemCampaignOrderByWithAggregationInput = {
    itemId?: SortOrder
    campaignId?: SortOrder
    _count?: ItemCampaignCountOrderByAggregateInput
    _max?: ItemCampaignMaxOrderByAggregateInput
    _min?: ItemCampaignMinOrderByAggregateInput
  }

  export type ItemCampaignScalarWhereWithAggregatesInput = {
    AND?: ItemCampaignScalarWhereWithAggregatesInput | ItemCampaignScalarWhereWithAggregatesInput[]
    OR?: ItemCampaignScalarWhereWithAggregatesInput[]
    NOT?: ItemCampaignScalarWhereWithAggregatesInput | ItemCampaignScalarWhereWithAggregatesInput[]
    itemId?: StringWithAggregatesFilter<"ItemCampaign"> | string
    campaignId?: StringWithAggregatesFilter<"ItemCampaign"> | string
  }

  export type NPCLocationWhereInput = {
    AND?: NPCLocationWhereInput | NPCLocationWhereInput[]
    OR?: NPCLocationWhereInput[]
    NOT?: NPCLocationWhereInput | NPCLocationWhereInput[]
    npcId?: StringFilter<"NPCLocation"> | string
    locationId?: StringFilter<"NPCLocation"> | string
    isPrimary?: BoolFilter<"NPCLocation"> | boolean
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type NPCLocationOrderByWithRelationInput = {
    npcId?: SortOrder
    locationId?: SortOrder
    isPrimary?: SortOrder
    npc?: NPCOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type NPCLocationWhereUniqueInput = Prisma.AtLeast<{
    npcId_locationId?: NPCLocationNpcIdLocationIdCompoundUniqueInput
    AND?: NPCLocationWhereInput | NPCLocationWhereInput[]
    OR?: NPCLocationWhereInput[]
    NOT?: NPCLocationWhereInput | NPCLocationWhereInput[]
    npcId?: StringFilter<"NPCLocation"> | string
    locationId?: StringFilter<"NPCLocation"> | string
    isPrimary?: BoolFilter<"NPCLocation"> | boolean
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "npcId_locationId">

  export type NPCLocationOrderByWithAggregationInput = {
    npcId?: SortOrder
    locationId?: SortOrder
    isPrimary?: SortOrder
    _count?: NPCLocationCountOrderByAggregateInput
    _max?: NPCLocationMaxOrderByAggregateInput
    _min?: NPCLocationMinOrderByAggregateInput
  }

  export type NPCLocationScalarWhereWithAggregatesInput = {
    AND?: NPCLocationScalarWhereWithAggregatesInput | NPCLocationScalarWhereWithAggregatesInput[]
    OR?: NPCLocationScalarWhereWithAggregatesInput[]
    NOT?: NPCLocationScalarWhereWithAggregatesInput | NPCLocationScalarWhereWithAggregatesInput[]
    npcId?: StringWithAggregatesFilter<"NPCLocation"> | string
    locationId?: StringWithAggregatesFilter<"NPCLocation"> | string
    isPrimary?: BoolWithAggregatesFilter<"NPCLocation"> | boolean
  }

  export type QuestNPCWhereInput = {
    AND?: QuestNPCWhereInput | QuestNPCWhereInput[]
    OR?: QuestNPCWhereInput[]
    NOT?: QuestNPCWhereInput | QuestNPCWhereInput[]
    questId?: StringFilter<"QuestNPC"> | string
    npcId?: StringFilter<"QuestNPC"> | string
    role?: StringNullableFilter<"QuestNPC"> | string | null
    quest?: XOR<QuestScalarRelationFilter, QuestWhereInput>
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
  }

  export type QuestNPCOrderByWithRelationInput = {
    questId?: SortOrder
    npcId?: SortOrder
    role?: SortOrderInput | SortOrder
    quest?: QuestOrderByWithRelationInput
    npc?: NPCOrderByWithRelationInput
  }

  export type QuestNPCWhereUniqueInput = Prisma.AtLeast<{
    questId_npcId?: QuestNPCQuestIdNpcIdCompoundUniqueInput
    AND?: QuestNPCWhereInput | QuestNPCWhereInput[]
    OR?: QuestNPCWhereInput[]
    NOT?: QuestNPCWhereInput | QuestNPCWhereInput[]
    questId?: StringFilter<"QuestNPC"> | string
    npcId?: StringFilter<"QuestNPC"> | string
    role?: StringNullableFilter<"QuestNPC"> | string | null
    quest?: XOR<QuestScalarRelationFilter, QuestWhereInput>
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
  }, "questId_npcId">

  export type QuestNPCOrderByWithAggregationInput = {
    questId?: SortOrder
    npcId?: SortOrder
    role?: SortOrderInput | SortOrder
    _count?: QuestNPCCountOrderByAggregateInput
    _max?: QuestNPCMaxOrderByAggregateInput
    _min?: QuestNPCMinOrderByAggregateInput
  }

  export type QuestNPCScalarWhereWithAggregatesInput = {
    AND?: QuestNPCScalarWhereWithAggregatesInput | QuestNPCScalarWhereWithAggregatesInput[]
    OR?: QuestNPCScalarWhereWithAggregatesInput[]
    NOT?: QuestNPCScalarWhereWithAggregatesInput | QuestNPCScalarWhereWithAggregatesInput[]
    questId?: StringWithAggregatesFilter<"QuestNPC"> | string
    npcId?: StringWithAggregatesFilter<"QuestNPC"> | string
    role?: StringNullableWithAggregatesFilter<"QuestNPC"> | string | null
  }

  export type QuestLocationWhereInput = {
    AND?: QuestLocationWhereInput | QuestLocationWhereInput[]
    OR?: QuestLocationWhereInput[]
    NOT?: QuestLocationWhereInput | QuestLocationWhereInput[]
    questId?: StringFilter<"QuestLocation"> | string
    locationId?: StringFilter<"QuestLocation"> | string
    quest?: XOR<QuestScalarRelationFilter, QuestWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type QuestLocationOrderByWithRelationInput = {
    questId?: SortOrder
    locationId?: SortOrder
    quest?: QuestOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type QuestLocationWhereUniqueInput = Prisma.AtLeast<{
    questId_locationId?: QuestLocationQuestIdLocationIdCompoundUniqueInput
    AND?: QuestLocationWhereInput | QuestLocationWhereInput[]
    OR?: QuestLocationWhereInput[]
    NOT?: QuestLocationWhereInput | QuestLocationWhereInput[]
    questId?: StringFilter<"QuestLocation"> | string
    locationId?: StringFilter<"QuestLocation"> | string
    quest?: XOR<QuestScalarRelationFilter, QuestWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "questId_locationId">

  export type QuestLocationOrderByWithAggregationInput = {
    questId?: SortOrder
    locationId?: SortOrder
    _count?: QuestLocationCountOrderByAggregateInput
    _max?: QuestLocationMaxOrderByAggregateInput
    _min?: QuestLocationMinOrderByAggregateInput
  }

  export type QuestLocationScalarWhereWithAggregatesInput = {
    AND?: QuestLocationScalarWhereWithAggregatesInput | QuestLocationScalarWhereWithAggregatesInput[]
    OR?: QuestLocationScalarWhereWithAggregatesInput[]
    NOT?: QuestLocationScalarWhereWithAggregatesInput | QuestLocationScalarWhereWithAggregatesInput[]
    questId?: StringWithAggregatesFilter<"QuestLocation"> | string
    locationId?: StringWithAggregatesFilter<"QuestLocation"> | string
  }

  export type ChronicleQuestWhereInput = {
    AND?: ChronicleQuestWhereInput | ChronicleQuestWhereInput[]
    OR?: ChronicleQuestWhereInput[]
    NOT?: ChronicleQuestWhereInput | ChronicleQuestWhereInput[]
    chronicleId?: StringFilter<"ChronicleQuest"> | string
    questId?: StringFilter<"ChronicleQuest"> | string
    statusChange?: StringFilter<"ChronicleQuest"> | string
    chronicle?: XOR<ChronicleScalarRelationFilter, ChronicleWhereInput>
    quest?: XOR<QuestScalarRelationFilter, QuestWhereInput>
  }

  export type ChronicleQuestOrderByWithRelationInput = {
    chronicleId?: SortOrder
    questId?: SortOrder
    statusChange?: SortOrder
    chronicle?: ChronicleOrderByWithRelationInput
    quest?: QuestOrderByWithRelationInput
  }

  export type ChronicleQuestWhereUniqueInput = Prisma.AtLeast<{
    chronicleId_questId?: ChronicleQuestChronicleIdQuestIdCompoundUniqueInput
    AND?: ChronicleQuestWhereInput | ChronicleQuestWhereInput[]
    OR?: ChronicleQuestWhereInput[]
    NOT?: ChronicleQuestWhereInput | ChronicleQuestWhereInput[]
    chronicleId?: StringFilter<"ChronicleQuest"> | string
    questId?: StringFilter<"ChronicleQuest"> | string
    statusChange?: StringFilter<"ChronicleQuest"> | string
    chronicle?: XOR<ChronicleScalarRelationFilter, ChronicleWhereInput>
    quest?: XOR<QuestScalarRelationFilter, QuestWhereInput>
  }, "chronicleId_questId">

  export type ChronicleQuestOrderByWithAggregationInput = {
    chronicleId?: SortOrder
    questId?: SortOrder
    statusChange?: SortOrder
    _count?: ChronicleQuestCountOrderByAggregateInput
    _max?: ChronicleQuestMaxOrderByAggregateInput
    _min?: ChronicleQuestMinOrderByAggregateInput
  }

  export type ChronicleQuestScalarWhereWithAggregatesInput = {
    AND?: ChronicleQuestScalarWhereWithAggregatesInput | ChronicleQuestScalarWhereWithAggregatesInput[]
    OR?: ChronicleQuestScalarWhereWithAggregatesInput[]
    NOT?: ChronicleQuestScalarWhereWithAggregatesInput | ChronicleQuestScalarWhereWithAggregatesInput[]
    chronicleId?: StringWithAggregatesFilter<"ChronicleQuest"> | string
    questId?: StringWithAggregatesFilter<"ChronicleQuest"> | string
    statusChange?: StringWithAggregatesFilter<"ChronicleQuest"> | string
  }

  export type ItemLocationWhereInput = {
    AND?: ItemLocationWhereInput | ItemLocationWhereInput[]
    OR?: ItemLocationWhereInput[]
    NOT?: ItemLocationWhereInput | ItemLocationWhereInput[]
    itemId?: StringFilter<"ItemLocation"> | string
    locationId?: StringFilter<"ItemLocation"> | string
    isHidden?: BoolFilter<"ItemLocation"> | boolean
    notes?: StringNullableFilter<"ItemLocation"> | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type ItemLocationOrderByWithRelationInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    isHidden?: SortOrder
    notes?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type ItemLocationWhereUniqueInput = Prisma.AtLeast<{
    itemId_locationId?: ItemLocationItemIdLocationIdCompoundUniqueInput
    AND?: ItemLocationWhereInput | ItemLocationWhereInput[]
    OR?: ItemLocationWhereInput[]
    NOT?: ItemLocationWhereInput | ItemLocationWhereInput[]
    itemId?: StringFilter<"ItemLocation"> | string
    locationId?: StringFilter<"ItemLocation"> | string
    isHidden?: BoolFilter<"ItemLocation"> | boolean
    notes?: StringNullableFilter<"ItemLocation"> | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "itemId_locationId">

  export type ItemLocationOrderByWithAggregationInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    isHidden?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ItemLocationCountOrderByAggregateInput
    _max?: ItemLocationMaxOrderByAggregateInput
    _min?: ItemLocationMinOrderByAggregateInput
  }

  export type ItemLocationScalarWhereWithAggregatesInput = {
    AND?: ItemLocationScalarWhereWithAggregatesInput | ItemLocationScalarWhereWithAggregatesInput[]
    OR?: ItemLocationScalarWhereWithAggregatesInput[]
    NOT?: ItemLocationScalarWhereWithAggregatesInput | ItemLocationScalarWhereWithAggregatesInput[]
    itemId?: StringWithAggregatesFilter<"ItemLocation"> | string
    locationId?: StringWithAggregatesFilter<"ItemLocation"> | string
    isHidden?: BoolWithAggregatesFilter<"ItemLocation"> | boolean
    notes?: StringNullableWithAggregatesFilter<"ItemLocation"> | string | null
  }

  export type ItemNPCWhereInput = {
    AND?: ItemNPCWhereInput | ItemNPCWhereInput[]
    OR?: ItemNPCWhereInput[]
    NOT?: ItemNPCWhereInput | ItemNPCWhereInput[]
    itemId?: StringFilter<"ItemNPC"> | string
    npcId?: StringFilter<"ItemNPC"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
  }

  export type ItemNPCOrderByWithRelationInput = {
    itemId?: SortOrder
    npcId?: SortOrder
    item?: ItemOrderByWithRelationInput
    npc?: NPCOrderByWithRelationInput
  }

  export type ItemNPCWhereUniqueInput = Prisma.AtLeast<{
    itemId_npcId?: ItemNPCItemIdNpcIdCompoundUniqueInput
    AND?: ItemNPCWhereInput | ItemNPCWhereInput[]
    OR?: ItemNPCWhereInput[]
    NOT?: ItemNPCWhereInput | ItemNPCWhereInput[]
    itemId?: StringFilter<"ItemNPC"> | string
    npcId?: StringFilter<"ItemNPC"> | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    npc?: XOR<NPCScalarRelationFilter, NPCWhereInput>
  }, "itemId_npcId">

  export type ItemNPCOrderByWithAggregationInput = {
    itemId?: SortOrder
    npcId?: SortOrder
    _count?: ItemNPCCountOrderByAggregateInput
    _max?: ItemNPCMaxOrderByAggregateInput
    _min?: ItemNPCMinOrderByAggregateInput
  }

  export type ItemNPCScalarWhereWithAggregatesInput = {
    AND?: ItemNPCScalarWhereWithAggregatesInput | ItemNPCScalarWhereWithAggregatesInput[]
    OR?: ItemNPCScalarWhereWithAggregatesInput[]
    NOT?: ItemNPCScalarWhereWithAggregatesInput | ItemNPCScalarWhereWithAggregatesInput[]
    itemId?: StringWithAggregatesFilter<"ItemNPC"> | string
    npcId?: StringWithAggregatesFilter<"ItemNPC"> | string
  }

  export type InteractionItemWhereInput = {
    AND?: InteractionItemWhereInput | InteractionItemWhereInput[]
    OR?: InteractionItemWhereInput[]
    NOT?: InteractionItemWhereInput | InteractionItemWhereInput[]
    interactionId?: StringFilter<"InteractionItem"> | string
    itemId?: StringFilter<"InteractionItem"> | string
    transactionType?: EnumTransactionTypeFilter<"InteractionItem"> | $Enums.TransactionType
    interaction?: XOR<InteractionScalarRelationFilter, InteractionWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type InteractionItemOrderByWithRelationInput = {
    interactionId?: SortOrder
    itemId?: SortOrder
    transactionType?: SortOrder
    interaction?: InteractionOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InteractionItemWhereUniqueInput = Prisma.AtLeast<{
    interactionId_itemId?: InteractionItemInteractionIdItemIdCompoundUniqueInput
    AND?: InteractionItemWhereInput | InteractionItemWhereInput[]
    OR?: InteractionItemWhereInput[]
    NOT?: InteractionItemWhereInput | InteractionItemWhereInput[]
    interactionId?: StringFilter<"InteractionItem"> | string
    itemId?: StringFilter<"InteractionItem"> | string
    transactionType?: EnumTransactionTypeFilter<"InteractionItem"> | $Enums.TransactionType
    interaction?: XOR<InteractionScalarRelationFilter, InteractionWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "interactionId_itemId">

  export type InteractionItemOrderByWithAggregationInput = {
    interactionId?: SortOrder
    itemId?: SortOrder
    transactionType?: SortOrder
    _count?: InteractionItemCountOrderByAggregateInput
    _max?: InteractionItemMaxOrderByAggregateInput
    _min?: InteractionItemMinOrderByAggregateInput
  }

  export type InteractionItemScalarWhereWithAggregatesInput = {
    AND?: InteractionItemScalarWhereWithAggregatesInput | InteractionItemScalarWhereWithAggregatesInput[]
    OR?: InteractionItemScalarWhereWithAggregatesInput[]
    NOT?: InteractionItemScalarWhereWithAggregatesInput | InteractionItemScalarWhereWithAggregatesInput[]
    interactionId?: StringWithAggregatesFilter<"InteractionItem"> | string
    itemId?: StringWithAggregatesFilter<"InteractionItem"> | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"InteractionItem"> | $Enums.TransactionType
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NPCCreateInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutNpcsInput
    locations?: NPCLocationCreateNestedManyWithoutNpcInput
    questsGiven?: QuestCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCCreateNestedManyWithoutNpcInput
    interactions?: InteractionCreateNestedManyWithoutNpcInput
    items?: ItemNPCCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationUncheckedCreateNestedManyWithoutNpcInput
    questsGiven?: QuestUncheckedCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCUncheckedCreateNestedManyWithoutNpcInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutNpcInput
    items?: ItemNPCUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutNpcsNestedInput
    locations?: NPCLocationUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUncheckedUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUncheckedUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUncheckedUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type NPCCreateManyInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NPCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapCreateInput = {
    id?: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMapsInput
    location?: LocationCreateNestedOneWithoutMapsInput
    annotations?: MapAnnotationCreateNestedManyWithoutMapInput
    encounters?: EncounterCreateNestedManyWithoutMapInput
  }

  export type MapUncheckedCreateInput = {
    id?: string
    campaignId: string
    locationId?: string | null
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    annotations?: MapAnnotationUncheckedCreateNestedManyWithoutMapInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutMapInput
  }

  export type MapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMapsNestedInput
    location?: LocationUpdateOneWithoutMapsNestedInput
    annotations?: MapAnnotationUpdateManyWithoutMapNestedInput
    encounters?: EncounterUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotations?: MapAnnotationUncheckedUpdateManyWithoutMapNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutMapNestedInput
  }

  export type MapCreateManyInput = {
    id?: string
    campaignId: string
    locationId?: string | null
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapAnnotationCreateInput = {
    id?: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title?: string | null
    content?: string | null
    isHidden?: boolean
    map: MapCreateNestedOneWithoutAnnotationsInput
  }

  export type MapAnnotationUncheckedCreateInput = {
    id?: string
    mapId: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title?: string | null
    content?: string | null
    isHidden?: boolean
  }

  export type MapAnnotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    map?: MapUpdateOneRequiredWithoutAnnotationsNestedInput
  }

  export type MapAnnotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MapAnnotationCreateManyInput = {
    id?: string
    mapId: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title?: string | null
    content?: string | null
    isHidden?: boolean
  }

  export type MapAnnotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MapAnnotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MonsterCreateInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: MonsterCampaignCreateNestedManyWithoutMonsterInput
    encounterParticipants?: EncounterParticipantCreateNestedManyWithoutMonsterInput
  }

  export type MonsterUncheckedCreateInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutMonsterInput
    encounterParticipants?: EncounterParticipantUncheckedCreateNestedManyWithoutMonsterInput
  }

  export type MonsterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: MonsterCampaignUpdateManyWithoutMonsterNestedInput
    encounterParticipants?: EncounterParticipantUpdateManyWithoutMonsterNestedInput
  }

  export type MonsterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: MonsterCampaignUncheckedUpdateManyWithoutMonsterNestedInput
    encounterParticipants?: EncounterParticipantUncheckedUpdateManyWithoutMonsterNestedInput
  }

  export type MonsterCreateManyInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonsterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonsterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionCreateInput = {
    id?: string
    name: string
    icon?: string | null
    description?: string | null
    mechanicalEffects?: string | null
    isCustom?: boolean
  }

  export type ConditionUncheckedCreateInput = {
    id?: string
    name: string
    icon?: string | null
    description?: string | null
    mechanicalEffects?: string | null
    isCustom?: boolean
  }

  export type ConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    isCustom?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    isCustom?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConditionCreateManyInput = {
    id?: string
    name: string
    icon?: string | null
    description?: string | null
    mechanicalEffects?: string | null
    isCustom?: boolean
  }

  export type ConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    isCustom?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    isCustom?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterCreateInput = {
    id?: string
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    map?: MapCreateNestedOneWithoutEncountersInput
    location?: LocationCreateNestedOneWithoutEncountersInput
    participants?: EncounterParticipantCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    campaignId: string
    mapId?: string | null
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    participants?: EncounterParticipantUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    map?: MapUpdateOneWithoutEncountersNestedInput
    location?: LocationUpdateOneWithoutEncountersNestedInput
    participants?: EncounterParticipantUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: EncounterParticipantUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: string
    campaignId: string
    mapId?: string | null
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterParticipantCreateInput = {
    id?: string
    participantType: $Enums.ParticipantType
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
    encounter: EncounterCreateNestedOneWithoutParticipantsInput
    monster?: MonsterCreateNestedOneWithoutEncounterParticipantsInput
    playerCharacter?: PlayerCharacterCreateNestedOneWithoutEncounterParticipantsInput
  }

  export type EncounterParticipantUncheckedCreateInput = {
    id?: string
    encounterId: string
    participantType: $Enums.ParticipantType
    monsterId?: string | null
    playerCharacterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutParticipantsNestedInput
    monster?: MonsterUpdateOneWithoutEncounterParticipantsNestedInput
    playerCharacter?: PlayerCharacterUpdateOneWithoutEncounterParticipantsNestedInput
  }

  export type EncounterParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    monsterId?: NullableStringFieldUpdateOperationsInput | string | null
    playerCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantCreateManyInput = {
    id?: string
    encounterId: string
    participantType: $Enums.ParticipantType
    monsterId?: string | null
    playerCharacterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    monsterId?: NullableStringFieldUpdateOperationsInput | string | null
    playerCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerCharacterCreateInput = {
    id?: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutPlayerCharactersInput
    encounterParticipants?: EncounterParticipantCreateNestedManyWithoutPlayerCharacterInput
  }

  export type PlayerCharacterUncheckedCreateInput = {
    id?: string
    campaignId: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    encounterParticipants?: EncounterParticipantUncheckedCreateNestedManyWithoutPlayerCharacterInput
  }

  export type PlayerCharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutPlayerCharactersNestedInput
    encounterParticipants?: EncounterParticipantUpdateManyWithoutPlayerCharacterNestedInput
  }

  export type PlayerCharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterParticipants?: EncounterParticipantUncheckedUpdateManyWithoutPlayerCharacterNestedInput
  }

  export type PlayerCharacterCreateManyInput = {
    id?: string
    campaignId: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestCreateInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestCreateManyInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type QuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignCreateNestedManyWithoutItemInput
    locations?: ItemLocationCreateNestedManyWithoutItemInput
    npcs?: ItemNPCCreateNestedManyWithoutItemInput
    interactions?: InteractionItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignUncheckedCreateNestedManyWithoutItemInput
    locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    npcs?: ItemNPCUncheckedCreateNestedManyWithoutItemInput
    interactions?: InteractionItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUpdateManyWithoutItemNestedInput
    locations?: ItemLocationUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUncheckedUpdateManyWithoutItemNestedInput
    locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUncheckedUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChronicleCreateInput = {
    id?: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutChroniclesInput
    quests?: ChronicleQuestCreateNestedManyWithoutChronicleInput
  }

  export type ChronicleUncheckedCreateInput = {
    id?: string
    campaignId: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quests?: ChronicleQuestUncheckedCreateNestedManyWithoutChronicleInput
  }

  export type ChronicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutChroniclesNestedInput
    quests?: ChronicleQuestUpdateManyWithoutChronicleNestedInput
  }

  export type ChronicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quests?: ChronicleQuestUncheckedUpdateManyWithoutChronicleNestedInput
  }

  export type ChronicleCreateManyInput = {
    id?: string
    campaignId: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChronicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChronicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateInput = {
    id?: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutInteractionsInput
    npc: NPCCreateNestedOneWithoutInteractionsInput
    items?: InteractionItemCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUncheckedCreateInput = {
    id?: string
    campaignId: string
    npcId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    items?: InteractionItemUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutInteractionsNestedInput
    npc?: NPCUpdateOneRequiredWithoutInteractionsNestedInput
    items?: InteractionItemUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InteractionItemUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionCreateManyInput = {
    id?: string
    campaignId: string
    npcId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
  }

  export type InteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonsterCampaignCreateInput = {
    monster: MonsterCreateNestedOneWithoutCampaignsInput
    campaign: CampaignCreateNestedOneWithoutMonsterCampaignsInput
  }

  export type MonsterCampaignUncheckedCreateInput = {
    monsterId: string
    campaignId: string
  }

  export type MonsterCampaignUpdateInput = {
    monster?: MonsterUpdateOneRequiredWithoutCampaignsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutMonsterCampaignsNestedInput
  }

  export type MonsterCampaignUncheckedUpdateInput = {
    monsterId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type MonsterCampaignCreateManyInput = {
    monsterId: string
    campaignId: string
  }

  export type MonsterCampaignUpdateManyMutationInput = {

  }

  export type MonsterCampaignUncheckedUpdateManyInput = {
    monsterId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCampaignCreateInput = {
    item: ItemCreateNestedOneWithoutCampaignsInput
    campaign: CampaignCreateNestedOneWithoutItemCampaignsInput
  }

  export type ItemCampaignUncheckedCreateInput = {
    itemId: string
    campaignId: string
  }

  export type ItemCampaignUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutCampaignsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutItemCampaignsNestedInput
  }

  export type ItemCampaignUncheckedUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCampaignCreateManyInput = {
    itemId: string
    campaignId: string
  }

  export type ItemCampaignUpdateManyMutationInput = {

  }

  export type ItemCampaignUncheckedUpdateManyInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type NPCLocationCreateInput = {
    isPrimary?: boolean
    npc: NPCCreateNestedOneWithoutLocationsInput
    location: LocationCreateNestedOneWithoutNpcsInput
  }

  export type NPCLocationUncheckedCreateInput = {
    npcId: string
    locationId: string
    isPrimary?: boolean
  }

  export type NPCLocationUpdateInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    npc?: NPCUpdateOneRequiredWithoutLocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutNpcsNestedInput
  }

  export type NPCLocationUncheckedUpdateInput = {
    npcId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NPCLocationCreateManyInput = {
    npcId: string
    locationId: string
    isPrimary?: boolean
  }

  export type NPCLocationUpdateManyMutationInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NPCLocationUncheckedUpdateManyInput = {
    npcId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestNPCCreateInput = {
    role?: string | null
    quest: QuestCreateNestedOneWithoutNpcsInput
    npc: NPCCreateNestedOneWithoutQuestsInvolvedInput
  }

  export type QuestNPCUncheckedCreateInput = {
    questId: string
    npcId: string
    role?: string | null
  }

  export type QuestNPCUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    quest?: QuestUpdateOneRequiredWithoutNpcsNestedInput
    npc?: NPCUpdateOneRequiredWithoutQuestsInvolvedNestedInput
  }

  export type QuestNPCUncheckedUpdateInput = {
    questId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestNPCCreateManyInput = {
    questId: string
    npcId: string
    role?: string | null
  }

  export type QuestNPCUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestNPCUncheckedUpdateManyInput = {
    questId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestLocationCreateInput = {
    quest: QuestCreateNestedOneWithoutLocationsInput
    location: LocationCreateNestedOneWithoutQuestsInput
  }

  export type QuestLocationUncheckedCreateInput = {
    questId: string
    locationId: string
  }

  export type QuestLocationUpdateInput = {
    quest?: QuestUpdateOneRequiredWithoutLocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type QuestLocationUncheckedUpdateInput = {
    questId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestLocationCreateManyInput = {
    questId: string
    locationId: string
  }

  export type QuestLocationUpdateManyMutationInput = {

  }

  export type QuestLocationUncheckedUpdateManyInput = {
    questId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type ChronicleQuestCreateInput = {
    statusChange: string
    chronicle: ChronicleCreateNestedOneWithoutQuestsInput
    quest: QuestCreateNestedOneWithoutChroniclesInput
  }

  export type ChronicleQuestUncheckedCreateInput = {
    chronicleId: string
    questId: string
    statusChange: string
  }

  export type ChronicleQuestUpdateInput = {
    statusChange?: StringFieldUpdateOperationsInput | string
    chronicle?: ChronicleUpdateOneRequiredWithoutQuestsNestedInput
    quest?: QuestUpdateOneRequiredWithoutChroniclesNestedInput
  }

  export type ChronicleQuestUncheckedUpdateInput = {
    chronicleId?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type ChronicleQuestCreateManyInput = {
    chronicleId: string
    questId: string
    statusChange: string
  }

  export type ChronicleQuestUpdateManyMutationInput = {
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type ChronicleQuestUncheckedUpdateManyInput = {
    chronicleId?: StringFieldUpdateOperationsInput | string
    questId?: StringFieldUpdateOperationsInput | string
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type ItemLocationCreateInput = {
    isHidden?: boolean
    notes?: string | null
    item: ItemCreateNestedOneWithoutLocationsInput
    location: LocationCreateNestedOneWithoutItemsInput
  }

  export type ItemLocationUncheckedCreateInput = {
    itemId: string
    locationId: string
    isHidden?: boolean
    notes?: string | null
  }

  export type ItemLocationUpdateInput = {
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    item?: ItemUpdateOneRequiredWithoutLocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemLocationUncheckedUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemLocationCreateManyInput = {
    itemId: string
    locationId: string
    isHidden?: boolean
    notes?: string | null
  }

  export type ItemLocationUpdateManyMutationInput = {
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemLocationUncheckedUpdateManyInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemNPCCreateInput = {
    item: ItemCreateNestedOneWithoutNpcsInput
    npc: NPCCreateNestedOneWithoutItemsInput
  }

  export type ItemNPCUncheckedCreateInput = {
    itemId: string
    npcId: string
  }

  export type ItemNPCUpdateInput = {
    item?: ItemUpdateOneRequiredWithoutNpcsNestedInput
    npc?: NPCUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemNPCUncheckedUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemNPCCreateManyInput = {
    itemId: string
    npcId: string
  }

  export type ItemNPCUpdateManyMutationInput = {

  }

  export type ItemNPCUncheckedUpdateManyInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionItemCreateInput = {
    transactionType: $Enums.TransactionType
    interaction: InteractionCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionItemUncheckedCreateInput = {
    interactionId: string
    itemId: string
    transactionType: $Enums.TransactionType
  }

  export type InteractionItemUpdateInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    interaction?: InteractionUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionItemUncheckedUpdateInput = {
    interactionId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type InteractionItemCreateManyInput = {
    interactionId: string
    itemId: string
    transactionType: $Enums.TransactionType
  }

  export type InteractionItemUpdateManyMutationInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type InteractionItemUncheckedUpdateManyInput = {
    interactionId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NPCListRelationFilter = {
    every?: NPCWhereInput
    some?: NPCWhereInput
    none?: NPCWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type MapListRelationFilter = {
    every?: MapWhereInput
    some?: MapWhereInput
    none?: MapWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type PlayerCharacterListRelationFilter = {
    every?: PlayerCharacterWhereInput
    some?: PlayerCharacterWhereInput
    none?: PlayerCharacterWhereInput
  }

  export type QuestListRelationFilter = {
    every?: QuestWhereInput
    some?: QuestWhereInput
    none?: QuestWhereInput
  }

  export type ChronicleListRelationFilter = {
    every?: ChronicleWhereInput
    some?: ChronicleWhereInput
    none?: ChronicleWhereInput
  }

  export type InteractionListRelationFilter = {
    every?: InteractionWhereInput
    some?: InteractionWhereInput
    none?: InteractionWhereInput
  }

  export type MonsterCampaignListRelationFilter = {
    every?: MonsterCampaignWhereInput
    some?: MonsterCampaignWhereInput
    none?: MonsterCampaignWhereInput
  }

  export type ItemCampaignListRelationFilter = {
    every?: ItemCampaignWhereInput
    some?: ItemCampaignWhereInput
    none?: ItemCampaignWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChronicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonsterCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coverImagePath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPlayedAt?: SortOrder
    settings?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coverImagePath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPlayedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    coverImagePath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPlayedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRaceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | null
    notIn?: $Enums.Race[] | null
    not?: NestedEnumRaceNullableFilter<$PrismaModel> | $Enums.Race | null
  }

  export type EnumCreatureTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreatureType[] | null
    notIn?: $Enums.CreatureType[] | null
    not?: NestedEnumCreatureTypeNullableFilter<$PrismaModel> | $Enums.CreatureType | null
  }

  export type EnumNPCRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCRole | EnumNPCRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCRole[] | null
    notIn?: $Enums.NPCRole[] | null
    not?: NestedEnumNPCRoleNullableFilter<$PrismaModel> | $Enums.NPCRole | null
  }

  export type EnumCharacterClassNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel> | null
    in?: $Enums.CharacterClass[] | null
    notIn?: $Enums.CharacterClass[] | null
    not?: NestedEnumCharacterClassNullableFilter<$PrismaModel> | $Enums.CharacterClass | null
  }

  export type EnumAlignmentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Alignment[] | null
    notIn?: $Enums.Alignment[] | null
    not?: NestedEnumAlignmentNullableFilter<$PrismaModel> | $Enums.Alignment | null
  }

  export type EnumNPCAttitudeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCAttitude | EnumNPCAttitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCAttitude[] | null
    notIn?: $Enums.NPCAttitude[] | null
    not?: NestedEnumNPCAttitudeNullableFilter<$PrismaModel> | $Enums.NPCAttitude | null
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type NPCLocationListRelationFilter = {
    every?: NPCLocationWhereInput
    some?: NPCLocationWhereInput
    none?: NPCLocationWhereInput
  }

  export type QuestNPCListRelationFilter = {
    every?: QuestNPCWhereInput
    some?: QuestNPCWhereInput
    none?: QuestNPCWhereInput
  }

  export type ItemNPCListRelationFilter = {
    every?: ItemNPCWhereInput
    some?: ItemNPCWhereInput
    none?: ItemNPCWhereInput
  }

  export type NPCLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestNPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemNPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NPCCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    title?: SortOrder
    race?: SortOrder
    creatureType?: SortOrder
    role?: SortOrder
    class?: SortOrder
    alignment?: SortOrder
    attitudeToParty?: SortOrder
    languages?: SortOrder
    appearance?: SortOrder
    personality?: SortOrder
    motivations?: SortOrder
    backstory?: SortOrder
    dmNotes?: SortOrder
    portraitPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NPCMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    title?: SortOrder
    race?: SortOrder
    creatureType?: SortOrder
    role?: SortOrder
    class?: SortOrder
    alignment?: SortOrder
    attitudeToParty?: SortOrder
    appearance?: SortOrder
    personality?: SortOrder
    motivations?: SortOrder
    backstory?: SortOrder
    dmNotes?: SortOrder
    portraitPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NPCMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    title?: SortOrder
    race?: SortOrder
    creatureType?: SortOrder
    role?: SortOrder
    class?: SortOrder
    alignment?: SortOrder
    attitudeToParty?: SortOrder
    appearance?: SortOrder
    personality?: SortOrder
    motivations?: SortOrder
    backstory?: SortOrder
    dmNotes?: SortOrder
    portraitPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRaceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | null
    notIn?: $Enums.Race[] | null
    not?: NestedEnumRaceNullableWithAggregatesFilter<$PrismaModel> | $Enums.Race | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRaceNullableFilter<$PrismaModel>
    _max?: NestedEnumRaceNullableFilter<$PrismaModel>
  }

  export type EnumCreatureTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreatureType[] | null
    notIn?: $Enums.CreatureType[] | null
    not?: NestedEnumCreatureTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CreatureType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCreatureTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCreatureTypeNullableFilter<$PrismaModel>
  }

  export type EnumNPCRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCRole | EnumNPCRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCRole[] | null
    notIn?: $Enums.NPCRole[] | null
    not?: NestedEnumNPCRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.NPCRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNPCRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumNPCRoleNullableFilter<$PrismaModel>
  }

  export type EnumCharacterClassNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel> | null
    in?: $Enums.CharacterClass[] | null
    notIn?: $Enums.CharacterClass[] | null
    not?: NestedEnumCharacterClassNullableWithAggregatesFilter<$PrismaModel> | $Enums.CharacterClass | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCharacterClassNullableFilter<$PrismaModel>
    _max?: NestedEnumCharacterClassNullableFilter<$PrismaModel>
  }

  export type EnumAlignmentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Alignment[] | null
    notIn?: $Enums.Alignment[] | null
    not?: NestedEnumAlignmentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Alignment | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAlignmentNullableFilter<$PrismaModel>
    _max?: NestedEnumAlignmentNullableFilter<$PrismaModel>
  }

  export type EnumNPCAttitudeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCAttitude | EnumNPCAttitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCAttitude[] | null
    notIn?: $Enums.NPCAttitude[] | null
    not?: NestedEnumNPCAttitudeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NPCAttitude | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNPCAttitudeNullableFilter<$PrismaModel>
    _max?: NestedEnumNPCAttitudeNullableFilter<$PrismaModel>
  }

  export type EnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type QuestLocationListRelationFilter = {
    every?: QuestLocationWhereInput
    some?: QuestLocationWhereInput
    none?: QuestLocationWhereInput
  }

  export type ItemLocationListRelationFilter = {
    every?: ItemLocationWhereInput
    some?: ItemLocationWhereInput
    none?: ItemLocationWhereInput
  }

  export type QuestLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentLocationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    notableFeatures?: SortOrder
    coverImagePath?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentLocationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    coverImagePath?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentLocationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    coverImagePath?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MapAnnotationListRelationFilter = {
    every?: MapAnnotationWhereInput
    some?: MapAnnotationWhereInput
    none?: MapAnnotationWhereInput
  }

  export type MapAnnotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    gridSize?: SortOrder
    gridEnabled?: SortOrder
    scale?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapAvgOrderByAggregateInput = {
    gridSize?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type MapMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    gridSize?: SortOrder
    gridEnabled?: SortOrder
    scale?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    gridSize?: SortOrder
    gridEnabled?: SortOrder
    scale?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MapSumOrderByAggregateInput = {
    gridSize?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumMapAnnotationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MapAnnotationType | EnumMapAnnotationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MapAnnotationType[]
    notIn?: $Enums.MapAnnotationType[]
    not?: NestedEnumMapAnnotationTypeFilter<$PrismaModel> | $Enums.MapAnnotationType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MapScalarRelationFilter = {
    is?: MapWhereInput
    isNot?: MapWhereInput
  }

  export type MapAnnotationCountOrderByAggregateInput = {
    id?: SortOrder
    mapId?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isHidden?: SortOrder
  }

  export type MapAnnotationAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type MapAnnotationMaxOrderByAggregateInput = {
    id?: SortOrder
    mapId?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isHidden?: SortOrder
  }

  export type MapAnnotationMinOrderByAggregateInput = {
    id?: SortOrder
    mapId?: SortOrder
    type?: SortOrder
    x?: SortOrder
    y?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isHidden?: SortOrder
  }

  export type MapAnnotationSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type EnumMapAnnotationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MapAnnotationType | EnumMapAnnotationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MapAnnotationType[]
    notIn?: $Enums.MapAnnotationType[]
    not?: NestedEnumMapAnnotationTypeWithAggregatesFilter<$PrismaModel> | $Enums.MapAnnotationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMapAnnotationTypeFilter<$PrismaModel>
    _max?: NestedEnumMapAnnotationTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[]
    notIn?: $Enums.Size[]
    not?: NestedEnumSizeFilter<$PrismaModel> | $Enums.Size
  }

  export type EnumCreatureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreatureType[]
    notIn?: $Enums.CreatureType[]
    not?: NestedEnumCreatureTypeFilter<$PrismaModel> | $Enums.CreatureType
  }

  export type EnumAlignmentFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.Alignment[]
    notIn?: $Enums.Alignment[]
    not?: NestedEnumAlignmentFilter<$PrismaModel> | $Enums.Alignment
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EncounterParticipantListRelationFilter = {
    every?: EncounterParticipantWhereInput
    some?: EncounterParticipantWhereInput
    none?: EncounterParticipantWhereInput
  }

  export type EncounterParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonsterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    size?: SortOrder
    creatureType?: SortOrder
    alignment?: SortOrder
    portraitPath?: SortOrder
    hpMax?: SortOrder
    hpDice?: SortOrder
    ac?: SortOrder
    acDescription?: SortOrder
    speed?: SortOrder
    abilities?: SortOrder
    savingThrows?: SortOrder
    skills?: SortOrder
    damageResistances?: SortOrder
    damageImmunities?: SortOrder
    conditionImmunities?: SortOrder
    senses?: SortOrder
    languages?: SortOrder
    challengeRating?: SortOrder
    actions?: SortOrder
    reactions?: SortOrder
    legendaryActions?: SortOrder
    description?: SortOrder
    dmNotes?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonsterAvgOrderByAggregateInput = {
    hpMax?: SortOrder
    ac?: SortOrder
    challengeRating?: SortOrder
  }

  export type MonsterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    size?: SortOrder
    creatureType?: SortOrder
    alignment?: SortOrder
    portraitPath?: SortOrder
    hpMax?: SortOrder
    hpDice?: SortOrder
    ac?: SortOrder
    acDescription?: SortOrder
    senses?: SortOrder
    challengeRating?: SortOrder
    description?: SortOrder
    dmNotes?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonsterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    size?: SortOrder
    creatureType?: SortOrder
    alignment?: SortOrder
    portraitPath?: SortOrder
    hpMax?: SortOrder
    hpDice?: SortOrder
    ac?: SortOrder
    acDescription?: SortOrder
    senses?: SortOrder
    challengeRating?: SortOrder
    description?: SortOrder
    dmNotes?: SortOrder
    isTemplate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MonsterSumOrderByAggregateInput = {
    hpMax?: SortOrder
    ac?: SortOrder
    challengeRating?: SortOrder
  }

  export type EnumSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[]
    notIn?: $Enums.Size[]
    not?: NestedEnumSizeWithAggregatesFilter<$PrismaModel> | $Enums.Size
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSizeFilter<$PrismaModel>
    _max?: NestedEnumSizeFilter<$PrismaModel>
  }

  export type EnumCreatureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreatureType[]
    notIn?: $Enums.CreatureType[]
    not?: NestedEnumCreatureTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreatureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatureTypeFilter<$PrismaModel>
    _max?: NestedEnumCreatureTypeFilter<$PrismaModel>
  }

  export type EnumAlignmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.Alignment[]
    notIn?: $Enums.Alignment[]
    not?: NestedEnumAlignmentWithAggregatesFilter<$PrismaModel> | $Enums.Alignment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlignmentFilter<$PrismaModel>
    _max?: NestedEnumAlignmentFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    mechanicalEffects?: SortOrder
    isCustom?: SortOrder
  }

  export type ConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    mechanicalEffects?: SortOrder
    isCustom?: SortOrder
  }

  export type ConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    mechanicalEffects?: SortOrder
    isCustom?: SortOrder
  }

  export type EnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type EnumEncounterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[]
    notIn?: $Enums.EncounterStatus[]
    not?: NestedEnumEncounterStatusFilter<$PrismaModel> | $Enums.EncounterStatus
  }

  export type MapNullableScalarRelationFilter = {
    is?: MapWhereInput | null
    isNot?: MapWhereInput | null
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mapId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mapId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    mapId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type EnumEncounterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[]
    notIn?: $Enums.EncounterStatus[]
    not?: NestedEnumEncounterStatusWithAggregatesFilter<$PrismaModel> | $Enums.EncounterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterStatusFilter<$PrismaModel>
    _max?: NestedEnumEncounterStatusFilter<$PrismaModel>
  }

  export type EnumParticipantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[]
    notIn?: $Enums.ParticipantType[]
    not?: NestedEnumParticipantTypeFilter<$PrismaModel> | $Enums.ParticipantType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EncounterScalarRelationFilter = {
    is?: EncounterWhereInput
    isNot?: EncounterWhereInput
  }

  export type MonsterNullableScalarRelationFilter = {
    is?: MonsterWhereInput | null
    isNot?: MonsterWhereInput | null
  }

  export type PlayerCharacterNullableScalarRelationFilter = {
    is?: PlayerCharacterWhereInput | null
    isNot?: PlayerCharacterWhereInput | null
  }

  export type EncounterParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    participantType?: SortOrder
    monsterId?: SortOrder
    playerCharacterId?: SortOrder
    customName?: SortOrder
    initiative?: SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    conditions?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    isVisible?: SortOrder
    dmNotes?: SortOrder
  }

  export type EncounterParticipantAvgOrderByAggregateInput = {
    initiative?: SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type EncounterParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    participantType?: SortOrder
    monsterId?: SortOrder
    playerCharacterId?: SortOrder
    customName?: SortOrder
    initiative?: SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    isVisible?: SortOrder
    dmNotes?: SortOrder
  }

  export type EncounterParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    participantType?: SortOrder
    monsterId?: SortOrder
    playerCharacterId?: SortOrder
    customName?: SortOrder
    initiative?: SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
    isVisible?: SortOrder
    dmNotes?: SortOrder
  }

  export type EncounterParticipantSumOrderByAggregateInput = {
    initiative?: SortOrder
    hpCurrent?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    positionX?: SortOrder
    positionY?: SortOrder
  }

  export type EnumParticipantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[]
    notIn?: $Enums.ParticipantType[]
    not?: NestedEnumParticipantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantTypeFilter<$PrismaModel>
    _max?: NestedEnumParticipantTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumRaceFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[]
    notIn?: $Enums.Race[]
    not?: NestedEnumRaceFilter<$PrismaModel> | $Enums.Race
  }

  export type EnumCharacterClassFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterClass[]
    notIn?: $Enums.CharacterClass[]
    not?: NestedEnumCharacterClassFilter<$PrismaModel> | $Enums.CharacterClass
  }

  export type EnumBackgroundTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundType | EnumBackgroundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundType[]
    notIn?: $Enums.BackgroundType[]
    not?: NestedEnumBackgroundTypeFilter<$PrismaModel> | $Enums.BackgroundType
  }

  export type PlayerCharacterCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    playerName?: SortOrder
    characterName?: SortOrder
    race?: SortOrder
    class?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    backgroundType?: SortOrder
    background?: SortOrder
    languages?: SortOrder
    portraitPath?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCharacterAvgOrderByAggregateInput = {
    level?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
  }

  export type PlayerCharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    playerName?: SortOrder
    characterName?: SortOrder
    race?: SortOrder
    class?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    backgroundType?: SortOrder
    background?: SortOrder
    portraitPath?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCharacterMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    playerName?: SortOrder
    characterName?: SortOrder
    race?: SortOrder
    class?: SortOrder
    level?: SortOrder
    alignment?: SortOrder
    backgroundType?: SortOrder
    background?: SortOrder
    portraitPath?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerCharacterSumOrderByAggregateInput = {
    level?: SortOrder
    hpMax?: SortOrder
    ac?: SortOrder
    passivePerception?: SortOrder
  }

  export type EnumRaceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[]
    notIn?: $Enums.Race[]
    not?: NestedEnumRaceWithAggregatesFilter<$PrismaModel> | $Enums.Race
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRaceFilter<$PrismaModel>
    _max?: NestedEnumRaceFilter<$PrismaModel>
  }

  export type EnumCharacterClassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterClass[]
    notIn?: $Enums.CharacterClass[]
    not?: NestedEnumCharacterClassWithAggregatesFilter<$PrismaModel> | $Enums.CharacterClass
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCharacterClassFilter<$PrismaModel>
    _max?: NestedEnumCharacterClassFilter<$PrismaModel>
  }

  export type EnumBackgroundTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundType | EnumBackgroundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundType[]
    notIn?: $Enums.BackgroundType[]
    not?: NestedEnumBackgroundTypeWithAggregatesFilter<$PrismaModel> | $Enums.BackgroundType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackgroundTypeFilter<$PrismaModel>
    _max?: NestedEnumBackgroundTypeFilter<$PrismaModel>
  }

  export type EnumQuestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestStatus | EnumQuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestStatus[]
    notIn?: $Enums.QuestStatus[]
    not?: NestedEnumQuestStatusFilter<$PrismaModel> | $Enums.QuestStatus
  }

  export type QuestNullableScalarRelationFilter = {
    is?: QuestWhereInput | null
    isNot?: QuestWhereInput | null
  }

  export type NPCNullableScalarRelationFilter = {
    is?: NPCWhereInput | null
    isNot?: NPCWhereInput | null
  }

  export type ChronicleQuestListRelationFilter = {
    every?: ChronicleQuestWhereInput
    some?: ChronicleQuestWhereInput
    none?: ChronicleQuestWhereInput
  }

  export type ChronicleQuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentQuestId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objectives?: SortOrder
    status?: SortOrder
    questGiverNpcId?: SortOrder
    rewardDescription?: SortOrder
    rewardItems?: SortOrder
    isMilestone?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuestMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentQuestId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    questGiverNpcId?: SortOrder
    rewardDescription?: SortOrder
    isMilestone?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuestMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    parentQuestId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    questGiverNpcId?: SortOrder
    rewardDescription?: SortOrder
    isMilestone?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumQuestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestStatus | EnumQuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestStatus[]
    notIn?: $Enums.QuestStatus[]
    not?: NestedEnumQuestStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestStatusFilter<$PrismaModel>
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type EnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[]
    notIn?: $Enums.ItemRarity[]
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type InteractionItemListRelationFilter = {
    every?: InteractionItemWhereInput
    some?: InteractionItemWhereInput
    none?: InteractionItemWhereInput
  }

  export type InteractionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    mechanicalEffects?: SortOrder
    grantedAbilities?: SortOrder
    value?: SortOrder
    weight?: SortOrder
    quantity?: SortOrder
    isMagical?: SortOrder
    attunementRequired?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    weight?: SortOrder
    quantity?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    mechanicalEffects?: SortOrder
    value?: SortOrder
    weight?: SortOrder
    quantity?: SortOrder
    isMagical?: SortOrder
    attunementRequired?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    rarity?: SortOrder
    description?: SortOrder
    mechanicalEffects?: SortOrder
    value?: SortOrder
    weight?: SortOrder
    quantity?: SortOrder
    isMagical?: SortOrder
    attunementRequired?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    weight?: SortOrder
    quantity?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type EnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[]
    notIn?: $Enums.ItemRarity[]
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type ChronicleCampaignIdSessionNumberCompoundUniqueInput = {
    campaignId: string
    sessionNumber: number
  }

  export type ChronicleCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sessionNumber?: SortOrder
    sessionDate?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    playerDeeds?: SortOrder
    importantDecisions?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChronicleAvgOrderByAggregateInput = {
    sessionNumber?: SortOrder
  }

  export type ChronicleMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sessionNumber?: SortOrder
    sessionDate?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChronicleMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    sessionNumber?: SortOrder
    sessionDate?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChronicleSumOrderByAggregateInput = {
    sessionNumber?: SortOrder
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NPCScalarRelationFilter = {
    is?: NPCWhereInput
    isNot?: NPCWhereInput
  }

  export type InteractionCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    npcId?: SortOrder
    interactionDate?: SortOrder
    sessionDate?: SortOrder
    interactionType?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    attitudeChange?: SortOrder
    involvedPcs?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    npcId?: SortOrder
    interactionDate?: SortOrder
    sessionDate?: SortOrder
    interactionType?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    attitudeChange?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    npcId?: SortOrder
    interactionDate?: SortOrder
    sessionDate?: SortOrder
    interactionType?: SortOrder
    summary?: SortOrder
    details?: SortOrder
    attitudeChange?: SortOrder
    dmNotes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type MonsterScalarRelationFilter = {
    is?: MonsterWhereInput
    isNot?: MonsterWhereInput
  }

  export type MonsterCampaignMonsterIdCampaignIdCompoundUniqueInput = {
    monsterId: string
    campaignId: string
  }

  export type MonsterCampaignCountOrderByAggregateInput = {
    monsterId?: SortOrder
    campaignId?: SortOrder
  }

  export type MonsterCampaignMaxOrderByAggregateInput = {
    monsterId?: SortOrder
    campaignId?: SortOrder
  }

  export type MonsterCampaignMinOrderByAggregateInput = {
    monsterId?: SortOrder
    campaignId?: SortOrder
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type ItemCampaignItemIdCampaignIdCompoundUniqueInput = {
    itemId: string
    campaignId: string
  }

  export type ItemCampaignCountOrderByAggregateInput = {
    itemId?: SortOrder
    campaignId?: SortOrder
  }

  export type ItemCampaignMaxOrderByAggregateInput = {
    itemId?: SortOrder
    campaignId?: SortOrder
  }

  export type ItemCampaignMinOrderByAggregateInput = {
    itemId?: SortOrder
    campaignId?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type NPCLocationNpcIdLocationIdCompoundUniqueInput = {
    npcId: string
    locationId: string
  }

  export type NPCLocationCountOrderByAggregateInput = {
    npcId?: SortOrder
    locationId?: SortOrder
    isPrimary?: SortOrder
  }

  export type NPCLocationMaxOrderByAggregateInput = {
    npcId?: SortOrder
    locationId?: SortOrder
    isPrimary?: SortOrder
  }

  export type NPCLocationMinOrderByAggregateInput = {
    npcId?: SortOrder
    locationId?: SortOrder
    isPrimary?: SortOrder
  }

  export type QuestScalarRelationFilter = {
    is?: QuestWhereInput
    isNot?: QuestWhereInput
  }

  export type QuestNPCQuestIdNpcIdCompoundUniqueInput = {
    questId: string
    npcId: string
  }

  export type QuestNPCCountOrderByAggregateInput = {
    questId?: SortOrder
    npcId?: SortOrder
    role?: SortOrder
  }

  export type QuestNPCMaxOrderByAggregateInput = {
    questId?: SortOrder
    npcId?: SortOrder
    role?: SortOrder
  }

  export type QuestNPCMinOrderByAggregateInput = {
    questId?: SortOrder
    npcId?: SortOrder
    role?: SortOrder
  }

  export type QuestLocationQuestIdLocationIdCompoundUniqueInput = {
    questId: string
    locationId: string
  }

  export type QuestLocationCountOrderByAggregateInput = {
    questId?: SortOrder
    locationId?: SortOrder
  }

  export type QuestLocationMaxOrderByAggregateInput = {
    questId?: SortOrder
    locationId?: SortOrder
  }

  export type QuestLocationMinOrderByAggregateInput = {
    questId?: SortOrder
    locationId?: SortOrder
  }

  export type ChronicleScalarRelationFilter = {
    is?: ChronicleWhereInput
    isNot?: ChronicleWhereInput
  }

  export type ChronicleQuestChronicleIdQuestIdCompoundUniqueInput = {
    chronicleId: string
    questId: string
  }

  export type ChronicleQuestCountOrderByAggregateInput = {
    chronicleId?: SortOrder
    questId?: SortOrder
    statusChange?: SortOrder
  }

  export type ChronicleQuestMaxOrderByAggregateInput = {
    chronicleId?: SortOrder
    questId?: SortOrder
    statusChange?: SortOrder
  }

  export type ChronicleQuestMinOrderByAggregateInput = {
    chronicleId?: SortOrder
    questId?: SortOrder
    statusChange?: SortOrder
  }

  export type ItemLocationItemIdLocationIdCompoundUniqueInput = {
    itemId: string
    locationId: string
  }

  export type ItemLocationCountOrderByAggregateInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    isHidden?: SortOrder
    notes?: SortOrder
  }

  export type ItemLocationMaxOrderByAggregateInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    isHidden?: SortOrder
    notes?: SortOrder
  }

  export type ItemLocationMinOrderByAggregateInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    isHidden?: SortOrder
    notes?: SortOrder
  }

  export type ItemNPCItemIdNpcIdCompoundUniqueInput = {
    itemId: string
    npcId: string
  }

  export type ItemNPCCountOrderByAggregateInput = {
    itemId?: SortOrder
    npcId?: SortOrder
  }

  export type ItemNPCMaxOrderByAggregateInput = {
    itemId?: SortOrder
    npcId?: SortOrder
  }

  export type ItemNPCMinOrderByAggregateInput = {
    itemId?: SortOrder
    npcId?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type InteractionScalarRelationFilter = {
    is?: InteractionWhereInput
    isNot?: InteractionWhereInput
  }

  export type InteractionItemInteractionIdItemIdCompoundUniqueInput = {
    interactionId: string
    itemId: string
  }

  export type InteractionItemCountOrderByAggregateInput = {
    interactionId?: SortOrder
    itemId?: SortOrder
    transactionType?: SortOrder
  }

  export type InteractionItemMaxOrderByAggregateInput = {
    interactionId?: SortOrder
    itemId?: SortOrder
    transactionType?: SortOrder
  }

  export type InteractionItemMinOrderByAggregateInput = {
    interactionId?: SortOrder
    itemId?: SortOrder
    transactionType?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NPCCreateNestedManyWithoutCampaignInput = {
    create?: XOR<NPCCreateWithoutCampaignInput, NPCUncheckedCreateWithoutCampaignInput> | NPCCreateWithoutCampaignInput[] | NPCUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCampaignInput | NPCCreateOrConnectWithoutCampaignInput[]
    createMany?: NPCCreateManyCampaignInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutCampaignInput = {
    create?: XOR<LocationCreateWithoutCampaignInput, LocationUncheckedCreateWithoutCampaignInput> | LocationCreateWithoutCampaignInput[] | LocationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCampaignInput | LocationCreateOrConnectWithoutCampaignInput[]
    createMany?: LocationCreateManyCampaignInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type MapCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MapCreateWithoutCampaignInput, MapUncheckedCreateWithoutCampaignInput> | MapCreateWithoutCampaignInput[] | MapUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCampaignInput | MapCreateOrConnectWithoutCampaignInput[]
    createMany?: MapCreateManyCampaignInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type PlayerCharacterCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PlayerCharacterCreateWithoutCampaignInput, PlayerCharacterUncheckedCreateWithoutCampaignInput> | PlayerCharacterCreateWithoutCampaignInput[] | PlayerCharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PlayerCharacterCreateOrConnectWithoutCampaignInput | PlayerCharacterCreateOrConnectWithoutCampaignInput[]
    createMany?: PlayerCharacterCreateManyCampaignInputEnvelope
    connect?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutCampaignInput = {
    create?: XOR<QuestCreateWithoutCampaignInput, QuestUncheckedCreateWithoutCampaignInput> | QuestCreateWithoutCampaignInput[] | QuestUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCampaignInput | QuestCreateOrConnectWithoutCampaignInput[]
    createMany?: QuestCreateManyCampaignInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type ChronicleCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ChronicleCreateWithoutCampaignInput, ChronicleUncheckedCreateWithoutCampaignInput> | ChronicleCreateWithoutCampaignInput[] | ChronicleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChronicleCreateOrConnectWithoutCampaignInput | ChronicleCreateOrConnectWithoutCampaignInput[]
    createMany?: ChronicleCreateManyCampaignInputEnvelope
    connect?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
  }

  export type InteractionCreateNestedManyWithoutCampaignInput = {
    create?: XOR<InteractionCreateWithoutCampaignInput, InteractionUncheckedCreateWithoutCampaignInput> | InteractionCreateWithoutCampaignInput[] | InteractionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCampaignInput | InteractionCreateOrConnectWithoutCampaignInput[]
    createMany?: InteractionCreateManyCampaignInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type MonsterCampaignCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MonsterCampaignCreateWithoutCampaignInput, MonsterCampaignUncheckedCreateWithoutCampaignInput> | MonsterCampaignCreateWithoutCampaignInput[] | MonsterCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutCampaignInput | MonsterCampaignCreateOrConnectWithoutCampaignInput[]
    createMany?: MonsterCampaignCreateManyCampaignInputEnvelope
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
  }

  export type ItemCampaignCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ItemCampaignCreateWithoutCampaignInput, ItemCampaignUncheckedCreateWithoutCampaignInput> | ItemCampaignCreateWithoutCampaignInput[] | ItemCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutCampaignInput | ItemCampaignCreateOrConnectWithoutCampaignInput[]
    createMany?: ItemCampaignCreateManyCampaignInputEnvelope
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
  }

  export type NPCUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<NPCCreateWithoutCampaignInput, NPCUncheckedCreateWithoutCampaignInput> | NPCCreateWithoutCampaignInput[] | NPCUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCampaignInput | NPCCreateOrConnectWithoutCampaignInput[]
    createMany?: NPCCreateManyCampaignInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<LocationCreateWithoutCampaignInput, LocationUncheckedCreateWithoutCampaignInput> | LocationCreateWithoutCampaignInput[] | LocationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCampaignInput | LocationCreateOrConnectWithoutCampaignInput[]
    createMany?: LocationCreateManyCampaignInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type MapUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MapCreateWithoutCampaignInput, MapUncheckedCreateWithoutCampaignInput> | MapCreateWithoutCampaignInput[] | MapUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCampaignInput | MapCreateOrConnectWithoutCampaignInput[]
    createMany?: MapCreateManyCampaignInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<PlayerCharacterCreateWithoutCampaignInput, PlayerCharacterUncheckedCreateWithoutCampaignInput> | PlayerCharacterCreateWithoutCampaignInput[] | PlayerCharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PlayerCharacterCreateOrConnectWithoutCampaignInput | PlayerCharacterCreateOrConnectWithoutCampaignInput[]
    createMany?: PlayerCharacterCreateManyCampaignInputEnvelope
    connect?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<QuestCreateWithoutCampaignInput, QuestUncheckedCreateWithoutCampaignInput> | QuestCreateWithoutCampaignInput[] | QuestUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCampaignInput | QuestCreateOrConnectWithoutCampaignInput[]
    createMany?: QuestCreateManyCampaignInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type ChronicleUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ChronicleCreateWithoutCampaignInput, ChronicleUncheckedCreateWithoutCampaignInput> | ChronicleCreateWithoutCampaignInput[] | ChronicleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChronicleCreateOrConnectWithoutCampaignInput | ChronicleCreateOrConnectWithoutCampaignInput[]
    createMany?: ChronicleCreateManyCampaignInputEnvelope
    connect?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<InteractionCreateWithoutCampaignInput, InteractionUncheckedCreateWithoutCampaignInput> | InteractionCreateWithoutCampaignInput[] | InteractionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCampaignInput | InteractionCreateOrConnectWithoutCampaignInput[]
    createMany?: InteractionCreateManyCampaignInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MonsterCampaignCreateWithoutCampaignInput, MonsterCampaignUncheckedCreateWithoutCampaignInput> | MonsterCampaignCreateWithoutCampaignInput[] | MonsterCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutCampaignInput | MonsterCampaignCreateOrConnectWithoutCampaignInput[]
    createMany?: MonsterCampaignCreateManyCampaignInputEnvelope
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
  }

  export type ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ItemCampaignCreateWithoutCampaignInput, ItemCampaignUncheckedCreateWithoutCampaignInput> | ItemCampaignCreateWithoutCampaignInput[] | ItemCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutCampaignInput | ItemCampaignCreateOrConnectWithoutCampaignInput[]
    createMany?: ItemCampaignCreateManyCampaignInputEnvelope
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NPCUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<NPCCreateWithoutCampaignInput, NPCUncheckedCreateWithoutCampaignInput> | NPCCreateWithoutCampaignInput[] | NPCUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCampaignInput | NPCCreateOrConnectWithoutCampaignInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutCampaignInput | NPCUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: NPCCreateManyCampaignInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutCampaignInput | NPCUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutCampaignInput | NPCUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<LocationCreateWithoutCampaignInput, LocationUncheckedCreateWithoutCampaignInput> | LocationCreateWithoutCampaignInput[] | LocationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCampaignInput | LocationCreateOrConnectWithoutCampaignInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCampaignInput | LocationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: LocationCreateManyCampaignInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCampaignInput | LocationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCampaignInput | LocationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MapUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MapCreateWithoutCampaignInput, MapUncheckedCreateWithoutCampaignInput> | MapCreateWithoutCampaignInput[] | MapUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCampaignInput | MapCreateOrConnectWithoutCampaignInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutCampaignInput | MapUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MapCreateManyCampaignInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutCampaignInput | MapUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MapUpdateManyWithWhereWithoutCampaignInput | MapUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutCampaignInput | EncounterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutCampaignInput | EncounterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutCampaignInput | EncounterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type PlayerCharacterUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PlayerCharacterCreateWithoutCampaignInput, PlayerCharacterUncheckedCreateWithoutCampaignInput> | PlayerCharacterCreateWithoutCampaignInput[] | PlayerCharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PlayerCharacterCreateOrConnectWithoutCampaignInput | PlayerCharacterCreateOrConnectWithoutCampaignInput[]
    upsert?: PlayerCharacterUpsertWithWhereUniqueWithoutCampaignInput | PlayerCharacterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PlayerCharacterCreateManyCampaignInputEnvelope
    set?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    disconnect?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    delete?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    connect?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    update?: PlayerCharacterUpdateWithWhereUniqueWithoutCampaignInput | PlayerCharacterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PlayerCharacterUpdateManyWithWhereWithoutCampaignInput | PlayerCharacterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PlayerCharacterScalarWhereInput | PlayerCharacterScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<QuestCreateWithoutCampaignInput, QuestUncheckedCreateWithoutCampaignInput> | QuestCreateWithoutCampaignInput[] | QuestUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCampaignInput | QuestCreateOrConnectWithoutCampaignInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutCampaignInput | QuestUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: QuestCreateManyCampaignInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutCampaignInput | QuestUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutCampaignInput | QuestUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type ChronicleUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ChronicleCreateWithoutCampaignInput, ChronicleUncheckedCreateWithoutCampaignInput> | ChronicleCreateWithoutCampaignInput[] | ChronicleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChronicleCreateOrConnectWithoutCampaignInput | ChronicleCreateOrConnectWithoutCampaignInput[]
    upsert?: ChronicleUpsertWithWhereUniqueWithoutCampaignInput | ChronicleUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ChronicleCreateManyCampaignInputEnvelope
    set?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    disconnect?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    delete?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    connect?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    update?: ChronicleUpdateWithWhereUniqueWithoutCampaignInput | ChronicleUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ChronicleUpdateManyWithWhereWithoutCampaignInput | ChronicleUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ChronicleScalarWhereInput | ChronicleScalarWhereInput[]
  }

  export type InteractionUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<InteractionCreateWithoutCampaignInput, InteractionUncheckedCreateWithoutCampaignInput> | InteractionCreateWithoutCampaignInput[] | InteractionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCampaignInput | InteractionCreateOrConnectWithoutCampaignInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutCampaignInput | InteractionUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: InteractionCreateManyCampaignInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutCampaignInput | InteractionUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutCampaignInput | InteractionUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type MonsterCampaignUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MonsterCampaignCreateWithoutCampaignInput, MonsterCampaignUncheckedCreateWithoutCampaignInput> | MonsterCampaignCreateWithoutCampaignInput[] | MonsterCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutCampaignInput | MonsterCampaignCreateOrConnectWithoutCampaignInput[]
    upsert?: MonsterCampaignUpsertWithWhereUniqueWithoutCampaignInput | MonsterCampaignUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MonsterCampaignCreateManyCampaignInputEnvelope
    set?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    disconnect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    delete?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    update?: MonsterCampaignUpdateWithWhereUniqueWithoutCampaignInput | MonsterCampaignUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MonsterCampaignUpdateManyWithWhereWithoutCampaignInput | MonsterCampaignUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MonsterCampaignScalarWhereInput | MonsterCampaignScalarWhereInput[]
  }

  export type ItemCampaignUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ItemCampaignCreateWithoutCampaignInput, ItemCampaignUncheckedCreateWithoutCampaignInput> | ItemCampaignCreateWithoutCampaignInput[] | ItemCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutCampaignInput | ItemCampaignCreateOrConnectWithoutCampaignInput[]
    upsert?: ItemCampaignUpsertWithWhereUniqueWithoutCampaignInput | ItemCampaignUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ItemCampaignCreateManyCampaignInputEnvelope
    set?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    disconnect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    delete?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    update?: ItemCampaignUpdateWithWhereUniqueWithoutCampaignInput | ItemCampaignUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ItemCampaignUpdateManyWithWhereWithoutCampaignInput | ItemCampaignUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ItemCampaignScalarWhereInput | ItemCampaignScalarWhereInput[]
  }

  export type NPCUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<NPCCreateWithoutCampaignInput, NPCUncheckedCreateWithoutCampaignInput> | NPCCreateWithoutCampaignInput[] | NPCUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutCampaignInput | NPCCreateOrConnectWithoutCampaignInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutCampaignInput | NPCUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: NPCCreateManyCampaignInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutCampaignInput | NPCUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutCampaignInput | NPCUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<LocationCreateWithoutCampaignInput, LocationUncheckedCreateWithoutCampaignInput> | LocationCreateWithoutCampaignInput[] | LocationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCampaignInput | LocationCreateOrConnectWithoutCampaignInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCampaignInput | LocationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: LocationCreateManyCampaignInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCampaignInput | LocationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCampaignInput | LocationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MapUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MapCreateWithoutCampaignInput, MapUncheckedCreateWithoutCampaignInput> | MapCreateWithoutCampaignInput[] | MapUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCampaignInput | MapCreateOrConnectWithoutCampaignInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutCampaignInput | MapUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MapCreateManyCampaignInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutCampaignInput | MapUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MapUpdateManyWithWhereWithoutCampaignInput | MapUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutCampaignInput | EncounterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutCampaignInput | EncounterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutCampaignInput | EncounterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<PlayerCharacterCreateWithoutCampaignInput, PlayerCharacterUncheckedCreateWithoutCampaignInput> | PlayerCharacterCreateWithoutCampaignInput[] | PlayerCharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: PlayerCharacterCreateOrConnectWithoutCampaignInput | PlayerCharacterCreateOrConnectWithoutCampaignInput[]
    upsert?: PlayerCharacterUpsertWithWhereUniqueWithoutCampaignInput | PlayerCharacterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: PlayerCharacterCreateManyCampaignInputEnvelope
    set?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    disconnect?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    delete?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    connect?: PlayerCharacterWhereUniqueInput | PlayerCharacterWhereUniqueInput[]
    update?: PlayerCharacterUpdateWithWhereUniqueWithoutCampaignInput | PlayerCharacterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: PlayerCharacterUpdateManyWithWhereWithoutCampaignInput | PlayerCharacterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: PlayerCharacterScalarWhereInput | PlayerCharacterScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<QuestCreateWithoutCampaignInput, QuestUncheckedCreateWithoutCampaignInput> | QuestCreateWithoutCampaignInput[] | QuestUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutCampaignInput | QuestCreateOrConnectWithoutCampaignInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutCampaignInput | QuestUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: QuestCreateManyCampaignInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutCampaignInput | QuestUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutCampaignInput | QuestUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type ChronicleUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ChronicleCreateWithoutCampaignInput, ChronicleUncheckedCreateWithoutCampaignInput> | ChronicleCreateWithoutCampaignInput[] | ChronicleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ChronicleCreateOrConnectWithoutCampaignInput | ChronicleCreateOrConnectWithoutCampaignInput[]
    upsert?: ChronicleUpsertWithWhereUniqueWithoutCampaignInput | ChronicleUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ChronicleCreateManyCampaignInputEnvelope
    set?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    disconnect?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    delete?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    connect?: ChronicleWhereUniqueInput | ChronicleWhereUniqueInput[]
    update?: ChronicleUpdateWithWhereUniqueWithoutCampaignInput | ChronicleUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ChronicleUpdateManyWithWhereWithoutCampaignInput | ChronicleUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ChronicleScalarWhereInput | ChronicleScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<InteractionCreateWithoutCampaignInput, InteractionUncheckedCreateWithoutCampaignInput> | InteractionCreateWithoutCampaignInput[] | InteractionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutCampaignInput | InteractionCreateOrConnectWithoutCampaignInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutCampaignInput | InteractionUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: InteractionCreateManyCampaignInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutCampaignInput | InteractionUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutCampaignInput | InteractionUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MonsterCampaignCreateWithoutCampaignInput, MonsterCampaignUncheckedCreateWithoutCampaignInput> | MonsterCampaignCreateWithoutCampaignInput[] | MonsterCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutCampaignInput | MonsterCampaignCreateOrConnectWithoutCampaignInput[]
    upsert?: MonsterCampaignUpsertWithWhereUniqueWithoutCampaignInput | MonsterCampaignUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MonsterCampaignCreateManyCampaignInputEnvelope
    set?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    disconnect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    delete?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    update?: MonsterCampaignUpdateWithWhereUniqueWithoutCampaignInput | MonsterCampaignUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MonsterCampaignUpdateManyWithWhereWithoutCampaignInput | MonsterCampaignUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MonsterCampaignScalarWhereInput | MonsterCampaignScalarWhereInput[]
  }

  export type ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ItemCampaignCreateWithoutCampaignInput, ItemCampaignUncheckedCreateWithoutCampaignInput> | ItemCampaignCreateWithoutCampaignInput[] | ItemCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutCampaignInput | ItemCampaignCreateOrConnectWithoutCampaignInput[]
    upsert?: ItemCampaignUpsertWithWhereUniqueWithoutCampaignInput | ItemCampaignUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ItemCampaignCreateManyCampaignInputEnvelope
    set?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    disconnect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    delete?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    update?: ItemCampaignUpdateWithWhereUniqueWithoutCampaignInput | ItemCampaignUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ItemCampaignUpdateManyWithWhereWithoutCampaignInput | ItemCampaignUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ItemCampaignScalarWhereInput | ItemCampaignScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutNpcsInput = {
    create?: XOR<CampaignCreateWithoutNpcsInput, CampaignUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutNpcsInput
    connect?: CampaignWhereUniqueInput
  }

  export type NPCLocationCreateNestedManyWithoutNpcInput = {
    create?: XOR<NPCLocationCreateWithoutNpcInput, NPCLocationUncheckedCreateWithoutNpcInput> | NPCLocationCreateWithoutNpcInput[] | NPCLocationUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutNpcInput | NPCLocationCreateOrConnectWithoutNpcInput[]
    createMany?: NPCLocationCreateManyNpcInputEnvelope
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
  }

  export type QuestCreateNestedManyWithoutQuestGiverInput = {
    create?: XOR<QuestCreateWithoutQuestGiverInput, QuestUncheckedCreateWithoutQuestGiverInput> | QuestCreateWithoutQuestGiverInput[] | QuestUncheckedCreateWithoutQuestGiverInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutQuestGiverInput | QuestCreateOrConnectWithoutQuestGiverInput[]
    createMany?: QuestCreateManyQuestGiverInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type QuestNPCCreateNestedManyWithoutNpcInput = {
    create?: XOR<QuestNPCCreateWithoutNpcInput, QuestNPCUncheckedCreateWithoutNpcInput> | QuestNPCCreateWithoutNpcInput[] | QuestNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutNpcInput | QuestNPCCreateOrConnectWithoutNpcInput[]
    createMany?: QuestNPCCreateManyNpcInputEnvelope
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
  }

  export type InteractionCreateNestedManyWithoutNpcInput = {
    create?: XOR<InteractionCreateWithoutNpcInput, InteractionUncheckedCreateWithoutNpcInput> | InteractionCreateWithoutNpcInput[] | InteractionUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutNpcInput | InteractionCreateOrConnectWithoutNpcInput[]
    createMany?: InteractionCreateManyNpcInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type ItemNPCCreateNestedManyWithoutNpcInput = {
    create?: XOR<ItemNPCCreateWithoutNpcInput, ItemNPCUncheckedCreateWithoutNpcInput> | ItemNPCCreateWithoutNpcInput[] | ItemNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutNpcInput | ItemNPCCreateOrConnectWithoutNpcInput[]
    createMany?: ItemNPCCreateManyNpcInputEnvelope
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
  }

  export type NPCLocationUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<NPCLocationCreateWithoutNpcInput, NPCLocationUncheckedCreateWithoutNpcInput> | NPCLocationCreateWithoutNpcInput[] | NPCLocationUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutNpcInput | NPCLocationCreateOrConnectWithoutNpcInput[]
    createMany?: NPCLocationCreateManyNpcInputEnvelope
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutQuestGiverInput = {
    create?: XOR<QuestCreateWithoutQuestGiverInput, QuestUncheckedCreateWithoutQuestGiverInput> | QuestCreateWithoutQuestGiverInput[] | QuestUncheckedCreateWithoutQuestGiverInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutQuestGiverInput | QuestCreateOrConnectWithoutQuestGiverInput[]
    createMany?: QuestCreateManyQuestGiverInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type QuestNPCUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<QuestNPCCreateWithoutNpcInput, QuestNPCUncheckedCreateWithoutNpcInput> | QuestNPCCreateWithoutNpcInput[] | QuestNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutNpcInput | QuestNPCCreateOrConnectWithoutNpcInput[]
    createMany?: QuestNPCCreateManyNpcInputEnvelope
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<InteractionCreateWithoutNpcInput, InteractionUncheckedCreateWithoutNpcInput> | InteractionCreateWithoutNpcInput[] | InteractionUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutNpcInput | InteractionCreateOrConnectWithoutNpcInput[]
    createMany?: InteractionCreateManyNpcInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type ItemNPCUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<ItemNPCCreateWithoutNpcInput, ItemNPCUncheckedCreateWithoutNpcInput> | ItemNPCCreateWithoutNpcInput[] | ItemNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutNpcInput | ItemNPCCreateOrConnectWithoutNpcInput[]
    createMany?: ItemNPCCreateManyNpcInputEnvelope
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
  }

  export type NullableEnumRaceFieldUpdateOperationsInput = {
    set?: $Enums.Race | null
  }

  export type NullableEnumCreatureTypeFieldUpdateOperationsInput = {
    set?: $Enums.CreatureType | null
  }

  export type NullableEnumNPCRoleFieldUpdateOperationsInput = {
    set?: $Enums.NPCRole | null
  }

  export type NullableEnumCharacterClassFieldUpdateOperationsInput = {
    set?: $Enums.CharacterClass | null
  }

  export type NullableEnumAlignmentFieldUpdateOperationsInput = {
    set?: $Enums.Alignment | null
  }

  export type NullableEnumNPCAttitudeFieldUpdateOperationsInput = {
    set?: $Enums.NPCAttitude | null
  }

  export type CampaignUpdateOneRequiredWithoutNpcsNestedInput = {
    create?: XOR<CampaignCreateWithoutNpcsInput, CampaignUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutNpcsInput
    upsert?: CampaignUpsertWithoutNpcsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutNpcsInput, CampaignUpdateWithoutNpcsInput>, CampaignUncheckedUpdateWithoutNpcsInput>
  }

  export type NPCLocationUpdateManyWithoutNpcNestedInput = {
    create?: XOR<NPCLocationCreateWithoutNpcInput, NPCLocationUncheckedCreateWithoutNpcInput> | NPCLocationCreateWithoutNpcInput[] | NPCLocationUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutNpcInput | NPCLocationCreateOrConnectWithoutNpcInput[]
    upsert?: NPCLocationUpsertWithWhereUniqueWithoutNpcInput | NPCLocationUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: NPCLocationCreateManyNpcInputEnvelope
    set?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    disconnect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    delete?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    update?: NPCLocationUpdateWithWhereUniqueWithoutNpcInput | NPCLocationUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: NPCLocationUpdateManyWithWhereWithoutNpcInput | NPCLocationUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: NPCLocationScalarWhereInput | NPCLocationScalarWhereInput[]
  }

  export type QuestUpdateManyWithoutQuestGiverNestedInput = {
    create?: XOR<QuestCreateWithoutQuestGiverInput, QuestUncheckedCreateWithoutQuestGiverInput> | QuestCreateWithoutQuestGiverInput[] | QuestUncheckedCreateWithoutQuestGiverInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutQuestGiverInput | QuestCreateOrConnectWithoutQuestGiverInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutQuestGiverInput | QuestUpsertWithWhereUniqueWithoutQuestGiverInput[]
    createMany?: QuestCreateManyQuestGiverInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutQuestGiverInput | QuestUpdateWithWhereUniqueWithoutQuestGiverInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutQuestGiverInput | QuestUpdateManyWithWhereWithoutQuestGiverInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type QuestNPCUpdateManyWithoutNpcNestedInput = {
    create?: XOR<QuestNPCCreateWithoutNpcInput, QuestNPCUncheckedCreateWithoutNpcInput> | QuestNPCCreateWithoutNpcInput[] | QuestNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutNpcInput | QuestNPCCreateOrConnectWithoutNpcInput[]
    upsert?: QuestNPCUpsertWithWhereUniqueWithoutNpcInput | QuestNPCUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: QuestNPCCreateManyNpcInputEnvelope
    set?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    disconnect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    delete?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    update?: QuestNPCUpdateWithWhereUniqueWithoutNpcInput | QuestNPCUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: QuestNPCUpdateManyWithWhereWithoutNpcInput | QuestNPCUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: QuestNPCScalarWhereInput | QuestNPCScalarWhereInput[]
  }

  export type InteractionUpdateManyWithoutNpcNestedInput = {
    create?: XOR<InteractionCreateWithoutNpcInput, InteractionUncheckedCreateWithoutNpcInput> | InteractionCreateWithoutNpcInput[] | InteractionUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutNpcInput | InteractionCreateOrConnectWithoutNpcInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutNpcInput | InteractionUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: InteractionCreateManyNpcInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutNpcInput | InteractionUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutNpcInput | InteractionUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type ItemNPCUpdateManyWithoutNpcNestedInput = {
    create?: XOR<ItemNPCCreateWithoutNpcInput, ItemNPCUncheckedCreateWithoutNpcInput> | ItemNPCCreateWithoutNpcInput[] | ItemNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutNpcInput | ItemNPCCreateOrConnectWithoutNpcInput[]
    upsert?: ItemNPCUpsertWithWhereUniqueWithoutNpcInput | ItemNPCUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: ItemNPCCreateManyNpcInputEnvelope
    set?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    disconnect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    delete?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    update?: ItemNPCUpdateWithWhereUniqueWithoutNpcInput | ItemNPCUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: ItemNPCUpdateManyWithWhereWithoutNpcInput | ItemNPCUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: ItemNPCScalarWhereInput | ItemNPCScalarWhereInput[]
  }

  export type NPCLocationUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<NPCLocationCreateWithoutNpcInput, NPCLocationUncheckedCreateWithoutNpcInput> | NPCLocationCreateWithoutNpcInput[] | NPCLocationUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutNpcInput | NPCLocationCreateOrConnectWithoutNpcInput[]
    upsert?: NPCLocationUpsertWithWhereUniqueWithoutNpcInput | NPCLocationUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: NPCLocationCreateManyNpcInputEnvelope
    set?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    disconnect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    delete?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    update?: NPCLocationUpdateWithWhereUniqueWithoutNpcInput | NPCLocationUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: NPCLocationUpdateManyWithWhereWithoutNpcInput | NPCLocationUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: NPCLocationScalarWhereInput | NPCLocationScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutQuestGiverNestedInput = {
    create?: XOR<QuestCreateWithoutQuestGiverInput, QuestUncheckedCreateWithoutQuestGiverInput> | QuestCreateWithoutQuestGiverInput[] | QuestUncheckedCreateWithoutQuestGiverInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutQuestGiverInput | QuestCreateOrConnectWithoutQuestGiverInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutQuestGiverInput | QuestUpsertWithWhereUniqueWithoutQuestGiverInput[]
    createMany?: QuestCreateManyQuestGiverInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutQuestGiverInput | QuestUpdateWithWhereUniqueWithoutQuestGiverInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutQuestGiverInput | QuestUpdateManyWithWhereWithoutQuestGiverInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type QuestNPCUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<QuestNPCCreateWithoutNpcInput, QuestNPCUncheckedCreateWithoutNpcInput> | QuestNPCCreateWithoutNpcInput[] | QuestNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutNpcInput | QuestNPCCreateOrConnectWithoutNpcInput[]
    upsert?: QuestNPCUpsertWithWhereUniqueWithoutNpcInput | QuestNPCUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: QuestNPCCreateManyNpcInputEnvelope
    set?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    disconnect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    delete?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    update?: QuestNPCUpdateWithWhereUniqueWithoutNpcInput | QuestNPCUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: QuestNPCUpdateManyWithWhereWithoutNpcInput | QuestNPCUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: QuestNPCScalarWhereInput | QuestNPCScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<InteractionCreateWithoutNpcInput, InteractionUncheckedCreateWithoutNpcInput> | InteractionCreateWithoutNpcInput[] | InteractionUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutNpcInput | InteractionCreateOrConnectWithoutNpcInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutNpcInput | InteractionUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: InteractionCreateManyNpcInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutNpcInput | InteractionUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutNpcInput | InteractionUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type ItemNPCUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<ItemNPCCreateWithoutNpcInput, ItemNPCUncheckedCreateWithoutNpcInput> | ItemNPCCreateWithoutNpcInput[] | ItemNPCUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutNpcInput | ItemNPCCreateOrConnectWithoutNpcInput[]
    upsert?: ItemNPCUpsertWithWhereUniqueWithoutNpcInput | ItemNPCUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: ItemNPCCreateManyNpcInputEnvelope
    set?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    disconnect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    delete?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    update?: ItemNPCUpdateWithWhereUniqueWithoutNpcInput | ItemNPCUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: ItemNPCUpdateManyWithWhereWithoutNpcInput | ItemNPCUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: ItemNPCScalarWhereInput | ItemNPCScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutLocationsInput = {
    create?: XOR<CampaignCreateWithoutLocationsInput, CampaignUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLocationsInput
    connect?: CampaignWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutChildLocationsInput = {
    create?: XOR<LocationCreateWithoutChildLocationsInput, LocationUncheckedCreateWithoutChildLocationsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutChildLocationsInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedManyWithoutParentLocationInput = {
    create?: XOR<LocationCreateWithoutParentLocationInput, LocationUncheckedCreateWithoutParentLocationInput> | LocationCreateWithoutParentLocationInput[] | LocationUncheckedCreateWithoutParentLocationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentLocationInput | LocationCreateOrConnectWithoutParentLocationInput[]
    createMany?: LocationCreateManyParentLocationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type MapCreateNestedManyWithoutLocationInput = {
    create?: XOR<MapCreateWithoutLocationInput, MapUncheckedCreateWithoutLocationInput> | MapCreateWithoutLocationInput[] | MapUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MapCreateOrConnectWithoutLocationInput | MapCreateOrConnectWithoutLocationInput[]
    createMany?: MapCreateManyLocationInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutLocationInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type NPCLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<NPCLocationCreateWithoutLocationInput, NPCLocationUncheckedCreateWithoutLocationInput> | NPCLocationCreateWithoutLocationInput[] | NPCLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutLocationInput | NPCLocationCreateOrConnectWithoutLocationInput[]
    createMany?: NPCLocationCreateManyLocationInputEnvelope
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
  }

  export type QuestLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<QuestLocationCreateWithoutLocationInput, QuestLocationUncheckedCreateWithoutLocationInput> | QuestLocationCreateWithoutLocationInput[] | QuestLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutLocationInput | QuestLocationCreateOrConnectWithoutLocationInput[]
    createMany?: QuestLocationCreateManyLocationInputEnvelope
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
  }

  export type ItemLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<ItemLocationCreateWithoutLocationInput, ItemLocationUncheckedCreateWithoutLocationInput> | ItemLocationCreateWithoutLocationInput[] | ItemLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutLocationInput | ItemLocationCreateOrConnectWithoutLocationInput[]
    createMany?: ItemLocationCreateManyLocationInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutParentLocationInput = {
    create?: XOR<LocationCreateWithoutParentLocationInput, LocationUncheckedCreateWithoutParentLocationInput> | LocationCreateWithoutParentLocationInput[] | LocationUncheckedCreateWithoutParentLocationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentLocationInput | LocationCreateOrConnectWithoutParentLocationInput[]
    createMany?: LocationCreateManyParentLocationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type MapUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<MapCreateWithoutLocationInput, MapUncheckedCreateWithoutLocationInput> | MapCreateWithoutLocationInput[] | MapUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MapCreateOrConnectWithoutLocationInput | MapCreateOrConnectWithoutLocationInput[]
    createMany?: MapCreateManyLocationInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type NPCLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<NPCLocationCreateWithoutLocationInput, NPCLocationUncheckedCreateWithoutLocationInput> | NPCLocationCreateWithoutLocationInput[] | NPCLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutLocationInput | NPCLocationCreateOrConnectWithoutLocationInput[]
    createMany?: NPCLocationCreateManyLocationInputEnvelope
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
  }

  export type QuestLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<QuestLocationCreateWithoutLocationInput, QuestLocationUncheckedCreateWithoutLocationInput> | QuestLocationCreateWithoutLocationInput[] | QuestLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutLocationInput | QuestLocationCreateOrConnectWithoutLocationInput[]
    createMany?: QuestLocationCreateManyLocationInputEnvelope
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
  }

  export type ItemLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ItemLocationCreateWithoutLocationInput, ItemLocationUncheckedCreateWithoutLocationInput> | ItemLocationCreateWithoutLocationInput[] | ItemLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutLocationInput | ItemLocationCreateOrConnectWithoutLocationInput[]
    createMany?: ItemLocationCreateManyLocationInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type EnumLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.LocationType
  }

  export type CampaignUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<CampaignCreateWithoutLocationsInput, CampaignUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLocationsInput
    upsert?: CampaignUpsertWithoutLocationsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLocationsInput, CampaignUpdateWithoutLocationsInput>, CampaignUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneWithoutChildLocationsNestedInput = {
    create?: XOR<LocationCreateWithoutChildLocationsInput, LocationUncheckedCreateWithoutChildLocationsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutChildLocationsInput
    upsert?: LocationUpsertWithoutChildLocationsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutChildLocationsInput, LocationUpdateWithoutChildLocationsInput>, LocationUncheckedUpdateWithoutChildLocationsInput>
  }

  export type LocationUpdateManyWithoutParentLocationNestedInput = {
    create?: XOR<LocationCreateWithoutParentLocationInput, LocationUncheckedCreateWithoutParentLocationInput> | LocationCreateWithoutParentLocationInput[] | LocationUncheckedCreateWithoutParentLocationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentLocationInput | LocationCreateOrConnectWithoutParentLocationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutParentLocationInput | LocationUpsertWithWhereUniqueWithoutParentLocationInput[]
    createMany?: LocationCreateManyParentLocationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutParentLocationInput | LocationUpdateWithWhereUniqueWithoutParentLocationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutParentLocationInput | LocationUpdateManyWithWhereWithoutParentLocationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MapUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MapCreateWithoutLocationInput, MapUncheckedCreateWithoutLocationInput> | MapCreateWithoutLocationInput[] | MapUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MapCreateOrConnectWithoutLocationInput | MapCreateOrConnectWithoutLocationInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutLocationInput | MapUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MapCreateManyLocationInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutLocationInput | MapUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MapUpdateManyWithWhereWithoutLocationInput | MapUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutLocationInput | EncounterUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutLocationInput | EncounterUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutLocationInput | EncounterUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type NPCLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<NPCLocationCreateWithoutLocationInput, NPCLocationUncheckedCreateWithoutLocationInput> | NPCLocationCreateWithoutLocationInput[] | NPCLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutLocationInput | NPCLocationCreateOrConnectWithoutLocationInput[]
    upsert?: NPCLocationUpsertWithWhereUniqueWithoutLocationInput | NPCLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: NPCLocationCreateManyLocationInputEnvelope
    set?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    disconnect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    delete?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    update?: NPCLocationUpdateWithWhereUniqueWithoutLocationInput | NPCLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: NPCLocationUpdateManyWithWhereWithoutLocationInput | NPCLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: NPCLocationScalarWhereInput | NPCLocationScalarWhereInput[]
  }

  export type QuestLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<QuestLocationCreateWithoutLocationInput, QuestLocationUncheckedCreateWithoutLocationInput> | QuestLocationCreateWithoutLocationInput[] | QuestLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutLocationInput | QuestLocationCreateOrConnectWithoutLocationInput[]
    upsert?: QuestLocationUpsertWithWhereUniqueWithoutLocationInput | QuestLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: QuestLocationCreateManyLocationInputEnvelope
    set?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    disconnect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    delete?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    update?: QuestLocationUpdateWithWhereUniqueWithoutLocationInput | QuestLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: QuestLocationUpdateManyWithWhereWithoutLocationInput | QuestLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: QuestLocationScalarWhereInput | QuestLocationScalarWhereInput[]
  }

  export type ItemLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ItemLocationCreateWithoutLocationInput, ItemLocationUncheckedCreateWithoutLocationInput> | ItemLocationCreateWithoutLocationInput[] | ItemLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutLocationInput | ItemLocationCreateOrConnectWithoutLocationInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutLocationInput | ItemLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ItemLocationCreateManyLocationInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutLocationInput | ItemLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutLocationInput | ItemLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutParentLocationNestedInput = {
    create?: XOR<LocationCreateWithoutParentLocationInput, LocationUncheckedCreateWithoutParentLocationInput> | LocationCreateWithoutParentLocationInput[] | LocationUncheckedCreateWithoutParentLocationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentLocationInput | LocationCreateOrConnectWithoutParentLocationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutParentLocationInput | LocationUpsertWithWhereUniqueWithoutParentLocationInput[]
    createMany?: LocationCreateManyParentLocationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutParentLocationInput | LocationUpdateWithWhereUniqueWithoutParentLocationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutParentLocationInput | LocationUpdateManyWithWhereWithoutParentLocationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type MapUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MapCreateWithoutLocationInput, MapUncheckedCreateWithoutLocationInput> | MapCreateWithoutLocationInput[] | MapUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MapCreateOrConnectWithoutLocationInput | MapCreateOrConnectWithoutLocationInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutLocationInput | MapUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MapCreateManyLocationInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutLocationInput | MapUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MapUpdateManyWithWhereWithoutLocationInput | MapUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput> | EncounterCreateWithoutLocationInput[] | EncounterUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocationInput | EncounterCreateOrConnectWithoutLocationInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutLocationInput | EncounterUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EncounterCreateManyLocationInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutLocationInput | EncounterUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutLocationInput | EncounterUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type NPCLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<NPCLocationCreateWithoutLocationInput, NPCLocationUncheckedCreateWithoutLocationInput> | NPCLocationCreateWithoutLocationInput[] | NPCLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCLocationCreateOrConnectWithoutLocationInput | NPCLocationCreateOrConnectWithoutLocationInput[]
    upsert?: NPCLocationUpsertWithWhereUniqueWithoutLocationInput | NPCLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: NPCLocationCreateManyLocationInputEnvelope
    set?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    disconnect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    delete?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    connect?: NPCLocationWhereUniqueInput | NPCLocationWhereUniqueInput[]
    update?: NPCLocationUpdateWithWhereUniqueWithoutLocationInput | NPCLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: NPCLocationUpdateManyWithWhereWithoutLocationInput | NPCLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: NPCLocationScalarWhereInput | NPCLocationScalarWhereInput[]
  }

  export type QuestLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<QuestLocationCreateWithoutLocationInput, QuestLocationUncheckedCreateWithoutLocationInput> | QuestLocationCreateWithoutLocationInput[] | QuestLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutLocationInput | QuestLocationCreateOrConnectWithoutLocationInput[]
    upsert?: QuestLocationUpsertWithWhereUniqueWithoutLocationInput | QuestLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: QuestLocationCreateManyLocationInputEnvelope
    set?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    disconnect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    delete?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    update?: QuestLocationUpdateWithWhereUniqueWithoutLocationInput | QuestLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: QuestLocationUpdateManyWithWhereWithoutLocationInput | QuestLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: QuestLocationScalarWhereInput | QuestLocationScalarWhereInput[]
  }

  export type ItemLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ItemLocationCreateWithoutLocationInput, ItemLocationUncheckedCreateWithoutLocationInput> | ItemLocationCreateWithoutLocationInput[] | ItemLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutLocationInput | ItemLocationCreateOrConnectWithoutLocationInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutLocationInput | ItemLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ItemLocationCreateManyLocationInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutLocationInput | ItemLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutLocationInput | ItemLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutMapsInput = {
    create?: XOR<CampaignCreateWithoutMapsInput, CampaignUncheckedCreateWithoutMapsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMapsInput
    connect?: CampaignWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutMapsInput = {
    create?: XOR<LocationCreateWithoutMapsInput, LocationUncheckedCreateWithoutMapsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMapsInput
    connect?: LocationWhereUniqueInput
  }

  export type MapAnnotationCreateNestedManyWithoutMapInput = {
    create?: XOR<MapAnnotationCreateWithoutMapInput, MapAnnotationUncheckedCreateWithoutMapInput> | MapAnnotationCreateWithoutMapInput[] | MapAnnotationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapAnnotationCreateOrConnectWithoutMapInput | MapAnnotationCreateOrConnectWithoutMapInput[]
    createMany?: MapAnnotationCreateManyMapInputEnvelope
    connect?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutMapInput = {
    create?: XOR<EncounterCreateWithoutMapInput, EncounterUncheckedCreateWithoutMapInput> | EncounterCreateWithoutMapInput[] | EncounterUncheckedCreateWithoutMapInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutMapInput | EncounterCreateOrConnectWithoutMapInput[]
    createMany?: EncounterCreateManyMapInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type MapAnnotationUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<MapAnnotationCreateWithoutMapInput, MapAnnotationUncheckedCreateWithoutMapInput> | MapAnnotationCreateWithoutMapInput[] | MapAnnotationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapAnnotationCreateOrConnectWithoutMapInput | MapAnnotationCreateOrConnectWithoutMapInput[]
    createMany?: MapAnnotationCreateManyMapInputEnvelope
    connect?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<EncounterCreateWithoutMapInput, EncounterUncheckedCreateWithoutMapInput> | EncounterCreateWithoutMapInput[] | EncounterUncheckedCreateWithoutMapInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutMapInput | EncounterCreateOrConnectWithoutMapInput[]
    createMany?: EncounterCreateManyMapInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CampaignUpdateOneRequiredWithoutMapsNestedInput = {
    create?: XOR<CampaignCreateWithoutMapsInput, CampaignUncheckedCreateWithoutMapsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMapsInput
    upsert?: CampaignUpsertWithoutMapsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMapsInput, CampaignUpdateWithoutMapsInput>, CampaignUncheckedUpdateWithoutMapsInput>
  }

  export type LocationUpdateOneWithoutMapsNestedInput = {
    create?: XOR<LocationCreateWithoutMapsInput, LocationUncheckedCreateWithoutMapsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMapsInput
    upsert?: LocationUpsertWithoutMapsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutMapsInput, LocationUpdateWithoutMapsInput>, LocationUncheckedUpdateWithoutMapsInput>
  }

  export type MapAnnotationUpdateManyWithoutMapNestedInput = {
    create?: XOR<MapAnnotationCreateWithoutMapInput, MapAnnotationUncheckedCreateWithoutMapInput> | MapAnnotationCreateWithoutMapInput[] | MapAnnotationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapAnnotationCreateOrConnectWithoutMapInput | MapAnnotationCreateOrConnectWithoutMapInput[]
    upsert?: MapAnnotationUpsertWithWhereUniqueWithoutMapInput | MapAnnotationUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: MapAnnotationCreateManyMapInputEnvelope
    set?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    disconnect?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    delete?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    connect?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    update?: MapAnnotationUpdateWithWhereUniqueWithoutMapInput | MapAnnotationUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: MapAnnotationUpdateManyWithWhereWithoutMapInput | MapAnnotationUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: MapAnnotationScalarWhereInput | MapAnnotationScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutMapNestedInput = {
    create?: XOR<EncounterCreateWithoutMapInput, EncounterUncheckedCreateWithoutMapInput> | EncounterCreateWithoutMapInput[] | EncounterUncheckedCreateWithoutMapInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutMapInput | EncounterCreateOrConnectWithoutMapInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutMapInput | EncounterUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: EncounterCreateManyMapInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutMapInput | EncounterUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutMapInput | EncounterUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type MapAnnotationUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<MapAnnotationCreateWithoutMapInput, MapAnnotationUncheckedCreateWithoutMapInput> | MapAnnotationCreateWithoutMapInput[] | MapAnnotationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapAnnotationCreateOrConnectWithoutMapInput | MapAnnotationCreateOrConnectWithoutMapInput[]
    upsert?: MapAnnotationUpsertWithWhereUniqueWithoutMapInput | MapAnnotationUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: MapAnnotationCreateManyMapInputEnvelope
    set?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    disconnect?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    delete?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    connect?: MapAnnotationWhereUniqueInput | MapAnnotationWhereUniqueInput[]
    update?: MapAnnotationUpdateWithWhereUniqueWithoutMapInput | MapAnnotationUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: MapAnnotationUpdateManyWithWhereWithoutMapInput | MapAnnotationUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: MapAnnotationScalarWhereInput | MapAnnotationScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<EncounterCreateWithoutMapInput, EncounterUncheckedCreateWithoutMapInput> | EncounterCreateWithoutMapInput[] | EncounterUncheckedCreateWithoutMapInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutMapInput | EncounterCreateOrConnectWithoutMapInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutMapInput | EncounterUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: EncounterCreateManyMapInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutMapInput | EncounterUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutMapInput | EncounterUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type MapCreateNestedOneWithoutAnnotationsInput = {
    create?: XOR<MapCreateWithoutAnnotationsInput, MapUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: MapCreateOrConnectWithoutAnnotationsInput
    connect?: MapWhereUniqueInput
  }

  export type EnumMapAnnotationTypeFieldUpdateOperationsInput = {
    set?: $Enums.MapAnnotationType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MapUpdateOneRequiredWithoutAnnotationsNestedInput = {
    create?: XOR<MapCreateWithoutAnnotationsInput, MapUncheckedCreateWithoutAnnotationsInput>
    connectOrCreate?: MapCreateOrConnectWithoutAnnotationsInput
    upsert?: MapUpsertWithoutAnnotationsInput
    connect?: MapWhereUniqueInput
    update?: XOR<XOR<MapUpdateToOneWithWhereWithoutAnnotationsInput, MapUpdateWithoutAnnotationsInput>, MapUncheckedUpdateWithoutAnnotationsInput>
  }

  export type MonsterCampaignCreateNestedManyWithoutMonsterInput = {
    create?: XOR<MonsterCampaignCreateWithoutMonsterInput, MonsterCampaignUncheckedCreateWithoutMonsterInput> | MonsterCampaignCreateWithoutMonsterInput[] | MonsterCampaignUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutMonsterInput | MonsterCampaignCreateOrConnectWithoutMonsterInput[]
    createMany?: MonsterCampaignCreateManyMonsterInputEnvelope
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
  }

  export type EncounterParticipantCreateNestedManyWithoutMonsterInput = {
    create?: XOR<EncounterParticipantCreateWithoutMonsterInput, EncounterParticipantUncheckedCreateWithoutMonsterInput> | EncounterParticipantCreateWithoutMonsterInput[] | EncounterParticipantUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutMonsterInput | EncounterParticipantCreateOrConnectWithoutMonsterInput[]
    createMany?: EncounterParticipantCreateManyMonsterInputEnvelope
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
  }

  export type MonsterCampaignUncheckedCreateNestedManyWithoutMonsterInput = {
    create?: XOR<MonsterCampaignCreateWithoutMonsterInput, MonsterCampaignUncheckedCreateWithoutMonsterInput> | MonsterCampaignCreateWithoutMonsterInput[] | MonsterCampaignUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutMonsterInput | MonsterCampaignCreateOrConnectWithoutMonsterInput[]
    createMany?: MonsterCampaignCreateManyMonsterInputEnvelope
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
  }

  export type EncounterParticipantUncheckedCreateNestedManyWithoutMonsterInput = {
    create?: XOR<EncounterParticipantCreateWithoutMonsterInput, EncounterParticipantUncheckedCreateWithoutMonsterInput> | EncounterParticipantCreateWithoutMonsterInput[] | EncounterParticipantUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutMonsterInput | EncounterParticipantCreateOrConnectWithoutMonsterInput[]
    createMany?: EncounterParticipantCreateManyMonsterInputEnvelope
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
  }

  export type EnumSizeFieldUpdateOperationsInput = {
    set?: $Enums.Size
  }

  export type EnumCreatureTypeFieldUpdateOperationsInput = {
    set?: $Enums.CreatureType
  }

  export type EnumAlignmentFieldUpdateOperationsInput = {
    set?: $Enums.Alignment
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MonsterCampaignUpdateManyWithoutMonsterNestedInput = {
    create?: XOR<MonsterCampaignCreateWithoutMonsterInput, MonsterCampaignUncheckedCreateWithoutMonsterInput> | MonsterCampaignCreateWithoutMonsterInput[] | MonsterCampaignUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutMonsterInput | MonsterCampaignCreateOrConnectWithoutMonsterInput[]
    upsert?: MonsterCampaignUpsertWithWhereUniqueWithoutMonsterInput | MonsterCampaignUpsertWithWhereUniqueWithoutMonsterInput[]
    createMany?: MonsterCampaignCreateManyMonsterInputEnvelope
    set?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    disconnect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    delete?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    update?: MonsterCampaignUpdateWithWhereUniqueWithoutMonsterInput | MonsterCampaignUpdateWithWhereUniqueWithoutMonsterInput[]
    updateMany?: MonsterCampaignUpdateManyWithWhereWithoutMonsterInput | MonsterCampaignUpdateManyWithWhereWithoutMonsterInput[]
    deleteMany?: MonsterCampaignScalarWhereInput | MonsterCampaignScalarWhereInput[]
  }

  export type EncounterParticipantUpdateManyWithoutMonsterNestedInput = {
    create?: XOR<EncounterParticipantCreateWithoutMonsterInput, EncounterParticipantUncheckedCreateWithoutMonsterInput> | EncounterParticipantCreateWithoutMonsterInput[] | EncounterParticipantUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutMonsterInput | EncounterParticipantCreateOrConnectWithoutMonsterInput[]
    upsert?: EncounterParticipantUpsertWithWhereUniqueWithoutMonsterInput | EncounterParticipantUpsertWithWhereUniqueWithoutMonsterInput[]
    createMany?: EncounterParticipantCreateManyMonsterInputEnvelope
    set?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    disconnect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    delete?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    update?: EncounterParticipantUpdateWithWhereUniqueWithoutMonsterInput | EncounterParticipantUpdateWithWhereUniqueWithoutMonsterInput[]
    updateMany?: EncounterParticipantUpdateManyWithWhereWithoutMonsterInput | EncounterParticipantUpdateManyWithWhereWithoutMonsterInput[]
    deleteMany?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
  }

  export type MonsterCampaignUncheckedUpdateManyWithoutMonsterNestedInput = {
    create?: XOR<MonsterCampaignCreateWithoutMonsterInput, MonsterCampaignUncheckedCreateWithoutMonsterInput> | MonsterCampaignCreateWithoutMonsterInput[] | MonsterCampaignUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: MonsterCampaignCreateOrConnectWithoutMonsterInput | MonsterCampaignCreateOrConnectWithoutMonsterInput[]
    upsert?: MonsterCampaignUpsertWithWhereUniqueWithoutMonsterInput | MonsterCampaignUpsertWithWhereUniqueWithoutMonsterInput[]
    createMany?: MonsterCampaignCreateManyMonsterInputEnvelope
    set?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    disconnect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    delete?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    connect?: MonsterCampaignWhereUniqueInput | MonsterCampaignWhereUniqueInput[]
    update?: MonsterCampaignUpdateWithWhereUniqueWithoutMonsterInput | MonsterCampaignUpdateWithWhereUniqueWithoutMonsterInput[]
    updateMany?: MonsterCampaignUpdateManyWithWhereWithoutMonsterInput | MonsterCampaignUpdateManyWithWhereWithoutMonsterInput[]
    deleteMany?: MonsterCampaignScalarWhereInput | MonsterCampaignScalarWhereInput[]
  }

  export type EncounterParticipantUncheckedUpdateManyWithoutMonsterNestedInput = {
    create?: XOR<EncounterParticipantCreateWithoutMonsterInput, EncounterParticipantUncheckedCreateWithoutMonsterInput> | EncounterParticipantCreateWithoutMonsterInput[] | EncounterParticipantUncheckedCreateWithoutMonsterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutMonsterInput | EncounterParticipantCreateOrConnectWithoutMonsterInput[]
    upsert?: EncounterParticipantUpsertWithWhereUniqueWithoutMonsterInput | EncounterParticipantUpsertWithWhereUniqueWithoutMonsterInput[]
    createMany?: EncounterParticipantCreateManyMonsterInputEnvelope
    set?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    disconnect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    delete?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    update?: EncounterParticipantUpdateWithWhereUniqueWithoutMonsterInput | EncounterParticipantUpdateWithWhereUniqueWithoutMonsterInput[]
    updateMany?: EncounterParticipantUpdateManyWithWhereWithoutMonsterInput | EncounterParticipantUpdateManyWithWhereWithoutMonsterInput[]
    deleteMany?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutEncountersInput = {
    create?: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEncountersInput
    connect?: CampaignWhereUniqueInput
  }

  export type MapCreateNestedOneWithoutEncountersInput = {
    create?: XOR<MapCreateWithoutEncountersInput, MapUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: MapCreateOrConnectWithoutEncountersInput
    connect?: MapWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutEncountersInput = {
    create?: XOR<LocationCreateWithoutEncountersInput, LocationUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEncountersInput
    connect?: LocationWhereUniqueInput
  }

  export type EncounterParticipantCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterParticipantCreateWithoutEncounterInput, EncounterParticipantUncheckedCreateWithoutEncounterInput> | EncounterParticipantCreateWithoutEncounterInput[] | EncounterParticipantUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutEncounterInput | EncounterParticipantCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterParticipantCreateManyEncounterInputEnvelope
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
  }

  export type EncounterParticipantUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterParticipantCreateWithoutEncounterInput, EncounterParticipantUncheckedCreateWithoutEncounterInput> | EncounterParticipantCreateWithoutEncounterInput[] | EncounterParticipantUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutEncounterInput | EncounterParticipantCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterParticipantCreateManyEncounterInputEnvelope
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
  }

  export type EnumDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.Difficulty
  }

  export type EnumEncounterStatusFieldUpdateOperationsInput = {
    set?: $Enums.EncounterStatus
  }

  export type CampaignUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEncountersInput
    upsert?: CampaignUpsertWithoutEncountersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEncountersInput, CampaignUpdateWithoutEncountersInput>, CampaignUncheckedUpdateWithoutEncountersInput>
  }

  export type MapUpdateOneWithoutEncountersNestedInput = {
    create?: XOR<MapCreateWithoutEncountersInput, MapUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: MapCreateOrConnectWithoutEncountersInput
    upsert?: MapUpsertWithoutEncountersInput
    disconnect?: MapWhereInput | boolean
    delete?: MapWhereInput | boolean
    connect?: MapWhereUniqueInput
    update?: XOR<XOR<MapUpdateToOneWithWhereWithoutEncountersInput, MapUpdateWithoutEncountersInput>, MapUncheckedUpdateWithoutEncountersInput>
  }

  export type LocationUpdateOneWithoutEncountersNestedInput = {
    create?: XOR<LocationCreateWithoutEncountersInput, LocationUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEncountersInput
    upsert?: LocationUpsertWithoutEncountersInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutEncountersInput, LocationUpdateWithoutEncountersInput>, LocationUncheckedUpdateWithoutEncountersInput>
  }

  export type EncounterParticipantUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterParticipantCreateWithoutEncounterInput, EncounterParticipantUncheckedCreateWithoutEncounterInput> | EncounterParticipantCreateWithoutEncounterInput[] | EncounterParticipantUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutEncounterInput | EncounterParticipantCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterParticipantUpsertWithWhereUniqueWithoutEncounterInput | EncounterParticipantUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterParticipantCreateManyEncounterInputEnvelope
    set?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    disconnect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    delete?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    update?: EncounterParticipantUpdateWithWhereUniqueWithoutEncounterInput | EncounterParticipantUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterParticipantUpdateManyWithWhereWithoutEncounterInput | EncounterParticipantUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
  }

  export type EncounterParticipantUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterParticipantCreateWithoutEncounterInput, EncounterParticipantUncheckedCreateWithoutEncounterInput> | EncounterParticipantCreateWithoutEncounterInput[] | EncounterParticipantUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutEncounterInput | EncounterParticipantCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterParticipantUpsertWithWhereUniqueWithoutEncounterInput | EncounterParticipantUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterParticipantCreateManyEncounterInputEnvelope
    set?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    disconnect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    delete?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    update?: EncounterParticipantUpdateWithWhereUniqueWithoutEncounterInput | EncounterParticipantUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterParticipantUpdateManyWithWhereWithoutEncounterInput | EncounterParticipantUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<EncounterCreateWithoutParticipantsInput, EncounterUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutParticipantsInput
    connect?: EncounterWhereUniqueInput
  }

  export type MonsterCreateNestedOneWithoutEncounterParticipantsInput = {
    create?: XOR<MonsterCreateWithoutEncounterParticipantsInput, MonsterUncheckedCreateWithoutEncounterParticipantsInput>
    connectOrCreate?: MonsterCreateOrConnectWithoutEncounterParticipantsInput
    connect?: MonsterWhereUniqueInput
  }

  export type PlayerCharacterCreateNestedOneWithoutEncounterParticipantsInput = {
    create?: XOR<PlayerCharacterCreateWithoutEncounterParticipantsInput, PlayerCharacterUncheckedCreateWithoutEncounterParticipantsInput>
    connectOrCreate?: PlayerCharacterCreateOrConnectWithoutEncounterParticipantsInput
    connect?: PlayerCharacterWhereUniqueInput
  }

  export type EnumParticipantTypeFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EncounterUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<EncounterCreateWithoutParticipantsInput, EncounterUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutParticipantsInput
    upsert?: EncounterUpsertWithoutParticipantsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutParticipantsInput, EncounterUpdateWithoutParticipantsInput>, EncounterUncheckedUpdateWithoutParticipantsInput>
  }

  export type MonsterUpdateOneWithoutEncounterParticipantsNestedInput = {
    create?: XOR<MonsterCreateWithoutEncounterParticipantsInput, MonsterUncheckedCreateWithoutEncounterParticipantsInput>
    connectOrCreate?: MonsterCreateOrConnectWithoutEncounterParticipantsInput
    upsert?: MonsterUpsertWithoutEncounterParticipantsInput
    disconnect?: MonsterWhereInput | boolean
    delete?: MonsterWhereInput | boolean
    connect?: MonsterWhereUniqueInput
    update?: XOR<XOR<MonsterUpdateToOneWithWhereWithoutEncounterParticipantsInput, MonsterUpdateWithoutEncounterParticipantsInput>, MonsterUncheckedUpdateWithoutEncounterParticipantsInput>
  }

  export type PlayerCharacterUpdateOneWithoutEncounterParticipantsNestedInput = {
    create?: XOR<PlayerCharacterCreateWithoutEncounterParticipantsInput, PlayerCharacterUncheckedCreateWithoutEncounterParticipantsInput>
    connectOrCreate?: PlayerCharacterCreateOrConnectWithoutEncounterParticipantsInput
    upsert?: PlayerCharacterUpsertWithoutEncounterParticipantsInput
    disconnect?: PlayerCharacterWhereInput | boolean
    delete?: PlayerCharacterWhereInput | boolean
    connect?: PlayerCharacterWhereUniqueInput
    update?: XOR<XOR<PlayerCharacterUpdateToOneWithWhereWithoutEncounterParticipantsInput, PlayerCharacterUpdateWithoutEncounterParticipantsInput>, PlayerCharacterUncheckedUpdateWithoutEncounterParticipantsInput>
  }

  export type CampaignCreateNestedOneWithoutPlayerCharactersInput = {
    create?: XOR<CampaignCreateWithoutPlayerCharactersInput, CampaignUncheckedCreateWithoutPlayerCharactersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPlayerCharactersInput
    connect?: CampaignWhereUniqueInput
  }

  export type EncounterParticipantCreateNestedManyWithoutPlayerCharacterInput = {
    create?: XOR<EncounterParticipantCreateWithoutPlayerCharacterInput, EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput> | EncounterParticipantCreateWithoutPlayerCharacterInput[] | EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput | EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput[]
    createMany?: EncounterParticipantCreateManyPlayerCharacterInputEnvelope
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
  }

  export type EncounterParticipantUncheckedCreateNestedManyWithoutPlayerCharacterInput = {
    create?: XOR<EncounterParticipantCreateWithoutPlayerCharacterInput, EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput> | EncounterParticipantCreateWithoutPlayerCharacterInput[] | EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput | EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput[]
    createMany?: EncounterParticipantCreateManyPlayerCharacterInputEnvelope
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
  }

  export type EnumRaceFieldUpdateOperationsInput = {
    set?: $Enums.Race
  }

  export type EnumCharacterClassFieldUpdateOperationsInput = {
    set?: $Enums.CharacterClass
  }

  export type EnumBackgroundTypeFieldUpdateOperationsInput = {
    set?: $Enums.BackgroundType
  }

  export type CampaignUpdateOneRequiredWithoutPlayerCharactersNestedInput = {
    create?: XOR<CampaignCreateWithoutPlayerCharactersInput, CampaignUncheckedCreateWithoutPlayerCharactersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutPlayerCharactersInput
    upsert?: CampaignUpsertWithoutPlayerCharactersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutPlayerCharactersInput, CampaignUpdateWithoutPlayerCharactersInput>, CampaignUncheckedUpdateWithoutPlayerCharactersInput>
  }

  export type EncounterParticipantUpdateManyWithoutPlayerCharacterNestedInput = {
    create?: XOR<EncounterParticipantCreateWithoutPlayerCharacterInput, EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput> | EncounterParticipantCreateWithoutPlayerCharacterInput[] | EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput | EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput[]
    upsert?: EncounterParticipantUpsertWithWhereUniqueWithoutPlayerCharacterInput | EncounterParticipantUpsertWithWhereUniqueWithoutPlayerCharacterInput[]
    createMany?: EncounterParticipantCreateManyPlayerCharacterInputEnvelope
    set?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    disconnect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    delete?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    update?: EncounterParticipantUpdateWithWhereUniqueWithoutPlayerCharacterInput | EncounterParticipantUpdateWithWhereUniqueWithoutPlayerCharacterInput[]
    updateMany?: EncounterParticipantUpdateManyWithWhereWithoutPlayerCharacterInput | EncounterParticipantUpdateManyWithWhereWithoutPlayerCharacterInput[]
    deleteMany?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
  }

  export type EncounterParticipantUncheckedUpdateManyWithoutPlayerCharacterNestedInput = {
    create?: XOR<EncounterParticipantCreateWithoutPlayerCharacterInput, EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput> | EncounterParticipantCreateWithoutPlayerCharacterInput[] | EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput[]
    connectOrCreate?: EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput | EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput[]
    upsert?: EncounterParticipantUpsertWithWhereUniqueWithoutPlayerCharacterInput | EncounterParticipantUpsertWithWhereUniqueWithoutPlayerCharacterInput[]
    createMany?: EncounterParticipantCreateManyPlayerCharacterInputEnvelope
    set?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    disconnect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    delete?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    connect?: EncounterParticipantWhereUniqueInput | EncounterParticipantWhereUniqueInput[]
    update?: EncounterParticipantUpdateWithWhereUniqueWithoutPlayerCharacterInput | EncounterParticipantUpdateWithWhereUniqueWithoutPlayerCharacterInput[]
    updateMany?: EncounterParticipantUpdateManyWithWhereWithoutPlayerCharacterInput | EncounterParticipantUpdateManyWithWhereWithoutPlayerCharacterInput[]
    deleteMany?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutQuestsInput = {
    create?: XOR<CampaignCreateWithoutQuestsInput, CampaignUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutQuestsInput
    connect?: CampaignWhereUniqueInput
  }

  export type QuestCreateNestedOneWithoutSubQuestsInput = {
    create?: XOR<QuestCreateWithoutSubQuestsInput, QuestUncheckedCreateWithoutSubQuestsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutSubQuestsInput
    connect?: QuestWhereUniqueInput
  }

  export type QuestCreateNestedManyWithoutParentQuestInput = {
    create?: XOR<QuestCreateWithoutParentQuestInput, QuestUncheckedCreateWithoutParentQuestInput> | QuestCreateWithoutParentQuestInput[] | QuestUncheckedCreateWithoutParentQuestInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutParentQuestInput | QuestCreateOrConnectWithoutParentQuestInput[]
    createMany?: QuestCreateManyParentQuestInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type NPCCreateNestedOneWithoutQuestsGivenInput = {
    create?: XOR<NPCCreateWithoutQuestsGivenInput, NPCUncheckedCreateWithoutQuestsGivenInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsGivenInput
    connect?: NPCWhereUniqueInput
  }

  export type QuestNPCCreateNestedManyWithoutQuestInput = {
    create?: XOR<QuestNPCCreateWithoutQuestInput, QuestNPCUncheckedCreateWithoutQuestInput> | QuestNPCCreateWithoutQuestInput[] | QuestNPCUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutQuestInput | QuestNPCCreateOrConnectWithoutQuestInput[]
    createMany?: QuestNPCCreateManyQuestInputEnvelope
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
  }

  export type QuestLocationCreateNestedManyWithoutQuestInput = {
    create?: XOR<QuestLocationCreateWithoutQuestInput, QuestLocationUncheckedCreateWithoutQuestInput> | QuestLocationCreateWithoutQuestInput[] | QuestLocationUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutQuestInput | QuestLocationCreateOrConnectWithoutQuestInput[]
    createMany?: QuestLocationCreateManyQuestInputEnvelope
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
  }

  export type ChronicleQuestCreateNestedManyWithoutQuestInput = {
    create?: XOR<ChronicleQuestCreateWithoutQuestInput, ChronicleQuestUncheckedCreateWithoutQuestInput> | ChronicleQuestCreateWithoutQuestInput[] | ChronicleQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutQuestInput | ChronicleQuestCreateOrConnectWithoutQuestInput[]
    createMany?: ChronicleQuestCreateManyQuestInputEnvelope
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
  }

  export type QuestUncheckedCreateNestedManyWithoutParentQuestInput = {
    create?: XOR<QuestCreateWithoutParentQuestInput, QuestUncheckedCreateWithoutParentQuestInput> | QuestCreateWithoutParentQuestInput[] | QuestUncheckedCreateWithoutParentQuestInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutParentQuestInput | QuestCreateOrConnectWithoutParentQuestInput[]
    createMany?: QuestCreateManyParentQuestInputEnvelope
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
  }

  export type QuestNPCUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<QuestNPCCreateWithoutQuestInput, QuestNPCUncheckedCreateWithoutQuestInput> | QuestNPCCreateWithoutQuestInput[] | QuestNPCUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutQuestInput | QuestNPCCreateOrConnectWithoutQuestInput[]
    createMany?: QuestNPCCreateManyQuestInputEnvelope
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
  }

  export type QuestLocationUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<QuestLocationCreateWithoutQuestInput, QuestLocationUncheckedCreateWithoutQuestInput> | QuestLocationCreateWithoutQuestInput[] | QuestLocationUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutQuestInput | QuestLocationCreateOrConnectWithoutQuestInput[]
    createMany?: QuestLocationCreateManyQuestInputEnvelope
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
  }

  export type ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput = {
    create?: XOR<ChronicleQuestCreateWithoutQuestInput, ChronicleQuestUncheckedCreateWithoutQuestInput> | ChronicleQuestCreateWithoutQuestInput[] | ChronicleQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutQuestInput | ChronicleQuestCreateOrConnectWithoutQuestInput[]
    createMany?: ChronicleQuestCreateManyQuestInputEnvelope
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
  }

  export type EnumQuestStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuestStatus
  }

  export type CampaignUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<CampaignCreateWithoutQuestsInput, CampaignUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutQuestsInput
    upsert?: CampaignUpsertWithoutQuestsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutQuestsInput, CampaignUpdateWithoutQuestsInput>, CampaignUncheckedUpdateWithoutQuestsInput>
  }

  export type QuestUpdateOneWithoutSubQuestsNestedInput = {
    create?: XOR<QuestCreateWithoutSubQuestsInput, QuestUncheckedCreateWithoutSubQuestsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutSubQuestsInput
    upsert?: QuestUpsertWithoutSubQuestsInput
    disconnect?: QuestWhereInput | boolean
    delete?: QuestWhereInput | boolean
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutSubQuestsInput, QuestUpdateWithoutSubQuestsInput>, QuestUncheckedUpdateWithoutSubQuestsInput>
  }

  export type QuestUpdateManyWithoutParentQuestNestedInput = {
    create?: XOR<QuestCreateWithoutParentQuestInput, QuestUncheckedCreateWithoutParentQuestInput> | QuestCreateWithoutParentQuestInput[] | QuestUncheckedCreateWithoutParentQuestInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutParentQuestInput | QuestCreateOrConnectWithoutParentQuestInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutParentQuestInput | QuestUpsertWithWhereUniqueWithoutParentQuestInput[]
    createMany?: QuestCreateManyParentQuestInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutParentQuestInput | QuestUpdateWithWhereUniqueWithoutParentQuestInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutParentQuestInput | QuestUpdateManyWithWhereWithoutParentQuestInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type NPCUpdateOneWithoutQuestsGivenNestedInput = {
    create?: XOR<NPCCreateWithoutQuestsGivenInput, NPCUncheckedCreateWithoutQuestsGivenInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsGivenInput
    upsert?: NPCUpsertWithoutQuestsGivenInput
    disconnect?: NPCWhereInput | boolean
    delete?: NPCWhereInput | boolean
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutQuestsGivenInput, NPCUpdateWithoutQuestsGivenInput>, NPCUncheckedUpdateWithoutQuestsGivenInput>
  }

  export type QuestNPCUpdateManyWithoutQuestNestedInput = {
    create?: XOR<QuestNPCCreateWithoutQuestInput, QuestNPCUncheckedCreateWithoutQuestInput> | QuestNPCCreateWithoutQuestInput[] | QuestNPCUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutQuestInput | QuestNPCCreateOrConnectWithoutQuestInput[]
    upsert?: QuestNPCUpsertWithWhereUniqueWithoutQuestInput | QuestNPCUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: QuestNPCCreateManyQuestInputEnvelope
    set?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    disconnect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    delete?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    update?: QuestNPCUpdateWithWhereUniqueWithoutQuestInput | QuestNPCUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: QuestNPCUpdateManyWithWhereWithoutQuestInput | QuestNPCUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: QuestNPCScalarWhereInput | QuestNPCScalarWhereInput[]
  }

  export type QuestLocationUpdateManyWithoutQuestNestedInput = {
    create?: XOR<QuestLocationCreateWithoutQuestInput, QuestLocationUncheckedCreateWithoutQuestInput> | QuestLocationCreateWithoutQuestInput[] | QuestLocationUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutQuestInput | QuestLocationCreateOrConnectWithoutQuestInput[]
    upsert?: QuestLocationUpsertWithWhereUniqueWithoutQuestInput | QuestLocationUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: QuestLocationCreateManyQuestInputEnvelope
    set?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    disconnect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    delete?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    update?: QuestLocationUpdateWithWhereUniqueWithoutQuestInput | QuestLocationUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: QuestLocationUpdateManyWithWhereWithoutQuestInput | QuestLocationUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: QuestLocationScalarWhereInput | QuestLocationScalarWhereInput[]
  }

  export type ChronicleQuestUpdateManyWithoutQuestNestedInput = {
    create?: XOR<ChronicleQuestCreateWithoutQuestInput, ChronicleQuestUncheckedCreateWithoutQuestInput> | ChronicleQuestCreateWithoutQuestInput[] | ChronicleQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutQuestInput | ChronicleQuestCreateOrConnectWithoutQuestInput[]
    upsert?: ChronicleQuestUpsertWithWhereUniqueWithoutQuestInput | ChronicleQuestUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: ChronicleQuestCreateManyQuestInputEnvelope
    set?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    disconnect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    delete?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    update?: ChronicleQuestUpdateWithWhereUniqueWithoutQuestInput | ChronicleQuestUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: ChronicleQuestUpdateManyWithWhereWithoutQuestInput | ChronicleQuestUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: ChronicleQuestScalarWhereInput | ChronicleQuestScalarWhereInput[]
  }

  export type QuestUncheckedUpdateManyWithoutParentQuestNestedInput = {
    create?: XOR<QuestCreateWithoutParentQuestInput, QuestUncheckedCreateWithoutParentQuestInput> | QuestCreateWithoutParentQuestInput[] | QuestUncheckedCreateWithoutParentQuestInput[]
    connectOrCreate?: QuestCreateOrConnectWithoutParentQuestInput | QuestCreateOrConnectWithoutParentQuestInput[]
    upsert?: QuestUpsertWithWhereUniqueWithoutParentQuestInput | QuestUpsertWithWhereUniqueWithoutParentQuestInput[]
    createMany?: QuestCreateManyParentQuestInputEnvelope
    set?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    disconnect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    delete?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    connect?: QuestWhereUniqueInput | QuestWhereUniqueInput[]
    update?: QuestUpdateWithWhereUniqueWithoutParentQuestInput | QuestUpdateWithWhereUniqueWithoutParentQuestInput[]
    updateMany?: QuestUpdateManyWithWhereWithoutParentQuestInput | QuestUpdateManyWithWhereWithoutParentQuestInput[]
    deleteMany?: QuestScalarWhereInput | QuestScalarWhereInput[]
  }

  export type QuestNPCUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<QuestNPCCreateWithoutQuestInput, QuestNPCUncheckedCreateWithoutQuestInput> | QuestNPCCreateWithoutQuestInput[] | QuestNPCUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestNPCCreateOrConnectWithoutQuestInput | QuestNPCCreateOrConnectWithoutQuestInput[]
    upsert?: QuestNPCUpsertWithWhereUniqueWithoutQuestInput | QuestNPCUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: QuestNPCCreateManyQuestInputEnvelope
    set?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    disconnect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    delete?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    connect?: QuestNPCWhereUniqueInput | QuestNPCWhereUniqueInput[]
    update?: QuestNPCUpdateWithWhereUniqueWithoutQuestInput | QuestNPCUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: QuestNPCUpdateManyWithWhereWithoutQuestInput | QuestNPCUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: QuestNPCScalarWhereInput | QuestNPCScalarWhereInput[]
  }

  export type QuestLocationUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<QuestLocationCreateWithoutQuestInput, QuestLocationUncheckedCreateWithoutQuestInput> | QuestLocationCreateWithoutQuestInput[] | QuestLocationUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: QuestLocationCreateOrConnectWithoutQuestInput | QuestLocationCreateOrConnectWithoutQuestInput[]
    upsert?: QuestLocationUpsertWithWhereUniqueWithoutQuestInput | QuestLocationUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: QuestLocationCreateManyQuestInputEnvelope
    set?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    disconnect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    delete?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    connect?: QuestLocationWhereUniqueInput | QuestLocationWhereUniqueInput[]
    update?: QuestLocationUpdateWithWhereUniqueWithoutQuestInput | QuestLocationUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: QuestLocationUpdateManyWithWhereWithoutQuestInput | QuestLocationUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: QuestLocationScalarWhereInput | QuestLocationScalarWhereInput[]
  }

  export type ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput = {
    create?: XOR<ChronicleQuestCreateWithoutQuestInput, ChronicleQuestUncheckedCreateWithoutQuestInput> | ChronicleQuestCreateWithoutQuestInput[] | ChronicleQuestUncheckedCreateWithoutQuestInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutQuestInput | ChronicleQuestCreateOrConnectWithoutQuestInput[]
    upsert?: ChronicleQuestUpsertWithWhereUniqueWithoutQuestInput | ChronicleQuestUpsertWithWhereUniqueWithoutQuestInput[]
    createMany?: ChronicleQuestCreateManyQuestInputEnvelope
    set?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    disconnect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    delete?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    update?: ChronicleQuestUpdateWithWhereUniqueWithoutQuestInput | ChronicleQuestUpdateWithWhereUniqueWithoutQuestInput[]
    updateMany?: ChronicleQuestUpdateManyWithWhereWithoutQuestInput | ChronicleQuestUpdateManyWithWhereWithoutQuestInput[]
    deleteMany?: ChronicleQuestScalarWhereInput | ChronicleQuestScalarWhereInput[]
  }

  export type ItemCampaignCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemCampaignCreateWithoutItemInput, ItemCampaignUncheckedCreateWithoutItemInput> | ItemCampaignCreateWithoutItemInput[] | ItemCampaignUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutItemInput | ItemCampaignCreateOrConnectWithoutItemInput[]
    createMany?: ItemCampaignCreateManyItemInputEnvelope
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
  }

  export type ItemLocationCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type ItemNPCCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemNPCCreateWithoutItemInput, ItemNPCUncheckedCreateWithoutItemInput> | ItemNPCCreateWithoutItemInput[] | ItemNPCUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutItemInput | ItemNPCCreateOrConnectWithoutItemInput[]
    createMany?: ItemNPCCreateManyItemInputEnvelope
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
  }

  export type InteractionItemCreateNestedManyWithoutItemInput = {
    create?: XOR<InteractionItemCreateWithoutItemInput, InteractionItemUncheckedCreateWithoutItemInput> | InteractionItemCreateWithoutItemInput[] | InteractionItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutItemInput | InteractionItemCreateOrConnectWithoutItemInput[]
    createMany?: InteractionItemCreateManyItemInputEnvelope
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
  }

  export type ItemCampaignUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemCampaignCreateWithoutItemInput, ItemCampaignUncheckedCreateWithoutItemInput> | ItemCampaignCreateWithoutItemInput[] | ItemCampaignUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutItemInput | ItemCampaignCreateOrConnectWithoutItemInput[]
    createMany?: ItemCampaignCreateManyItemInputEnvelope
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
  }

  export type ItemLocationUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
  }

  export type ItemNPCUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemNPCCreateWithoutItemInput, ItemNPCUncheckedCreateWithoutItemInput> | ItemNPCCreateWithoutItemInput[] | ItemNPCUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutItemInput | ItemNPCCreateOrConnectWithoutItemInput[]
    createMany?: ItemNPCCreateManyItemInputEnvelope
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
  }

  export type InteractionItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InteractionItemCreateWithoutItemInput, InteractionItemUncheckedCreateWithoutItemInput> | InteractionItemCreateWithoutItemInput[] | InteractionItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutItemInput | InteractionItemCreateOrConnectWithoutItemInput[]
    createMany?: InteractionItemCreateManyItemInputEnvelope
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type EnumItemRarityFieldUpdateOperationsInput = {
    set?: $Enums.ItemRarity
  }

  export type ItemCampaignUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemCampaignCreateWithoutItemInput, ItemCampaignUncheckedCreateWithoutItemInput> | ItemCampaignCreateWithoutItemInput[] | ItemCampaignUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutItemInput | ItemCampaignCreateOrConnectWithoutItemInput[]
    upsert?: ItemCampaignUpsertWithWhereUniqueWithoutItemInput | ItemCampaignUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemCampaignCreateManyItemInputEnvelope
    set?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    disconnect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    delete?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    update?: ItemCampaignUpdateWithWhereUniqueWithoutItemInput | ItemCampaignUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemCampaignUpdateManyWithWhereWithoutItemInput | ItemCampaignUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemCampaignScalarWhereInput | ItemCampaignScalarWhereInput[]
  }

  export type ItemLocationUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutItemInput | ItemLocationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutItemInput | ItemLocationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutItemInput | ItemLocationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type ItemNPCUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemNPCCreateWithoutItemInput, ItemNPCUncheckedCreateWithoutItemInput> | ItemNPCCreateWithoutItemInput[] | ItemNPCUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutItemInput | ItemNPCCreateOrConnectWithoutItemInput[]
    upsert?: ItemNPCUpsertWithWhereUniqueWithoutItemInput | ItemNPCUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemNPCCreateManyItemInputEnvelope
    set?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    disconnect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    delete?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    update?: ItemNPCUpdateWithWhereUniqueWithoutItemInput | ItemNPCUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemNPCUpdateManyWithWhereWithoutItemInput | ItemNPCUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemNPCScalarWhereInput | ItemNPCScalarWhereInput[]
  }

  export type InteractionItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<InteractionItemCreateWithoutItemInput, InteractionItemUncheckedCreateWithoutItemInput> | InteractionItemCreateWithoutItemInput[] | InteractionItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutItemInput | InteractionItemCreateOrConnectWithoutItemInput[]
    upsert?: InteractionItemUpsertWithWhereUniqueWithoutItemInput | InteractionItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InteractionItemCreateManyItemInputEnvelope
    set?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    disconnect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    delete?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    update?: InteractionItemUpdateWithWhereUniqueWithoutItemInput | InteractionItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InteractionItemUpdateManyWithWhereWithoutItemInput | InteractionItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InteractionItemScalarWhereInput | InteractionItemScalarWhereInput[]
  }

  export type ItemCampaignUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemCampaignCreateWithoutItemInput, ItemCampaignUncheckedCreateWithoutItemInput> | ItemCampaignCreateWithoutItemInput[] | ItemCampaignUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemCampaignCreateOrConnectWithoutItemInput | ItemCampaignCreateOrConnectWithoutItemInput[]
    upsert?: ItemCampaignUpsertWithWhereUniqueWithoutItemInput | ItemCampaignUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemCampaignCreateManyItemInputEnvelope
    set?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    disconnect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    delete?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    connect?: ItemCampaignWhereUniqueInput | ItemCampaignWhereUniqueInput[]
    update?: ItemCampaignUpdateWithWhereUniqueWithoutItemInput | ItemCampaignUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemCampaignUpdateManyWithWhereWithoutItemInput | ItemCampaignUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemCampaignScalarWhereInput | ItemCampaignScalarWhereInput[]
  }

  export type ItemLocationUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput> | ItemLocationCreateWithoutItemInput[] | ItemLocationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLocationCreateOrConnectWithoutItemInput | ItemLocationCreateOrConnectWithoutItemInput[]
    upsert?: ItemLocationUpsertWithWhereUniqueWithoutItemInput | ItemLocationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemLocationCreateManyItemInputEnvelope
    set?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    disconnect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    delete?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    connect?: ItemLocationWhereUniqueInput | ItemLocationWhereUniqueInput[]
    update?: ItemLocationUpdateWithWhereUniqueWithoutItemInput | ItemLocationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemLocationUpdateManyWithWhereWithoutItemInput | ItemLocationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
  }

  export type ItemNPCUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemNPCCreateWithoutItemInput, ItemNPCUncheckedCreateWithoutItemInput> | ItemNPCCreateWithoutItemInput[] | ItemNPCUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemNPCCreateOrConnectWithoutItemInput | ItemNPCCreateOrConnectWithoutItemInput[]
    upsert?: ItemNPCUpsertWithWhereUniqueWithoutItemInput | ItemNPCUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemNPCCreateManyItemInputEnvelope
    set?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    disconnect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    delete?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    connect?: ItemNPCWhereUniqueInput | ItemNPCWhereUniqueInput[]
    update?: ItemNPCUpdateWithWhereUniqueWithoutItemInput | ItemNPCUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemNPCUpdateManyWithWhereWithoutItemInput | ItemNPCUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemNPCScalarWhereInput | ItemNPCScalarWhereInput[]
  }

  export type InteractionItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InteractionItemCreateWithoutItemInput, InteractionItemUncheckedCreateWithoutItemInput> | InteractionItemCreateWithoutItemInput[] | InteractionItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutItemInput | InteractionItemCreateOrConnectWithoutItemInput[]
    upsert?: InteractionItemUpsertWithWhereUniqueWithoutItemInput | InteractionItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InteractionItemCreateManyItemInputEnvelope
    set?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    disconnect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    delete?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    update?: InteractionItemUpdateWithWhereUniqueWithoutItemInput | InteractionItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InteractionItemUpdateManyWithWhereWithoutItemInput | InteractionItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InteractionItemScalarWhereInput | InteractionItemScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutChroniclesInput = {
    create?: XOR<CampaignCreateWithoutChroniclesInput, CampaignUncheckedCreateWithoutChroniclesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChroniclesInput
    connect?: CampaignWhereUniqueInput
  }

  export type ChronicleQuestCreateNestedManyWithoutChronicleInput = {
    create?: XOR<ChronicleQuestCreateWithoutChronicleInput, ChronicleQuestUncheckedCreateWithoutChronicleInput> | ChronicleQuestCreateWithoutChronicleInput[] | ChronicleQuestUncheckedCreateWithoutChronicleInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutChronicleInput | ChronicleQuestCreateOrConnectWithoutChronicleInput[]
    createMany?: ChronicleQuestCreateManyChronicleInputEnvelope
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
  }

  export type ChronicleQuestUncheckedCreateNestedManyWithoutChronicleInput = {
    create?: XOR<ChronicleQuestCreateWithoutChronicleInput, ChronicleQuestUncheckedCreateWithoutChronicleInput> | ChronicleQuestCreateWithoutChronicleInput[] | ChronicleQuestUncheckedCreateWithoutChronicleInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutChronicleInput | ChronicleQuestCreateOrConnectWithoutChronicleInput[]
    createMany?: ChronicleQuestCreateManyChronicleInputEnvelope
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutChroniclesNestedInput = {
    create?: XOR<CampaignCreateWithoutChroniclesInput, CampaignUncheckedCreateWithoutChroniclesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutChroniclesInput
    upsert?: CampaignUpsertWithoutChroniclesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutChroniclesInput, CampaignUpdateWithoutChroniclesInput>, CampaignUncheckedUpdateWithoutChroniclesInput>
  }

  export type ChronicleQuestUpdateManyWithoutChronicleNestedInput = {
    create?: XOR<ChronicleQuestCreateWithoutChronicleInput, ChronicleQuestUncheckedCreateWithoutChronicleInput> | ChronicleQuestCreateWithoutChronicleInput[] | ChronicleQuestUncheckedCreateWithoutChronicleInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutChronicleInput | ChronicleQuestCreateOrConnectWithoutChronicleInput[]
    upsert?: ChronicleQuestUpsertWithWhereUniqueWithoutChronicleInput | ChronicleQuestUpsertWithWhereUniqueWithoutChronicleInput[]
    createMany?: ChronicleQuestCreateManyChronicleInputEnvelope
    set?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    disconnect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    delete?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    update?: ChronicleQuestUpdateWithWhereUniqueWithoutChronicleInput | ChronicleQuestUpdateWithWhereUniqueWithoutChronicleInput[]
    updateMany?: ChronicleQuestUpdateManyWithWhereWithoutChronicleInput | ChronicleQuestUpdateManyWithWhereWithoutChronicleInput[]
    deleteMany?: ChronicleQuestScalarWhereInput | ChronicleQuestScalarWhereInput[]
  }

  export type ChronicleQuestUncheckedUpdateManyWithoutChronicleNestedInput = {
    create?: XOR<ChronicleQuestCreateWithoutChronicleInput, ChronicleQuestUncheckedCreateWithoutChronicleInput> | ChronicleQuestCreateWithoutChronicleInput[] | ChronicleQuestUncheckedCreateWithoutChronicleInput[]
    connectOrCreate?: ChronicleQuestCreateOrConnectWithoutChronicleInput | ChronicleQuestCreateOrConnectWithoutChronicleInput[]
    upsert?: ChronicleQuestUpsertWithWhereUniqueWithoutChronicleInput | ChronicleQuestUpsertWithWhereUniqueWithoutChronicleInput[]
    createMany?: ChronicleQuestCreateManyChronicleInputEnvelope
    set?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    disconnect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    delete?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    connect?: ChronicleQuestWhereUniqueInput | ChronicleQuestWhereUniqueInput[]
    update?: ChronicleQuestUpdateWithWhereUniqueWithoutChronicleInput | ChronicleQuestUpdateWithWhereUniqueWithoutChronicleInput[]
    updateMany?: ChronicleQuestUpdateManyWithWhereWithoutChronicleInput | ChronicleQuestUpdateManyWithWhereWithoutChronicleInput[]
    deleteMany?: ChronicleQuestScalarWhereInput | ChronicleQuestScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<CampaignCreateWithoutInteractionsInput, CampaignUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutInteractionsInput
    connect?: CampaignWhereUniqueInput
  }

  export type NPCCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<NPCCreateWithoutInteractionsInput, NPCUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutInteractionsInput
    connect?: NPCWhereUniqueInput
  }

  export type InteractionItemCreateNestedManyWithoutInteractionInput = {
    create?: XOR<InteractionItemCreateWithoutInteractionInput, InteractionItemUncheckedCreateWithoutInteractionInput> | InteractionItemCreateWithoutInteractionInput[] | InteractionItemUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutInteractionInput | InteractionItemCreateOrConnectWithoutInteractionInput[]
    createMany?: InteractionItemCreateManyInteractionInputEnvelope
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
  }

  export type InteractionItemUncheckedCreateNestedManyWithoutInteractionInput = {
    create?: XOR<InteractionItemCreateWithoutInteractionInput, InteractionItemUncheckedCreateWithoutInteractionInput> | InteractionItemCreateWithoutInteractionInput[] | InteractionItemUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutInteractionInput | InteractionItemCreateOrConnectWithoutInteractionInput[]
    createMany?: InteractionItemCreateManyInteractionInputEnvelope
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type CampaignUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<CampaignCreateWithoutInteractionsInput, CampaignUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutInteractionsInput
    upsert?: CampaignUpsertWithoutInteractionsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutInteractionsInput, CampaignUpdateWithoutInteractionsInput>, CampaignUncheckedUpdateWithoutInteractionsInput>
  }

  export type NPCUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<NPCCreateWithoutInteractionsInput, NPCUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutInteractionsInput
    upsert?: NPCUpsertWithoutInteractionsInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutInteractionsInput, NPCUpdateWithoutInteractionsInput>, NPCUncheckedUpdateWithoutInteractionsInput>
  }

  export type InteractionItemUpdateManyWithoutInteractionNestedInput = {
    create?: XOR<InteractionItemCreateWithoutInteractionInput, InteractionItemUncheckedCreateWithoutInteractionInput> | InteractionItemCreateWithoutInteractionInput[] | InteractionItemUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutInteractionInput | InteractionItemCreateOrConnectWithoutInteractionInput[]
    upsert?: InteractionItemUpsertWithWhereUniqueWithoutInteractionInput | InteractionItemUpsertWithWhereUniqueWithoutInteractionInput[]
    createMany?: InteractionItemCreateManyInteractionInputEnvelope
    set?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    disconnect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    delete?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    update?: InteractionItemUpdateWithWhereUniqueWithoutInteractionInput | InteractionItemUpdateWithWhereUniqueWithoutInteractionInput[]
    updateMany?: InteractionItemUpdateManyWithWhereWithoutInteractionInput | InteractionItemUpdateManyWithWhereWithoutInteractionInput[]
    deleteMany?: InteractionItemScalarWhereInput | InteractionItemScalarWhereInput[]
  }

  export type InteractionItemUncheckedUpdateManyWithoutInteractionNestedInput = {
    create?: XOR<InteractionItemCreateWithoutInteractionInput, InteractionItemUncheckedCreateWithoutInteractionInput> | InteractionItemCreateWithoutInteractionInput[] | InteractionItemUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: InteractionItemCreateOrConnectWithoutInteractionInput | InteractionItemCreateOrConnectWithoutInteractionInput[]
    upsert?: InteractionItemUpsertWithWhereUniqueWithoutInteractionInput | InteractionItemUpsertWithWhereUniqueWithoutInteractionInput[]
    createMany?: InteractionItemCreateManyInteractionInputEnvelope
    set?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    disconnect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    delete?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    connect?: InteractionItemWhereUniqueInput | InteractionItemWhereUniqueInput[]
    update?: InteractionItemUpdateWithWhereUniqueWithoutInteractionInput | InteractionItemUpdateWithWhereUniqueWithoutInteractionInput[]
    updateMany?: InteractionItemUpdateManyWithWhereWithoutInteractionInput | InteractionItemUpdateManyWithWhereWithoutInteractionInput[]
    deleteMany?: InteractionItemScalarWhereInput | InteractionItemScalarWhereInput[]
  }

  export type MonsterCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<MonsterCreateWithoutCampaignsInput, MonsterUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MonsterCreateOrConnectWithoutCampaignsInput
    connect?: MonsterWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutMonsterCampaignsInput = {
    create?: XOR<CampaignCreateWithoutMonsterCampaignsInput, CampaignUncheckedCreateWithoutMonsterCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMonsterCampaignsInput
    connect?: CampaignWhereUniqueInput
  }

  export type MonsterUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<MonsterCreateWithoutCampaignsInput, MonsterUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MonsterCreateOrConnectWithoutCampaignsInput
    upsert?: MonsterUpsertWithoutCampaignsInput
    connect?: MonsterWhereUniqueInput
    update?: XOR<XOR<MonsterUpdateToOneWithWhereWithoutCampaignsInput, MonsterUpdateWithoutCampaignsInput>, MonsterUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignUpdateOneRequiredWithoutMonsterCampaignsNestedInput = {
    create?: XOR<CampaignCreateWithoutMonsterCampaignsInput, CampaignUncheckedCreateWithoutMonsterCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMonsterCampaignsInput
    upsert?: CampaignUpsertWithoutMonsterCampaignsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMonsterCampaignsInput, CampaignUpdateWithoutMonsterCampaignsInput>, CampaignUncheckedUpdateWithoutMonsterCampaignsInput>
  }

  export type ItemCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ItemCreateWithoutCampaignsInput, ItemUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCampaignsInput
    connect?: ItemWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutItemCampaignsInput = {
    create?: XOR<CampaignCreateWithoutItemCampaignsInput, CampaignUncheckedCreateWithoutItemCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutItemCampaignsInput
    connect?: CampaignWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<ItemCreateWithoutCampaignsInput, ItemUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutCampaignsInput
    upsert?: ItemUpsertWithoutCampaignsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutCampaignsInput, ItemUpdateWithoutCampaignsInput>, ItemUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignUpdateOneRequiredWithoutItemCampaignsNestedInput = {
    create?: XOR<CampaignCreateWithoutItemCampaignsInput, CampaignUncheckedCreateWithoutItemCampaignsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutItemCampaignsInput
    upsert?: CampaignUpsertWithoutItemCampaignsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutItemCampaignsInput, CampaignUpdateWithoutItemCampaignsInput>, CampaignUncheckedUpdateWithoutItemCampaignsInput>
  }

  export type NPCCreateNestedOneWithoutLocationsInput = {
    create?: XOR<NPCCreateWithoutLocationsInput, NPCUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutLocationsInput
    connect?: NPCWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutNpcsInput = {
    create?: XOR<LocationCreateWithoutNpcsInput, LocationUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutNpcsInput
    connect?: LocationWhereUniqueInput
  }

  export type NPCUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<NPCCreateWithoutLocationsInput, NPCUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutLocationsInput
    upsert?: NPCUpsertWithoutLocationsInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutLocationsInput, NPCUpdateWithoutLocationsInput>, NPCUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutNpcsNestedInput = {
    create?: XOR<LocationCreateWithoutNpcsInput, LocationUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutNpcsInput
    upsert?: LocationUpsertWithoutNpcsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutNpcsInput, LocationUpdateWithoutNpcsInput>, LocationUncheckedUpdateWithoutNpcsInput>
  }

  export type QuestCreateNestedOneWithoutNpcsInput = {
    create?: XOR<QuestCreateWithoutNpcsInput, QuestUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutNpcsInput
    connect?: QuestWhereUniqueInput
  }

  export type NPCCreateNestedOneWithoutQuestsInvolvedInput = {
    create?: XOR<NPCCreateWithoutQuestsInvolvedInput, NPCUncheckedCreateWithoutQuestsInvolvedInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsInvolvedInput
    connect?: NPCWhereUniqueInput
  }

  export type QuestUpdateOneRequiredWithoutNpcsNestedInput = {
    create?: XOR<QuestCreateWithoutNpcsInput, QuestUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutNpcsInput
    upsert?: QuestUpsertWithoutNpcsInput
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutNpcsInput, QuestUpdateWithoutNpcsInput>, QuestUncheckedUpdateWithoutNpcsInput>
  }

  export type NPCUpdateOneRequiredWithoutQuestsInvolvedNestedInput = {
    create?: XOR<NPCCreateWithoutQuestsInvolvedInput, NPCUncheckedCreateWithoutQuestsInvolvedInput>
    connectOrCreate?: NPCCreateOrConnectWithoutQuestsInvolvedInput
    upsert?: NPCUpsertWithoutQuestsInvolvedInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutQuestsInvolvedInput, NPCUpdateWithoutQuestsInvolvedInput>, NPCUncheckedUpdateWithoutQuestsInvolvedInput>
  }

  export type QuestCreateNestedOneWithoutLocationsInput = {
    create?: XOR<QuestCreateWithoutLocationsInput, QuestUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutLocationsInput
    connect?: QuestWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutQuestsInput = {
    create?: XOR<LocationCreateWithoutQuestsInput, LocationUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutQuestsInput
    connect?: LocationWhereUniqueInput
  }

  export type QuestUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<QuestCreateWithoutLocationsInput, QuestUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: QuestCreateOrConnectWithoutLocationsInput
    upsert?: QuestUpsertWithoutLocationsInput
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutLocationsInput, QuestUpdateWithoutLocationsInput>, QuestUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<LocationCreateWithoutQuestsInput, LocationUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutQuestsInput
    upsert?: LocationUpsertWithoutQuestsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutQuestsInput, LocationUpdateWithoutQuestsInput>, LocationUncheckedUpdateWithoutQuestsInput>
  }

  export type ChronicleCreateNestedOneWithoutQuestsInput = {
    create?: XOR<ChronicleCreateWithoutQuestsInput, ChronicleUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: ChronicleCreateOrConnectWithoutQuestsInput
    connect?: ChronicleWhereUniqueInput
  }

  export type QuestCreateNestedOneWithoutChroniclesInput = {
    create?: XOR<QuestCreateWithoutChroniclesInput, QuestUncheckedCreateWithoutChroniclesInput>
    connectOrCreate?: QuestCreateOrConnectWithoutChroniclesInput
    connect?: QuestWhereUniqueInput
  }

  export type ChronicleUpdateOneRequiredWithoutQuestsNestedInput = {
    create?: XOR<ChronicleCreateWithoutQuestsInput, ChronicleUncheckedCreateWithoutQuestsInput>
    connectOrCreate?: ChronicleCreateOrConnectWithoutQuestsInput
    upsert?: ChronicleUpsertWithoutQuestsInput
    connect?: ChronicleWhereUniqueInput
    update?: XOR<XOR<ChronicleUpdateToOneWithWhereWithoutQuestsInput, ChronicleUpdateWithoutQuestsInput>, ChronicleUncheckedUpdateWithoutQuestsInput>
  }

  export type QuestUpdateOneRequiredWithoutChroniclesNestedInput = {
    create?: XOR<QuestCreateWithoutChroniclesInput, QuestUncheckedCreateWithoutChroniclesInput>
    connectOrCreate?: QuestCreateOrConnectWithoutChroniclesInput
    upsert?: QuestUpsertWithoutChroniclesInput
    connect?: QuestWhereUniqueInput
    update?: XOR<XOR<QuestUpdateToOneWithWhereWithoutChroniclesInput, QuestUpdateWithoutChroniclesInput>, QuestUncheckedUpdateWithoutChroniclesInput>
  }

  export type ItemCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ItemCreateWithoutLocationsInput, ItemUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutLocationsInput
    connect?: ItemWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutItemsInput = {
    create?: XOR<LocationCreateWithoutItemsInput, LocationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutItemsInput
    connect?: LocationWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<ItemCreateWithoutLocationsInput, ItemUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutLocationsInput
    upsert?: ItemUpsertWithoutLocationsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutLocationsInput, ItemUpdateWithoutLocationsInput>, ItemUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<LocationCreateWithoutItemsInput, LocationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutItemsInput
    upsert?: LocationUpsertWithoutItemsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutItemsInput, LocationUpdateWithoutItemsInput>, LocationUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCreateNestedOneWithoutNpcsInput = {
    create?: XOR<ItemCreateWithoutNpcsInput, ItemUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutNpcsInput
    connect?: ItemWhereUniqueInput
  }

  export type NPCCreateNestedOneWithoutItemsInput = {
    create?: XOR<NPCCreateWithoutItemsInput, NPCUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutItemsInput
    connect?: NPCWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutNpcsNestedInput = {
    create?: XOR<ItemCreateWithoutNpcsInput, ItemUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutNpcsInput
    upsert?: ItemUpsertWithoutNpcsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutNpcsInput, ItemUpdateWithoutNpcsInput>, ItemUncheckedUpdateWithoutNpcsInput>
  }

  export type NPCUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<NPCCreateWithoutItemsInput, NPCUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutItemsInput
    upsert?: NPCUpsertWithoutItemsInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutItemsInput, NPCUpdateWithoutItemsInput>, NPCUncheckedUpdateWithoutItemsInput>
  }

  export type InteractionCreateNestedOneWithoutItemsInput = {
    create?: XOR<InteractionCreateWithoutItemsInput, InteractionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InteractionCreateOrConnectWithoutItemsInput
    connect?: InteractionWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<ItemCreateWithoutInteractionsInput, ItemUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInteractionsInput
    connect?: ItemWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type InteractionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InteractionCreateWithoutItemsInput, InteractionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InteractionCreateOrConnectWithoutItemsInput
    upsert?: InteractionUpsertWithoutItemsInput
    connect?: InteractionWhereUniqueInput
    update?: XOR<XOR<InteractionUpdateToOneWithWhereWithoutItemsInput, InteractionUpdateWithoutItemsInput>, InteractionUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<ItemCreateWithoutInteractionsInput, ItemUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInteractionsInput
    upsert?: ItemUpsertWithoutInteractionsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInteractionsInput, ItemUpdateWithoutInteractionsInput>, ItemUncheckedUpdateWithoutInteractionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRaceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | null
    notIn?: $Enums.Race[] | null
    not?: NestedEnumRaceNullableFilter<$PrismaModel> | $Enums.Race | null
  }

  export type NestedEnumCreatureTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreatureType[] | null
    notIn?: $Enums.CreatureType[] | null
    not?: NestedEnumCreatureTypeNullableFilter<$PrismaModel> | $Enums.CreatureType | null
  }

  export type NestedEnumNPCRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCRole | EnumNPCRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCRole[] | null
    notIn?: $Enums.NPCRole[] | null
    not?: NestedEnumNPCRoleNullableFilter<$PrismaModel> | $Enums.NPCRole | null
  }

  export type NestedEnumCharacterClassNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel> | null
    in?: $Enums.CharacterClass[] | null
    notIn?: $Enums.CharacterClass[] | null
    not?: NestedEnumCharacterClassNullableFilter<$PrismaModel> | $Enums.CharacterClass | null
  }

  export type NestedEnumAlignmentNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Alignment[] | null
    notIn?: $Enums.Alignment[] | null
    not?: NestedEnumAlignmentNullableFilter<$PrismaModel> | $Enums.Alignment | null
  }

  export type NestedEnumNPCAttitudeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCAttitude | EnumNPCAttitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCAttitude[] | null
    notIn?: $Enums.NPCAttitude[] | null
    not?: NestedEnumNPCAttitudeNullableFilter<$PrismaModel> | $Enums.NPCAttitude | null
  }

  export type NestedEnumRaceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel> | null
    in?: $Enums.Race[] | null
    notIn?: $Enums.Race[] | null
    not?: NestedEnumRaceNullableWithAggregatesFilter<$PrismaModel> | $Enums.Race | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRaceNullableFilter<$PrismaModel>
    _max?: NestedEnumRaceNullableFilter<$PrismaModel>
  }

  export type NestedEnumCreatureTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreatureType[] | null
    notIn?: $Enums.CreatureType[] | null
    not?: NestedEnumCreatureTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CreatureType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCreatureTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCreatureTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNPCRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCRole | EnumNPCRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCRole[] | null
    notIn?: $Enums.NPCRole[] | null
    not?: NestedEnumNPCRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.NPCRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNPCRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumNPCRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumCharacterClassNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel> | null
    in?: $Enums.CharacterClass[] | null
    notIn?: $Enums.CharacterClass[] | null
    not?: NestedEnumCharacterClassNullableWithAggregatesFilter<$PrismaModel> | $Enums.CharacterClass | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCharacterClassNullableFilter<$PrismaModel>
    _max?: NestedEnumCharacterClassNullableFilter<$PrismaModel>
  }

  export type NestedEnumAlignmentNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel> | null
    in?: $Enums.Alignment[] | null
    notIn?: $Enums.Alignment[] | null
    not?: NestedEnumAlignmentNullableWithAggregatesFilter<$PrismaModel> | $Enums.Alignment | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAlignmentNullableFilter<$PrismaModel>
    _max?: NestedEnumAlignmentNullableFilter<$PrismaModel>
  }

  export type NestedEnumNPCAttitudeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NPCAttitude | EnumNPCAttitudeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NPCAttitude[] | null
    notIn?: $Enums.NPCAttitude[] | null
    not?: NestedEnumNPCAttitudeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NPCAttitude | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNPCAttitudeNullableFilter<$PrismaModel>
    _max?: NestedEnumNPCAttitudeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumMapAnnotationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MapAnnotationType | EnumMapAnnotationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MapAnnotationType[]
    notIn?: $Enums.MapAnnotationType[]
    not?: NestedEnumMapAnnotationTypeFilter<$PrismaModel> | $Enums.MapAnnotationType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMapAnnotationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MapAnnotationType | EnumMapAnnotationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MapAnnotationType[]
    notIn?: $Enums.MapAnnotationType[]
    not?: NestedEnumMapAnnotationTypeWithAggregatesFilter<$PrismaModel> | $Enums.MapAnnotationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMapAnnotationTypeFilter<$PrismaModel>
    _max?: NestedEnumMapAnnotationTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[]
    notIn?: $Enums.Size[]
    not?: NestedEnumSizeFilter<$PrismaModel> | $Enums.Size
  }

  export type NestedEnumCreatureTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreatureType[]
    notIn?: $Enums.CreatureType[]
    not?: NestedEnumCreatureTypeFilter<$PrismaModel> | $Enums.CreatureType
  }

  export type NestedEnumAlignmentFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.Alignment[]
    notIn?: $Enums.Alignment[]
    not?: NestedEnumAlignmentFilter<$PrismaModel> | $Enums.Alignment
  }

  export type NestedEnumSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel>
    in?: $Enums.Size[]
    notIn?: $Enums.Size[]
    not?: NestedEnumSizeWithAggregatesFilter<$PrismaModel> | $Enums.Size
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSizeFilter<$PrismaModel>
    _max?: NestedEnumSizeFilter<$PrismaModel>
  }

  export type NestedEnumCreatureTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatureType | EnumCreatureTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreatureType[]
    notIn?: $Enums.CreatureType[]
    not?: NestedEnumCreatureTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreatureType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatureTypeFilter<$PrismaModel>
    _max?: NestedEnumCreatureTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlignmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Alignment | EnumAlignmentFieldRefInput<$PrismaModel>
    in?: $Enums.Alignment[]
    notIn?: $Enums.Alignment[]
    not?: NestedEnumAlignmentWithAggregatesFilter<$PrismaModel> | $Enums.Alignment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlignmentFilter<$PrismaModel>
    _max?: NestedEnumAlignmentFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type NestedEnumEncounterStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[]
    notIn?: $Enums.EncounterStatus[]
    not?: NestedEnumEncounterStatusFilter<$PrismaModel> | $Enums.EncounterStatus
  }

  export type NestedEnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type NestedEnumEncounterStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterStatus | EnumEncounterStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterStatus[]
    notIn?: $Enums.EncounterStatus[]
    not?: NestedEnumEncounterStatusWithAggregatesFilter<$PrismaModel> | $Enums.EncounterStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterStatusFilter<$PrismaModel>
    _max?: NestedEnumEncounterStatusFilter<$PrismaModel>
  }

  export type NestedEnumParticipantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[]
    notIn?: $Enums.ParticipantType[]
    not?: NestedEnumParticipantTypeFilter<$PrismaModel> | $Enums.ParticipantType
  }

  export type NestedEnumParticipantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[]
    notIn?: $Enums.ParticipantType[]
    not?: NestedEnumParticipantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantTypeFilter<$PrismaModel>
    _max?: NestedEnumParticipantTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRaceFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[]
    notIn?: $Enums.Race[]
    not?: NestedEnumRaceFilter<$PrismaModel> | $Enums.Race
  }

  export type NestedEnumCharacterClassFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterClass[]
    notIn?: $Enums.CharacterClass[]
    not?: NestedEnumCharacterClassFilter<$PrismaModel> | $Enums.CharacterClass
  }

  export type NestedEnumBackgroundTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundType | EnumBackgroundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundType[]
    notIn?: $Enums.BackgroundType[]
    not?: NestedEnumBackgroundTypeFilter<$PrismaModel> | $Enums.BackgroundType
  }

  export type NestedEnumRaceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Race | EnumRaceFieldRefInput<$PrismaModel>
    in?: $Enums.Race[]
    notIn?: $Enums.Race[]
    not?: NestedEnumRaceWithAggregatesFilter<$PrismaModel> | $Enums.Race
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRaceFilter<$PrismaModel>
    _max?: NestedEnumRaceFilter<$PrismaModel>
  }

  export type NestedEnumCharacterClassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CharacterClass | EnumCharacterClassFieldRefInput<$PrismaModel>
    in?: $Enums.CharacterClass[]
    notIn?: $Enums.CharacterClass[]
    not?: NestedEnumCharacterClassWithAggregatesFilter<$PrismaModel> | $Enums.CharacterClass
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCharacterClassFilter<$PrismaModel>
    _max?: NestedEnumCharacterClassFilter<$PrismaModel>
  }

  export type NestedEnumBackgroundTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundType | EnumBackgroundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundType[]
    notIn?: $Enums.BackgroundType[]
    not?: NestedEnumBackgroundTypeWithAggregatesFilter<$PrismaModel> | $Enums.BackgroundType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackgroundTypeFilter<$PrismaModel>
    _max?: NestedEnumBackgroundTypeFilter<$PrismaModel>
  }

  export type NestedEnumQuestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestStatus | EnumQuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestStatus[]
    notIn?: $Enums.QuestStatus[]
    not?: NestedEnumQuestStatusFilter<$PrismaModel> | $Enums.QuestStatus
  }

  export type NestedEnumQuestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestStatus | EnumQuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestStatus[]
    notIn?: $Enums.QuestStatus[]
    not?: NestedEnumQuestStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestStatusFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedEnumItemRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[]
    notIn?: $Enums.ItemRarity[]
    not?: NestedEnumItemRarityFilter<$PrismaModel> | $Enums.ItemRarity
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRarity | EnumItemRarityFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRarity[]
    notIn?: $Enums.ItemRarity[]
    not?: NestedEnumItemRarityWithAggregatesFilter<$PrismaModel> | $Enums.ItemRarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRarityFilter<$PrismaModel>
    _max?: NestedEnumItemRarityFilter<$PrismaModel>
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[]
    notIn?: $Enums.InteractionType[]
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[]
    notIn?: $Enums.TransactionType[]
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NPCCreateWithoutCampaignInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationCreateNestedManyWithoutNpcInput
    questsGiven?: QuestCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCCreateNestedManyWithoutNpcInput
    interactions?: InteractionCreateNestedManyWithoutNpcInput
    items?: ItemNPCCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationUncheckedCreateNestedManyWithoutNpcInput
    questsGiven?: QuestUncheckedCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCUncheckedCreateNestedManyWithoutNpcInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutNpcInput
    items?: ItemNPCUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutCampaignInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutCampaignInput, NPCUncheckedCreateWithoutCampaignInput>
  }

  export type NPCCreateManyCampaignInputEnvelope = {
    data: NPCCreateManyCampaignInput | NPCCreateManyCampaignInput[]
  }

  export type LocationCreateWithoutCampaignInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCampaignInput = {
    id?: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCampaignInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCampaignInput, LocationUncheckedCreateWithoutCampaignInput>
  }

  export type LocationCreateManyCampaignInputEnvelope = {
    data: LocationCreateManyCampaignInput | LocationCreateManyCampaignInput[]
  }

  export type MapCreateWithoutCampaignInput = {
    id?: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutMapsInput
    annotations?: MapAnnotationCreateNestedManyWithoutMapInput
    encounters?: EncounterCreateNestedManyWithoutMapInput
  }

  export type MapUncheckedCreateWithoutCampaignInput = {
    id?: string
    locationId?: string | null
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    annotations?: MapAnnotationUncheckedCreateNestedManyWithoutMapInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutMapInput
  }

  export type MapCreateOrConnectWithoutCampaignInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutCampaignInput, MapUncheckedCreateWithoutCampaignInput>
  }

  export type MapCreateManyCampaignInputEnvelope = {
    data: MapCreateManyCampaignInput | MapCreateManyCampaignInput[]
  }

  export type EncounterCreateWithoutCampaignInput = {
    id?: string
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    map?: MapCreateNestedOneWithoutEncountersInput
    location?: LocationCreateNestedOneWithoutEncountersInput
    participants?: EncounterParticipantCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutCampaignInput = {
    id?: string
    mapId?: string | null
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    participants?: EncounterParticipantUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutCampaignInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput>
  }

  export type EncounterCreateManyCampaignInputEnvelope = {
    data: EncounterCreateManyCampaignInput | EncounterCreateManyCampaignInput[]
  }

  export type PlayerCharacterCreateWithoutCampaignInput = {
    id?: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    encounterParticipants?: EncounterParticipantCreateNestedManyWithoutPlayerCharacterInput
  }

  export type PlayerCharacterUncheckedCreateWithoutCampaignInput = {
    id?: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    encounterParticipants?: EncounterParticipantUncheckedCreateNestedManyWithoutPlayerCharacterInput
  }

  export type PlayerCharacterCreateOrConnectWithoutCampaignInput = {
    where: PlayerCharacterWhereUniqueInput
    create: XOR<PlayerCharacterCreateWithoutCampaignInput, PlayerCharacterUncheckedCreateWithoutCampaignInput>
  }

  export type PlayerCharacterCreateManyCampaignInputEnvelope = {
    data: PlayerCharacterCreateManyCampaignInput | PlayerCharacterCreateManyCampaignInput[]
  }

  export type QuestCreateWithoutCampaignInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutCampaignInput = {
    id?: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutCampaignInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutCampaignInput, QuestUncheckedCreateWithoutCampaignInput>
  }

  export type QuestCreateManyCampaignInputEnvelope = {
    data: QuestCreateManyCampaignInput | QuestCreateManyCampaignInput[]
  }

  export type ChronicleCreateWithoutCampaignInput = {
    id?: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quests?: ChronicleQuestCreateNestedManyWithoutChronicleInput
  }

  export type ChronicleUncheckedCreateWithoutCampaignInput = {
    id?: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quests?: ChronicleQuestUncheckedCreateNestedManyWithoutChronicleInput
  }

  export type ChronicleCreateOrConnectWithoutCampaignInput = {
    where: ChronicleWhereUniqueInput
    create: XOR<ChronicleCreateWithoutCampaignInput, ChronicleUncheckedCreateWithoutCampaignInput>
  }

  export type ChronicleCreateManyCampaignInputEnvelope = {
    data: ChronicleCreateManyCampaignInput | ChronicleCreateManyCampaignInput[]
  }

  export type InteractionCreateWithoutCampaignInput = {
    id?: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    npc: NPCCreateNestedOneWithoutInteractionsInput
    items?: InteractionItemCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUncheckedCreateWithoutCampaignInput = {
    id?: string
    npcId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    items?: InteractionItemUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type InteractionCreateOrConnectWithoutCampaignInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutCampaignInput, InteractionUncheckedCreateWithoutCampaignInput>
  }

  export type InteractionCreateManyCampaignInputEnvelope = {
    data: InteractionCreateManyCampaignInput | InteractionCreateManyCampaignInput[]
  }

  export type MonsterCampaignCreateWithoutCampaignInput = {
    monster: MonsterCreateNestedOneWithoutCampaignsInput
  }

  export type MonsterCampaignUncheckedCreateWithoutCampaignInput = {
    monsterId: string
  }

  export type MonsterCampaignCreateOrConnectWithoutCampaignInput = {
    where: MonsterCampaignWhereUniqueInput
    create: XOR<MonsterCampaignCreateWithoutCampaignInput, MonsterCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type MonsterCampaignCreateManyCampaignInputEnvelope = {
    data: MonsterCampaignCreateManyCampaignInput | MonsterCampaignCreateManyCampaignInput[]
  }

  export type ItemCampaignCreateWithoutCampaignInput = {
    item: ItemCreateNestedOneWithoutCampaignsInput
  }

  export type ItemCampaignUncheckedCreateWithoutCampaignInput = {
    itemId: string
  }

  export type ItemCampaignCreateOrConnectWithoutCampaignInput = {
    where: ItemCampaignWhereUniqueInput
    create: XOR<ItemCampaignCreateWithoutCampaignInput, ItemCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type ItemCampaignCreateManyCampaignInputEnvelope = {
    data: ItemCampaignCreateManyCampaignInput | ItemCampaignCreateManyCampaignInput[]
  }

  export type NPCUpsertWithWhereUniqueWithoutCampaignInput = {
    where: NPCWhereUniqueInput
    update: XOR<NPCUpdateWithoutCampaignInput, NPCUncheckedUpdateWithoutCampaignInput>
    create: XOR<NPCCreateWithoutCampaignInput, NPCUncheckedCreateWithoutCampaignInput>
  }

  export type NPCUpdateWithWhereUniqueWithoutCampaignInput = {
    where: NPCWhereUniqueInput
    data: XOR<NPCUpdateWithoutCampaignInput, NPCUncheckedUpdateWithoutCampaignInput>
  }

  export type NPCUpdateManyWithWhereWithoutCampaignInput = {
    where: NPCScalarWhereInput
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyWithoutCampaignInput>
  }

  export type NPCScalarWhereInput = {
    AND?: NPCScalarWhereInput | NPCScalarWhereInput[]
    OR?: NPCScalarWhereInput[]
    NOT?: NPCScalarWhereInput | NPCScalarWhereInput[]
    id?: StringFilter<"NPC"> | string
    campaignId?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    title?: StringNullableFilter<"NPC"> | string | null
    race?: EnumRaceNullableFilter<"NPC"> | $Enums.Race | null
    creatureType?: EnumCreatureTypeNullableFilter<"NPC"> | $Enums.CreatureType | null
    role?: EnumNPCRoleNullableFilter<"NPC"> | $Enums.NPCRole | null
    class?: EnumCharacterClassNullableFilter<"NPC"> | $Enums.CharacterClass | null
    alignment?: EnumAlignmentNullableFilter<"NPC"> | $Enums.Alignment | null
    attitudeToParty?: EnumNPCAttitudeNullableFilter<"NPC"> | $Enums.NPCAttitude | null
    languages?: JsonNullableFilter<"NPC">
    appearance?: StringNullableFilter<"NPC"> | string | null
    personality?: StringNullableFilter<"NPC"> | string | null
    motivations?: StringNullableFilter<"NPC"> | string | null
    backstory?: StringNullableFilter<"NPC"> | string | null
    dmNotes?: StringNullableFilter<"NPC"> | string | null
    portraitPath?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    updatedAt?: DateTimeFilter<"NPC"> | Date | string
  }

  export type LocationUpsertWithWhereUniqueWithoutCampaignInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutCampaignInput, LocationUncheckedUpdateWithoutCampaignInput>
    create: XOR<LocationCreateWithoutCampaignInput, LocationUncheckedCreateWithoutCampaignInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutCampaignInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutCampaignInput, LocationUncheckedUpdateWithoutCampaignInput>
  }

  export type LocationUpdateManyWithWhereWithoutCampaignInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutCampaignInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    campaignId?: StringFilter<"Location"> | string
    parentLocationId?: StringNullableFilter<"Location"> | string | null
    name?: StringFilter<"Location"> | string
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    description?: StringNullableFilter<"Location"> | string | null
    notableFeatures?: JsonNullableFilter<"Location">
    coverImagePath?: StringNullableFilter<"Location"> | string | null
    dmNotes?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type MapUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MapWhereUniqueInput
    update: XOR<MapUpdateWithoutCampaignInput, MapUncheckedUpdateWithoutCampaignInput>
    create: XOR<MapCreateWithoutCampaignInput, MapUncheckedCreateWithoutCampaignInput>
  }

  export type MapUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MapWhereUniqueInput
    data: XOR<MapUpdateWithoutCampaignInput, MapUncheckedUpdateWithoutCampaignInput>
  }

  export type MapUpdateManyWithWhereWithoutCampaignInput = {
    where: MapScalarWhereInput
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyWithoutCampaignInput>
  }

  export type MapScalarWhereInput = {
    AND?: MapScalarWhereInput | MapScalarWhereInput[]
    OR?: MapScalarWhereInput[]
    NOT?: MapScalarWhereInput | MapScalarWhereInput[]
    id?: StringFilter<"Map"> | string
    campaignId?: StringFilter<"Map"> | string
    locationId?: StringNullableFilter<"Map"> | string | null
    name?: StringFilter<"Map"> | string
    imagePath?: StringFilter<"Map"> | string
    gridSize?: IntNullableFilter<"Map"> | number | null
    gridEnabled?: BoolFilter<"Map"> | boolean
    scale?: StringNullableFilter<"Map"> | string | null
    width?: IntNullableFilter<"Map"> | number | null
    height?: IntNullableFilter<"Map"> | number | null
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
  }

  export type EncounterUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutCampaignInput, EncounterUncheckedUpdateWithoutCampaignInput>
    create: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutCampaignInput, EncounterUncheckedUpdateWithoutCampaignInput>
  }

  export type EncounterUpdateManyWithWhereWithoutCampaignInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    campaignId?: StringFilter<"Encounter"> | string
    mapId?: StringNullableFilter<"Encounter"> | string | null
    locationId?: StringNullableFilter<"Encounter"> | string | null
    name?: StringFilter<"Encounter"> | string
    description?: StringNullableFilter<"Encounter"> | string | null
    difficulty?: EnumDifficultyFilter<"Encounter"> | $Enums.Difficulty
    status?: EnumEncounterStatusFilter<"Encounter"> | $Enums.EncounterStatus
    dmNotes?: StringNullableFilter<"Encounter"> | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    startedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
  }

  export type PlayerCharacterUpsertWithWhereUniqueWithoutCampaignInput = {
    where: PlayerCharacterWhereUniqueInput
    update: XOR<PlayerCharacterUpdateWithoutCampaignInput, PlayerCharacterUncheckedUpdateWithoutCampaignInput>
    create: XOR<PlayerCharacterCreateWithoutCampaignInput, PlayerCharacterUncheckedCreateWithoutCampaignInput>
  }

  export type PlayerCharacterUpdateWithWhereUniqueWithoutCampaignInput = {
    where: PlayerCharacterWhereUniqueInput
    data: XOR<PlayerCharacterUpdateWithoutCampaignInput, PlayerCharacterUncheckedUpdateWithoutCampaignInput>
  }

  export type PlayerCharacterUpdateManyWithWhereWithoutCampaignInput = {
    where: PlayerCharacterScalarWhereInput
    data: XOR<PlayerCharacterUpdateManyMutationInput, PlayerCharacterUncheckedUpdateManyWithoutCampaignInput>
  }

  export type PlayerCharacterScalarWhereInput = {
    AND?: PlayerCharacterScalarWhereInput | PlayerCharacterScalarWhereInput[]
    OR?: PlayerCharacterScalarWhereInput[]
    NOT?: PlayerCharacterScalarWhereInput | PlayerCharacterScalarWhereInput[]
    id?: StringFilter<"PlayerCharacter"> | string
    campaignId?: StringFilter<"PlayerCharacter"> | string
    playerName?: StringFilter<"PlayerCharacter"> | string
    characterName?: StringFilter<"PlayerCharacter"> | string
    race?: EnumRaceFilter<"PlayerCharacter"> | $Enums.Race
    class?: EnumCharacterClassFilter<"PlayerCharacter"> | $Enums.CharacterClass
    level?: IntFilter<"PlayerCharacter"> | number
    alignment?: EnumAlignmentFilter<"PlayerCharacter"> | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFilter<"PlayerCharacter"> | $Enums.BackgroundType
    background?: StringNullableFilter<"PlayerCharacter"> | string | null
    languages?: JsonNullableFilter<"PlayerCharacter">
    portraitPath?: StringNullableFilter<"PlayerCharacter"> | string | null
    hpMax?: IntFilter<"PlayerCharacter"> | number
    ac?: IntFilter<"PlayerCharacter"> | number
    passivePerception?: IntFilter<"PlayerCharacter"> | number
    isActive?: BoolFilter<"PlayerCharacter"> | boolean
    createdAt?: DateTimeFilter<"PlayerCharacter"> | Date | string
    updatedAt?: DateTimeFilter<"PlayerCharacter"> | Date | string
  }

  export type QuestUpsertWithWhereUniqueWithoutCampaignInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutCampaignInput, QuestUncheckedUpdateWithoutCampaignInput>
    create: XOR<QuestCreateWithoutCampaignInput, QuestUncheckedCreateWithoutCampaignInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutCampaignInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutCampaignInput, QuestUncheckedUpdateWithoutCampaignInput>
  }

  export type QuestUpdateManyWithWhereWithoutCampaignInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutCampaignInput>
  }

  export type QuestScalarWhereInput = {
    AND?: QuestScalarWhereInput | QuestScalarWhereInput[]
    OR?: QuestScalarWhereInput[]
    NOT?: QuestScalarWhereInput | QuestScalarWhereInput[]
    id?: StringFilter<"Quest"> | string
    campaignId?: StringFilter<"Quest"> | string
    parentQuestId?: StringNullableFilter<"Quest"> | string | null
    name?: StringFilter<"Quest"> | string
    description?: StringNullableFilter<"Quest"> | string | null
    objectives?: JsonNullableFilter<"Quest">
    status?: EnumQuestStatusFilter<"Quest"> | $Enums.QuestStatus
    questGiverNpcId?: StringNullableFilter<"Quest"> | string | null
    rewardDescription?: StringNullableFilter<"Quest"> | string | null
    rewardItems?: JsonNullableFilter<"Quest">
    isMilestone?: BoolFilter<"Quest"> | boolean
    dmNotes?: StringNullableFilter<"Quest"> | string | null
    createdAt?: DateTimeFilter<"Quest"> | Date | string
    startedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Quest"> | Date | string | null
  }

  export type ChronicleUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ChronicleWhereUniqueInput
    update: XOR<ChronicleUpdateWithoutCampaignInput, ChronicleUncheckedUpdateWithoutCampaignInput>
    create: XOR<ChronicleCreateWithoutCampaignInput, ChronicleUncheckedCreateWithoutCampaignInput>
  }

  export type ChronicleUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ChronicleWhereUniqueInput
    data: XOR<ChronicleUpdateWithoutCampaignInput, ChronicleUncheckedUpdateWithoutCampaignInput>
  }

  export type ChronicleUpdateManyWithWhereWithoutCampaignInput = {
    where: ChronicleScalarWhereInput
    data: XOR<ChronicleUpdateManyMutationInput, ChronicleUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ChronicleScalarWhereInput = {
    AND?: ChronicleScalarWhereInput | ChronicleScalarWhereInput[]
    OR?: ChronicleScalarWhereInput[]
    NOT?: ChronicleScalarWhereInput | ChronicleScalarWhereInput[]
    id?: StringFilter<"Chronicle"> | string
    campaignId?: StringFilter<"Chronicle"> | string
    sessionNumber?: IntFilter<"Chronicle"> | number
    sessionDate?: DateTimeFilter<"Chronicle"> | Date | string
    title?: StringNullableFilter<"Chronicle"> | string | null
    summary?: StringNullableFilter<"Chronicle"> | string | null
    playerDeeds?: JsonNullableFilter<"Chronicle">
    importantDecisions?: JsonNullableFilter<"Chronicle">
    dmNotes?: StringNullableFilter<"Chronicle"> | string | null
    createdAt?: DateTimeFilter<"Chronicle"> | Date | string
    updatedAt?: DateTimeFilter<"Chronicle"> | Date | string
  }

  export type InteractionUpsertWithWhereUniqueWithoutCampaignInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutCampaignInput, InteractionUncheckedUpdateWithoutCampaignInput>
    create: XOR<InteractionCreateWithoutCampaignInput, InteractionUncheckedCreateWithoutCampaignInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutCampaignInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutCampaignInput, InteractionUncheckedUpdateWithoutCampaignInput>
  }

  export type InteractionUpdateManyWithWhereWithoutCampaignInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutCampaignInput>
  }

  export type InteractionScalarWhereInput = {
    AND?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    OR?: InteractionScalarWhereInput[]
    NOT?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    id?: StringFilter<"Interaction"> | string
    campaignId?: StringFilter<"Interaction"> | string
    npcId?: StringFilter<"Interaction"> | string
    interactionDate?: DateTimeFilter<"Interaction"> | Date | string
    sessionDate?: DateTimeFilter<"Interaction"> | Date | string
    interactionType?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    summary?: StringNullableFilter<"Interaction"> | string | null
    details?: StringNullableFilter<"Interaction"> | string | null
    attitudeChange?: EnumNPCAttitudeNullableFilter<"Interaction"> | $Enums.NPCAttitude | null
    involvedPcs?: JsonNullableFilter<"Interaction">
    dmNotes?: StringNullableFilter<"Interaction"> | string | null
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
  }

  export type MonsterCampaignUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MonsterCampaignWhereUniqueInput
    update: XOR<MonsterCampaignUpdateWithoutCampaignInput, MonsterCampaignUncheckedUpdateWithoutCampaignInput>
    create: XOR<MonsterCampaignCreateWithoutCampaignInput, MonsterCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type MonsterCampaignUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MonsterCampaignWhereUniqueInput
    data: XOR<MonsterCampaignUpdateWithoutCampaignInput, MonsterCampaignUncheckedUpdateWithoutCampaignInput>
  }

  export type MonsterCampaignUpdateManyWithWhereWithoutCampaignInput = {
    where: MonsterCampaignScalarWhereInput
    data: XOR<MonsterCampaignUpdateManyMutationInput, MonsterCampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type MonsterCampaignScalarWhereInput = {
    AND?: MonsterCampaignScalarWhereInput | MonsterCampaignScalarWhereInput[]
    OR?: MonsterCampaignScalarWhereInput[]
    NOT?: MonsterCampaignScalarWhereInput | MonsterCampaignScalarWhereInput[]
    monsterId?: StringFilter<"MonsterCampaign"> | string
    campaignId?: StringFilter<"MonsterCampaign"> | string
  }

  export type ItemCampaignUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ItemCampaignWhereUniqueInput
    update: XOR<ItemCampaignUpdateWithoutCampaignInput, ItemCampaignUncheckedUpdateWithoutCampaignInput>
    create: XOR<ItemCampaignCreateWithoutCampaignInput, ItemCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type ItemCampaignUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ItemCampaignWhereUniqueInput
    data: XOR<ItemCampaignUpdateWithoutCampaignInput, ItemCampaignUncheckedUpdateWithoutCampaignInput>
  }

  export type ItemCampaignUpdateManyWithWhereWithoutCampaignInput = {
    where: ItemCampaignScalarWhereInput
    data: XOR<ItemCampaignUpdateManyMutationInput, ItemCampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ItemCampaignScalarWhereInput = {
    AND?: ItemCampaignScalarWhereInput | ItemCampaignScalarWhereInput[]
    OR?: ItemCampaignScalarWhereInput[]
    NOT?: ItemCampaignScalarWhereInput | ItemCampaignScalarWhereInput[]
    itemId?: StringFilter<"ItemCampaign"> | string
    campaignId?: StringFilter<"ItemCampaign"> | string
  }

  export type CampaignCreateWithoutNpcsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutNpcsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutNpcsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutNpcsInput, CampaignUncheckedCreateWithoutNpcsInput>
  }

  export type NPCLocationCreateWithoutNpcInput = {
    isPrimary?: boolean
    location: LocationCreateNestedOneWithoutNpcsInput
  }

  export type NPCLocationUncheckedCreateWithoutNpcInput = {
    locationId: string
    isPrimary?: boolean
  }

  export type NPCLocationCreateOrConnectWithoutNpcInput = {
    where: NPCLocationWhereUniqueInput
    create: XOR<NPCLocationCreateWithoutNpcInput, NPCLocationUncheckedCreateWithoutNpcInput>
  }

  export type NPCLocationCreateManyNpcInputEnvelope = {
    data: NPCLocationCreateManyNpcInput | NPCLocationCreateManyNpcInput[]
  }

  export type QuestCreateWithoutQuestGiverInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutQuestGiverInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutQuestGiverInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutQuestGiverInput, QuestUncheckedCreateWithoutQuestGiverInput>
  }

  export type QuestCreateManyQuestGiverInputEnvelope = {
    data: QuestCreateManyQuestGiverInput | QuestCreateManyQuestGiverInput[]
  }

  export type QuestNPCCreateWithoutNpcInput = {
    role?: string | null
    quest: QuestCreateNestedOneWithoutNpcsInput
  }

  export type QuestNPCUncheckedCreateWithoutNpcInput = {
    questId: string
    role?: string | null
  }

  export type QuestNPCCreateOrConnectWithoutNpcInput = {
    where: QuestNPCWhereUniqueInput
    create: XOR<QuestNPCCreateWithoutNpcInput, QuestNPCUncheckedCreateWithoutNpcInput>
  }

  export type QuestNPCCreateManyNpcInputEnvelope = {
    data: QuestNPCCreateManyNpcInput | QuestNPCCreateManyNpcInput[]
  }

  export type InteractionCreateWithoutNpcInput = {
    id?: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutInteractionsInput
    items?: InteractionItemCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUncheckedCreateWithoutNpcInput = {
    id?: string
    campaignId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    items?: InteractionItemUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type InteractionCreateOrConnectWithoutNpcInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutNpcInput, InteractionUncheckedCreateWithoutNpcInput>
  }

  export type InteractionCreateManyNpcInputEnvelope = {
    data: InteractionCreateManyNpcInput | InteractionCreateManyNpcInput[]
  }

  export type ItemNPCCreateWithoutNpcInput = {
    item: ItemCreateNestedOneWithoutNpcsInput
  }

  export type ItemNPCUncheckedCreateWithoutNpcInput = {
    itemId: string
  }

  export type ItemNPCCreateOrConnectWithoutNpcInput = {
    where: ItemNPCWhereUniqueInput
    create: XOR<ItemNPCCreateWithoutNpcInput, ItemNPCUncheckedCreateWithoutNpcInput>
  }

  export type ItemNPCCreateManyNpcInputEnvelope = {
    data: ItemNPCCreateManyNpcInput | ItemNPCCreateManyNpcInput[]
  }

  export type CampaignUpsertWithoutNpcsInput = {
    update: XOR<CampaignUpdateWithoutNpcsInput, CampaignUncheckedUpdateWithoutNpcsInput>
    create: XOR<CampaignCreateWithoutNpcsInput, CampaignUncheckedCreateWithoutNpcsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutNpcsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutNpcsInput, CampaignUncheckedUpdateWithoutNpcsInput>
  }

  export type CampaignUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type NPCLocationUpsertWithWhereUniqueWithoutNpcInput = {
    where: NPCLocationWhereUniqueInput
    update: XOR<NPCLocationUpdateWithoutNpcInput, NPCLocationUncheckedUpdateWithoutNpcInput>
    create: XOR<NPCLocationCreateWithoutNpcInput, NPCLocationUncheckedCreateWithoutNpcInput>
  }

  export type NPCLocationUpdateWithWhereUniqueWithoutNpcInput = {
    where: NPCLocationWhereUniqueInput
    data: XOR<NPCLocationUpdateWithoutNpcInput, NPCLocationUncheckedUpdateWithoutNpcInput>
  }

  export type NPCLocationUpdateManyWithWhereWithoutNpcInput = {
    where: NPCLocationScalarWhereInput
    data: XOR<NPCLocationUpdateManyMutationInput, NPCLocationUncheckedUpdateManyWithoutNpcInput>
  }

  export type NPCLocationScalarWhereInput = {
    AND?: NPCLocationScalarWhereInput | NPCLocationScalarWhereInput[]
    OR?: NPCLocationScalarWhereInput[]
    NOT?: NPCLocationScalarWhereInput | NPCLocationScalarWhereInput[]
    npcId?: StringFilter<"NPCLocation"> | string
    locationId?: StringFilter<"NPCLocation"> | string
    isPrimary?: BoolFilter<"NPCLocation"> | boolean
  }

  export type QuestUpsertWithWhereUniqueWithoutQuestGiverInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutQuestGiverInput, QuestUncheckedUpdateWithoutQuestGiverInput>
    create: XOR<QuestCreateWithoutQuestGiverInput, QuestUncheckedCreateWithoutQuestGiverInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutQuestGiverInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutQuestGiverInput, QuestUncheckedUpdateWithoutQuestGiverInput>
  }

  export type QuestUpdateManyWithWhereWithoutQuestGiverInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutQuestGiverInput>
  }

  export type QuestNPCUpsertWithWhereUniqueWithoutNpcInput = {
    where: QuestNPCWhereUniqueInput
    update: XOR<QuestNPCUpdateWithoutNpcInput, QuestNPCUncheckedUpdateWithoutNpcInput>
    create: XOR<QuestNPCCreateWithoutNpcInput, QuestNPCUncheckedCreateWithoutNpcInput>
  }

  export type QuestNPCUpdateWithWhereUniqueWithoutNpcInput = {
    where: QuestNPCWhereUniqueInput
    data: XOR<QuestNPCUpdateWithoutNpcInput, QuestNPCUncheckedUpdateWithoutNpcInput>
  }

  export type QuestNPCUpdateManyWithWhereWithoutNpcInput = {
    where: QuestNPCScalarWhereInput
    data: XOR<QuestNPCUpdateManyMutationInput, QuestNPCUncheckedUpdateManyWithoutNpcInput>
  }

  export type QuestNPCScalarWhereInput = {
    AND?: QuestNPCScalarWhereInput | QuestNPCScalarWhereInput[]
    OR?: QuestNPCScalarWhereInput[]
    NOT?: QuestNPCScalarWhereInput | QuestNPCScalarWhereInput[]
    questId?: StringFilter<"QuestNPC"> | string
    npcId?: StringFilter<"QuestNPC"> | string
    role?: StringNullableFilter<"QuestNPC"> | string | null
  }

  export type InteractionUpsertWithWhereUniqueWithoutNpcInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutNpcInput, InteractionUncheckedUpdateWithoutNpcInput>
    create: XOR<InteractionCreateWithoutNpcInput, InteractionUncheckedCreateWithoutNpcInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutNpcInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutNpcInput, InteractionUncheckedUpdateWithoutNpcInput>
  }

  export type InteractionUpdateManyWithWhereWithoutNpcInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutNpcInput>
  }

  export type ItemNPCUpsertWithWhereUniqueWithoutNpcInput = {
    where: ItemNPCWhereUniqueInput
    update: XOR<ItemNPCUpdateWithoutNpcInput, ItemNPCUncheckedUpdateWithoutNpcInput>
    create: XOR<ItemNPCCreateWithoutNpcInput, ItemNPCUncheckedCreateWithoutNpcInput>
  }

  export type ItemNPCUpdateWithWhereUniqueWithoutNpcInput = {
    where: ItemNPCWhereUniqueInput
    data: XOR<ItemNPCUpdateWithoutNpcInput, ItemNPCUncheckedUpdateWithoutNpcInput>
  }

  export type ItemNPCUpdateManyWithWhereWithoutNpcInput = {
    where: ItemNPCScalarWhereInput
    data: XOR<ItemNPCUpdateManyMutationInput, ItemNPCUncheckedUpdateManyWithoutNpcInput>
  }

  export type ItemNPCScalarWhereInput = {
    AND?: ItemNPCScalarWhereInput | ItemNPCScalarWhereInput[]
    OR?: ItemNPCScalarWhereInput[]
    NOT?: ItemNPCScalarWhereInput | ItemNPCScalarWhereInput[]
    itemId?: StringFilter<"ItemNPC"> | string
    npcId?: StringFilter<"ItemNPC"> | string
  }

  export type CampaignCreateWithoutLocationsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutLocationsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLocationsInput, CampaignUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutChildLocationsInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutChildLocationsInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutChildLocationsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutChildLocationsInput, LocationUncheckedCreateWithoutChildLocationsInput>
  }

  export type LocationCreateWithoutParentLocationInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutParentLocationInput = {
    id?: string
    campaignId: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutParentLocationInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutParentLocationInput, LocationUncheckedCreateWithoutParentLocationInput>
  }

  export type LocationCreateManyParentLocationInputEnvelope = {
    data: LocationCreateManyParentLocationInput | LocationCreateManyParentLocationInput[]
  }

  export type MapCreateWithoutLocationInput = {
    id?: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMapsInput
    annotations?: MapAnnotationCreateNestedManyWithoutMapInput
    encounters?: EncounterCreateNestedManyWithoutMapInput
  }

  export type MapUncheckedCreateWithoutLocationInput = {
    id?: string
    campaignId: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    annotations?: MapAnnotationUncheckedCreateNestedManyWithoutMapInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutMapInput
  }

  export type MapCreateOrConnectWithoutLocationInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutLocationInput, MapUncheckedCreateWithoutLocationInput>
  }

  export type MapCreateManyLocationInputEnvelope = {
    data: MapCreateManyLocationInput | MapCreateManyLocationInput[]
  }

  export type EncounterCreateWithoutLocationInput = {
    id?: string
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    map?: MapCreateNestedOneWithoutEncountersInput
    participants?: EncounterParticipantCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutLocationInput = {
    id?: string
    campaignId: string
    mapId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    participants?: EncounterParticipantUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutLocationInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput>
  }

  export type EncounterCreateManyLocationInputEnvelope = {
    data: EncounterCreateManyLocationInput | EncounterCreateManyLocationInput[]
  }

  export type NPCLocationCreateWithoutLocationInput = {
    isPrimary?: boolean
    npc: NPCCreateNestedOneWithoutLocationsInput
  }

  export type NPCLocationUncheckedCreateWithoutLocationInput = {
    npcId: string
    isPrimary?: boolean
  }

  export type NPCLocationCreateOrConnectWithoutLocationInput = {
    where: NPCLocationWhereUniqueInput
    create: XOR<NPCLocationCreateWithoutLocationInput, NPCLocationUncheckedCreateWithoutLocationInput>
  }

  export type NPCLocationCreateManyLocationInputEnvelope = {
    data: NPCLocationCreateManyLocationInput | NPCLocationCreateManyLocationInput[]
  }

  export type QuestLocationCreateWithoutLocationInput = {
    quest: QuestCreateNestedOneWithoutLocationsInput
  }

  export type QuestLocationUncheckedCreateWithoutLocationInput = {
    questId: string
  }

  export type QuestLocationCreateOrConnectWithoutLocationInput = {
    where: QuestLocationWhereUniqueInput
    create: XOR<QuestLocationCreateWithoutLocationInput, QuestLocationUncheckedCreateWithoutLocationInput>
  }

  export type QuestLocationCreateManyLocationInputEnvelope = {
    data: QuestLocationCreateManyLocationInput | QuestLocationCreateManyLocationInput[]
  }

  export type ItemLocationCreateWithoutLocationInput = {
    isHidden?: boolean
    notes?: string | null
    item: ItemCreateNestedOneWithoutLocationsInput
  }

  export type ItemLocationUncheckedCreateWithoutLocationInput = {
    itemId: string
    isHidden?: boolean
    notes?: string | null
  }

  export type ItemLocationCreateOrConnectWithoutLocationInput = {
    where: ItemLocationWhereUniqueInput
    create: XOR<ItemLocationCreateWithoutLocationInput, ItemLocationUncheckedCreateWithoutLocationInput>
  }

  export type ItemLocationCreateManyLocationInputEnvelope = {
    data: ItemLocationCreateManyLocationInput | ItemLocationCreateManyLocationInput[]
  }

  export type CampaignUpsertWithoutLocationsInput = {
    update: XOR<CampaignUpdateWithoutLocationsInput, CampaignUncheckedUpdateWithoutLocationsInput>
    create: XOR<CampaignCreateWithoutLocationsInput, CampaignUncheckedCreateWithoutLocationsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLocationsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLocationsInput, CampaignUncheckedUpdateWithoutLocationsInput>
  }

  export type CampaignUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LocationUpsertWithoutChildLocationsInput = {
    update: XOR<LocationUpdateWithoutChildLocationsInput, LocationUncheckedUpdateWithoutChildLocationsInput>
    create: XOR<LocationCreateWithoutChildLocationsInput, LocationUncheckedCreateWithoutChildLocationsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutChildLocationsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutChildLocationsInput, LocationUncheckedUpdateWithoutChildLocationsInput>
  }

  export type LocationUpdateWithoutChildLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutChildLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUpsertWithWhereUniqueWithoutParentLocationInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutParentLocationInput, LocationUncheckedUpdateWithoutParentLocationInput>
    create: XOR<LocationCreateWithoutParentLocationInput, LocationUncheckedCreateWithoutParentLocationInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutParentLocationInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutParentLocationInput, LocationUncheckedUpdateWithoutParentLocationInput>
  }

  export type LocationUpdateManyWithWhereWithoutParentLocationInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutParentLocationInput>
  }

  export type MapUpsertWithWhereUniqueWithoutLocationInput = {
    where: MapWhereUniqueInput
    update: XOR<MapUpdateWithoutLocationInput, MapUncheckedUpdateWithoutLocationInput>
    create: XOR<MapCreateWithoutLocationInput, MapUncheckedCreateWithoutLocationInput>
  }

  export type MapUpdateWithWhereUniqueWithoutLocationInput = {
    where: MapWhereUniqueInput
    data: XOR<MapUpdateWithoutLocationInput, MapUncheckedUpdateWithoutLocationInput>
  }

  export type MapUpdateManyWithWhereWithoutLocationInput = {
    where: MapScalarWhereInput
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyWithoutLocationInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutLocationInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutLocationInput, EncounterUncheckedUpdateWithoutLocationInput>
    create: XOR<EncounterCreateWithoutLocationInput, EncounterUncheckedCreateWithoutLocationInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutLocationInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutLocationInput, EncounterUncheckedUpdateWithoutLocationInput>
  }

  export type EncounterUpdateManyWithWhereWithoutLocationInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutLocationInput>
  }

  export type NPCLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: NPCLocationWhereUniqueInput
    update: XOR<NPCLocationUpdateWithoutLocationInput, NPCLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<NPCLocationCreateWithoutLocationInput, NPCLocationUncheckedCreateWithoutLocationInput>
  }

  export type NPCLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: NPCLocationWhereUniqueInput
    data: XOR<NPCLocationUpdateWithoutLocationInput, NPCLocationUncheckedUpdateWithoutLocationInput>
  }

  export type NPCLocationUpdateManyWithWhereWithoutLocationInput = {
    where: NPCLocationScalarWhereInput
    data: XOR<NPCLocationUpdateManyMutationInput, NPCLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type QuestLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: QuestLocationWhereUniqueInput
    update: XOR<QuestLocationUpdateWithoutLocationInput, QuestLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<QuestLocationCreateWithoutLocationInput, QuestLocationUncheckedCreateWithoutLocationInput>
  }

  export type QuestLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: QuestLocationWhereUniqueInput
    data: XOR<QuestLocationUpdateWithoutLocationInput, QuestLocationUncheckedUpdateWithoutLocationInput>
  }

  export type QuestLocationUpdateManyWithWhereWithoutLocationInput = {
    where: QuestLocationScalarWhereInput
    data: XOR<QuestLocationUpdateManyMutationInput, QuestLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type QuestLocationScalarWhereInput = {
    AND?: QuestLocationScalarWhereInput | QuestLocationScalarWhereInput[]
    OR?: QuestLocationScalarWhereInput[]
    NOT?: QuestLocationScalarWhereInput | QuestLocationScalarWhereInput[]
    questId?: StringFilter<"QuestLocation"> | string
    locationId?: StringFilter<"QuestLocation"> | string
  }

  export type ItemLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: ItemLocationWhereUniqueInput
    update: XOR<ItemLocationUpdateWithoutLocationInput, ItemLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<ItemLocationCreateWithoutLocationInput, ItemLocationUncheckedCreateWithoutLocationInput>
  }

  export type ItemLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: ItemLocationWhereUniqueInput
    data: XOR<ItemLocationUpdateWithoutLocationInput, ItemLocationUncheckedUpdateWithoutLocationInput>
  }

  export type ItemLocationUpdateManyWithWhereWithoutLocationInput = {
    where: ItemLocationScalarWhereInput
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type ItemLocationScalarWhereInput = {
    AND?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
    OR?: ItemLocationScalarWhereInput[]
    NOT?: ItemLocationScalarWhereInput | ItemLocationScalarWhereInput[]
    itemId?: StringFilter<"ItemLocation"> | string
    locationId?: StringFilter<"ItemLocation"> | string
    isHidden?: BoolFilter<"ItemLocation"> | boolean
    notes?: StringNullableFilter<"ItemLocation"> | string | null
  }

  export type CampaignCreateWithoutMapsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMapsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMapsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMapsInput, CampaignUncheckedCreateWithoutMapsInput>
  }

  export type LocationCreateWithoutMapsInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutMapsInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutMapsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutMapsInput, LocationUncheckedCreateWithoutMapsInput>
  }

  export type MapAnnotationCreateWithoutMapInput = {
    id?: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title?: string | null
    content?: string | null
    isHidden?: boolean
  }

  export type MapAnnotationUncheckedCreateWithoutMapInput = {
    id?: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title?: string | null
    content?: string | null
    isHidden?: boolean
  }

  export type MapAnnotationCreateOrConnectWithoutMapInput = {
    where: MapAnnotationWhereUniqueInput
    create: XOR<MapAnnotationCreateWithoutMapInput, MapAnnotationUncheckedCreateWithoutMapInput>
  }

  export type MapAnnotationCreateManyMapInputEnvelope = {
    data: MapAnnotationCreateManyMapInput | MapAnnotationCreateManyMapInput[]
  }

  export type EncounterCreateWithoutMapInput = {
    id?: string
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    location?: LocationCreateNestedOneWithoutEncountersInput
    participants?: EncounterParticipantCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutMapInput = {
    id?: string
    campaignId: string
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    participants?: EncounterParticipantUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutMapInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutMapInput, EncounterUncheckedCreateWithoutMapInput>
  }

  export type EncounterCreateManyMapInputEnvelope = {
    data: EncounterCreateManyMapInput | EncounterCreateManyMapInput[]
  }

  export type CampaignUpsertWithoutMapsInput = {
    update: XOR<CampaignUpdateWithoutMapsInput, CampaignUncheckedUpdateWithoutMapsInput>
    create: XOR<CampaignCreateWithoutMapsInput, CampaignUncheckedCreateWithoutMapsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMapsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMapsInput, CampaignUncheckedUpdateWithoutMapsInput>
  }

  export type CampaignUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type LocationUpsertWithoutMapsInput = {
    update: XOR<LocationUpdateWithoutMapsInput, LocationUncheckedUpdateWithoutMapsInput>
    create: XOR<LocationCreateWithoutMapsInput, LocationUncheckedCreateWithoutMapsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutMapsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutMapsInput, LocationUncheckedUpdateWithoutMapsInput>
  }

  export type LocationUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MapAnnotationUpsertWithWhereUniqueWithoutMapInput = {
    where: MapAnnotationWhereUniqueInput
    update: XOR<MapAnnotationUpdateWithoutMapInput, MapAnnotationUncheckedUpdateWithoutMapInput>
    create: XOR<MapAnnotationCreateWithoutMapInput, MapAnnotationUncheckedCreateWithoutMapInput>
  }

  export type MapAnnotationUpdateWithWhereUniqueWithoutMapInput = {
    where: MapAnnotationWhereUniqueInput
    data: XOR<MapAnnotationUpdateWithoutMapInput, MapAnnotationUncheckedUpdateWithoutMapInput>
  }

  export type MapAnnotationUpdateManyWithWhereWithoutMapInput = {
    where: MapAnnotationScalarWhereInput
    data: XOR<MapAnnotationUpdateManyMutationInput, MapAnnotationUncheckedUpdateManyWithoutMapInput>
  }

  export type MapAnnotationScalarWhereInput = {
    AND?: MapAnnotationScalarWhereInput | MapAnnotationScalarWhereInput[]
    OR?: MapAnnotationScalarWhereInput[]
    NOT?: MapAnnotationScalarWhereInput | MapAnnotationScalarWhereInput[]
    id?: StringFilter<"MapAnnotation"> | string
    mapId?: StringFilter<"MapAnnotation"> | string
    type?: EnumMapAnnotationTypeFilter<"MapAnnotation"> | $Enums.MapAnnotationType
    x?: FloatFilter<"MapAnnotation"> | number
    y?: FloatFilter<"MapAnnotation"> | number
    title?: StringNullableFilter<"MapAnnotation"> | string | null
    content?: StringNullableFilter<"MapAnnotation"> | string | null
    isHidden?: BoolFilter<"MapAnnotation"> | boolean
  }

  export type EncounterUpsertWithWhereUniqueWithoutMapInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutMapInput, EncounterUncheckedUpdateWithoutMapInput>
    create: XOR<EncounterCreateWithoutMapInput, EncounterUncheckedCreateWithoutMapInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutMapInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutMapInput, EncounterUncheckedUpdateWithoutMapInput>
  }

  export type EncounterUpdateManyWithWhereWithoutMapInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutMapInput>
  }

  export type MapCreateWithoutAnnotationsInput = {
    id?: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMapsInput
    location?: LocationCreateNestedOneWithoutMapsInput
    encounters?: EncounterCreateNestedManyWithoutMapInput
  }

  export type MapUncheckedCreateWithoutAnnotationsInput = {
    id?: string
    campaignId: string
    locationId?: string | null
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutMapInput
  }

  export type MapCreateOrConnectWithoutAnnotationsInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutAnnotationsInput, MapUncheckedCreateWithoutAnnotationsInput>
  }

  export type MapUpsertWithoutAnnotationsInput = {
    update: XOR<MapUpdateWithoutAnnotationsInput, MapUncheckedUpdateWithoutAnnotationsInput>
    create: XOR<MapCreateWithoutAnnotationsInput, MapUncheckedCreateWithoutAnnotationsInput>
    where?: MapWhereInput
  }

  export type MapUpdateToOneWithWhereWithoutAnnotationsInput = {
    where?: MapWhereInput
    data: XOR<MapUpdateWithoutAnnotationsInput, MapUncheckedUpdateWithoutAnnotationsInput>
  }

  export type MapUpdateWithoutAnnotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMapsNestedInput
    location?: LocationUpdateOneWithoutMapsNestedInput
    encounters?: EncounterUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateWithoutAnnotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutMapNestedInput
  }

  export type MonsterCampaignCreateWithoutMonsterInput = {
    campaign: CampaignCreateNestedOneWithoutMonsterCampaignsInput
  }

  export type MonsterCampaignUncheckedCreateWithoutMonsterInput = {
    campaignId: string
  }

  export type MonsterCampaignCreateOrConnectWithoutMonsterInput = {
    where: MonsterCampaignWhereUniqueInput
    create: XOR<MonsterCampaignCreateWithoutMonsterInput, MonsterCampaignUncheckedCreateWithoutMonsterInput>
  }

  export type MonsterCampaignCreateManyMonsterInputEnvelope = {
    data: MonsterCampaignCreateManyMonsterInput | MonsterCampaignCreateManyMonsterInput[]
  }

  export type EncounterParticipantCreateWithoutMonsterInput = {
    id?: string
    participantType: $Enums.ParticipantType
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
    encounter: EncounterCreateNestedOneWithoutParticipantsInput
    playerCharacter?: PlayerCharacterCreateNestedOneWithoutEncounterParticipantsInput
  }

  export type EncounterParticipantUncheckedCreateWithoutMonsterInput = {
    id?: string
    encounterId: string
    participantType: $Enums.ParticipantType
    playerCharacterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantCreateOrConnectWithoutMonsterInput = {
    where: EncounterParticipantWhereUniqueInput
    create: XOR<EncounterParticipantCreateWithoutMonsterInput, EncounterParticipantUncheckedCreateWithoutMonsterInput>
  }

  export type EncounterParticipantCreateManyMonsterInputEnvelope = {
    data: EncounterParticipantCreateManyMonsterInput | EncounterParticipantCreateManyMonsterInput[]
  }

  export type MonsterCampaignUpsertWithWhereUniqueWithoutMonsterInput = {
    where: MonsterCampaignWhereUniqueInput
    update: XOR<MonsterCampaignUpdateWithoutMonsterInput, MonsterCampaignUncheckedUpdateWithoutMonsterInput>
    create: XOR<MonsterCampaignCreateWithoutMonsterInput, MonsterCampaignUncheckedCreateWithoutMonsterInput>
  }

  export type MonsterCampaignUpdateWithWhereUniqueWithoutMonsterInput = {
    where: MonsterCampaignWhereUniqueInput
    data: XOR<MonsterCampaignUpdateWithoutMonsterInput, MonsterCampaignUncheckedUpdateWithoutMonsterInput>
  }

  export type MonsterCampaignUpdateManyWithWhereWithoutMonsterInput = {
    where: MonsterCampaignScalarWhereInput
    data: XOR<MonsterCampaignUpdateManyMutationInput, MonsterCampaignUncheckedUpdateManyWithoutMonsterInput>
  }

  export type EncounterParticipantUpsertWithWhereUniqueWithoutMonsterInput = {
    where: EncounterParticipantWhereUniqueInput
    update: XOR<EncounterParticipantUpdateWithoutMonsterInput, EncounterParticipantUncheckedUpdateWithoutMonsterInput>
    create: XOR<EncounterParticipantCreateWithoutMonsterInput, EncounterParticipantUncheckedCreateWithoutMonsterInput>
  }

  export type EncounterParticipantUpdateWithWhereUniqueWithoutMonsterInput = {
    where: EncounterParticipantWhereUniqueInput
    data: XOR<EncounterParticipantUpdateWithoutMonsterInput, EncounterParticipantUncheckedUpdateWithoutMonsterInput>
  }

  export type EncounterParticipantUpdateManyWithWhereWithoutMonsterInput = {
    where: EncounterParticipantScalarWhereInput
    data: XOR<EncounterParticipantUpdateManyMutationInput, EncounterParticipantUncheckedUpdateManyWithoutMonsterInput>
  }

  export type EncounterParticipantScalarWhereInput = {
    AND?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
    OR?: EncounterParticipantScalarWhereInput[]
    NOT?: EncounterParticipantScalarWhereInput | EncounterParticipantScalarWhereInput[]
    id?: StringFilter<"EncounterParticipant"> | string
    encounterId?: StringFilter<"EncounterParticipant"> | string
    participantType?: EnumParticipantTypeFilter<"EncounterParticipant"> | $Enums.ParticipantType
    monsterId?: StringNullableFilter<"EncounterParticipant"> | string | null
    playerCharacterId?: StringNullableFilter<"EncounterParticipant"> | string | null
    customName?: StringNullableFilter<"EncounterParticipant"> | string | null
    initiative?: IntNullableFilter<"EncounterParticipant"> | number | null
    hpCurrent?: IntFilter<"EncounterParticipant"> | number
    hpMax?: IntFilter<"EncounterParticipant"> | number
    ac?: IntFilter<"EncounterParticipant"> | number
    conditions?: JsonNullableFilter<"EncounterParticipant">
    positionX?: FloatNullableFilter<"EncounterParticipant"> | number | null
    positionY?: FloatNullableFilter<"EncounterParticipant"> | number | null
    isVisible?: BoolFilter<"EncounterParticipant"> | boolean
    dmNotes?: StringNullableFilter<"EncounterParticipant"> | string | null
  }

  export type CampaignCreateWithoutEncountersInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEncountersInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEncountersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
  }

  export type MapCreateWithoutEncountersInput = {
    id?: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMapsInput
    location?: LocationCreateNestedOneWithoutMapsInput
    annotations?: MapAnnotationCreateNestedManyWithoutMapInput
  }

  export type MapUncheckedCreateWithoutEncountersInput = {
    id?: string
    campaignId: string
    locationId?: string | null
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    annotations?: MapAnnotationUncheckedCreateNestedManyWithoutMapInput
  }

  export type MapCreateOrConnectWithoutEncountersInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutEncountersInput, MapUncheckedCreateWithoutEncountersInput>
  }

  export type LocationCreateWithoutEncountersInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutEncountersInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutEncountersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEncountersInput, LocationUncheckedCreateWithoutEncountersInput>
  }

  export type EncounterParticipantCreateWithoutEncounterInput = {
    id?: string
    participantType: $Enums.ParticipantType
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
    monster?: MonsterCreateNestedOneWithoutEncounterParticipantsInput
    playerCharacter?: PlayerCharacterCreateNestedOneWithoutEncounterParticipantsInput
  }

  export type EncounterParticipantUncheckedCreateWithoutEncounterInput = {
    id?: string
    participantType: $Enums.ParticipantType
    monsterId?: string | null
    playerCharacterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantCreateOrConnectWithoutEncounterInput = {
    where: EncounterParticipantWhereUniqueInput
    create: XOR<EncounterParticipantCreateWithoutEncounterInput, EncounterParticipantUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterParticipantCreateManyEncounterInputEnvelope = {
    data: EncounterParticipantCreateManyEncounterInput | EncounterParticipantCreateManyEncounterInput[]
  }

  export type CampaignUpsertWithoutEncountersInput = {
    update: XOR<CampaignUpdateWithoutEncountersInput, CampaignUncheckedUpdateWithoutEncountersInput>
    create: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEncountersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEncountersInput, CampaignUncheckedUpdateWithoutEncountersInput>
  }

  export type CampaignUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type MapUpsertWithoutEncountersInput = {
    update: XOR<MapUpdateWithoutEncountersInput, MapUncheckedUpdateWithoutEncountersInput>
    create: XOR<MapCreateWithoutEncountersInput, MapUncheckedCreateWithoutEncountersInput>
    where?: MapWhereInput
  }

  export type MapUpdateToOneWithWhereWithoutEncountersInput = {
    where?: MapWhereInput
    data: XOR<MapUpdateWithoutEncountersInput, MapUncheckedUpdateWithoutEncountersInput>
  }

  export type MapUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMapsNestedInput
    location?: LocationUpdateOneWithoutMapsNestedInput
    annotations?: MapAnnotationUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotations?: MapAnnotationUncheckedUpdateManyWithoutMapNestedInput
  }

  export type LocationUpsertWithoutEncountersInput = {
    update: XOR<LocationUpdateWithoutEncountersInput, LocationUncheckedUpdateWithoutEncountersInput>
    create: XOR<LocationCreateWithoutEncountersInput, LocationUncheckedCreateWithoutEncountersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutEncountersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutEncountersInput, LocationUncheckedUpdateWithoutEncountersInput>
  }

  export type LocationUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EncounterParticipantUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterParticipantWhereUniqueInput
    update: XOR<EncounterParticipantUpdateWithoutEncounterInput, EncounterParticipantUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterParticipantCreateWithoutEncounterInput, EncounterParticipantUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterParticipantUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterParticipantWhereUniqueInput
    data: XOR<EncounterParticipantUpdateWithoutEncounterInput, EncounterParticipantUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterParticipantUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterParticipantScalarWhereInput
    data: XOR<EncounterParticipantUpdateManyMutationInput, EncounterParticipantUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterCreateWithoutParticipantsInput = {
    id?: string
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    map?: MapCreateNestedOneWithoutEncountersInput
    location?: LocationCreateNestedOneWithoutEncountersInput
  }

  export type EncounterUncheckedCreateWithoutParticipantsInput = {
    id?: string
    campaignId: string
    mapId?: string | null
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type EncounterCreateOrConnectWithoutParticipantsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutParticipantsInput, EncounterUncheckedCreateWithoutParticipantsInput>
  }

  export type MonsterCreateWithoutEncounterParticipantsInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: MonsterCampaignCreateNestedManyWithoutMonsterInput
  }

  export type MonsterUncheckedCreateWithoutEncounterParticipantsInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutMonsterInput
  }

  export type MonsterCreateOrConnectWithoutEncounterParticipantsInput = {
    where: MonsterWhereUniqueInput
    create: XOR<MonsterCreateWithoutEncounterParticipantsInput, MonsterUncheckedCreateWithoutEncounterParticipantsInput>
  }

  export type PlayerCharacterCreateWithoutEncounterParticipantsInput = {
    id?: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutPlayerCharactersInput
  }

  export type PlayerCharacterUncheckedCreateWithoutEncounterParticipantsInput = {
    id?: string
    campaignId: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCharacterCreateOrConnectWithoutEncounterParticipantsInput = {
    where: PlayerCharacterWhereUniqueInput
    create: XOR<PlayerCharacterCreateWithoutEncounterParticipantsInput, PlayerCharacterUncheckedCreateWithoutEncounterParticipantsInput>
  }

  export type EncounterUpsertWithoutParticipantsInput = {
    update: XOR<EncounterUpdateWithoutParticipantsInput, EncounterUncheckedUpdateWithoutParticipantsInput>
    create: XOR<EncounterCreateWithoutParticipantsInput, EncounterUncheckedCreateWithoutParticipantsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutParticipantsInput, EncounterUncheckedUpdateWithoutParticipantsInput>
  }

  export type EncounterUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    map?: MapUpdateOneWithoutEncountersNestedInput
    location?: LocationUpdateOneWithoutEncountersNestedInput
  }

  export type EncounterUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MonsterUpsertWithoutEncounterParticipantsInput = {
    update: XOR<MonsterUpdateWithoutEncounterParticipantsInput, MonsterUncheckedUpdateWithoutEncounterParticipantsInput>
    create: XOR<MonsterCreateWithoutEncounterParticipantsInput, MonsterUncheckedCreateWithoutEncounterParticipantsInput>
    where?: MonsterWhereInput
  }

  export type MonsterUpdateToOneWithWhereWithoutEncounterParticipantsInput = {
    where?: MonsterWhereInput
    data: XOR<MonsterUpdateWithoutEncounterParticipantsInput, MonsterUncheckedUpdateWithoutEncounterParticipantsInput>
  }

  export type MonsterUpdateWithoutEncounterParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: MonsterCampaignUpdateManyWithoutMonsterNestedInput
  }

  export type MonsterUncheckedUpdateWithoutEncounterParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: MonsterCampaignUncheckedUpdateManyWithoutMonsterNestedInput
  }

  export type PlayerCharacterUpsertWithoutEncounterParticipantsInput = {
    update: XOR<PlayerCharacterUpdateWithoutEncounterParticipantsInput, PlayerCharacterUncheckedUpdateWithoutEncounterParticipantsInput>
    create: XOR<PlayerCharacterCreateWithoutEncounterParticipantsInput, PlayerCharacterUncheckedCreateWithoutEncounterParticipantsInput>
    where?: PlayerCharacterWhereInput
  }

  export type PlayerCharacterUpdateToOneWithWhereWithoutEncounterParticipantsInput = {
    where?: PlayerCharacterWhereInput
    data: XOR<PlayerCharacterUpdateWithoutEncounterParticipantsInput, PlayerCharacterUncheckedUpdateWithoutEncounterParticipantsInput>
  }

  export type PlayerCharacterUpdateWithoutEncounterParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutPlayerCharactersNestedInput
  }

  export type PlayerCharacterUncheckedUpdateWithoutEncounterParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateWithoutPlayerCharactersInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutPlayerCharactersInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutPlayerCharactersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutPlayerCharactersInput, CampaignUncheckedCreateWithoutPlayerCharactersInput>
  }

  export type EncounterParticipantCreateWithoutPlayerCharacterInput = {
    id?: string
    participantType: $Enums.ParticipantType
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
    encounter: EncounterCreateNestedOneWithoutParticipantsInput
    monster?: MonsterCreateNestedOneWithoutEncounterParticipantsInput
  }

  export type EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput = {
    id?: string
    encounterId: string
    participantType: $Enums.ParticipantType
    monsterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantCreateOrConnectWithoutPlayerCharacterInput = {
    where: EncounterParticipantWhereUniqueInput
    create: XOR<EncounterParticipantCreateWithoutPlayerCharacterInput, EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput>
  }

  export type EncounterParticipantCreateManyPlayerCharacterInputEnvelope = {
    data: EncounterParticipantCreateManyPlayerCharacterInput | EncounterParticipantCreateManyPlayerCharacterInput[]
  }

  export type CampaignUpsertWithoutPlayerCharactersInput = {
    update: XOR<CampaignUpdateWithoutPlayerCharactersInput, CampaignUncheckedUpdateWithoutPlayerCharactersInput>
    create: XOR<CampaignCreateWithoutPlayerCharactersInput, CampaignUncheckedCreateWithoutPlayerCharactersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutPlayerCharactersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutPlayerCharactersInput, CampaignUncheckedUpdateWithoutPlayerCharactersInput>
  }

  export type CampaignUpdateWithoutPlayerCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutPlayerCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EncounterParticipantUpsertWithWhereUniqueWithoutPlayerCharacterInput = {
    where: EncounterParticipantWhereUniqueInput
    update: XOR<EncounterParticipantUpdateWithoutPlayerCharacterInput, EncounterParticipantUncheckedUpdateWithoutPlayerCharacterInput>
    create: XOR<EncounterParticipantCreateWithoutPlayerCharacterInput, EncounterParticipantUncheckedCreateWithoutPlayerCharacterInput>
  }

  export type EncounterParticipantUpdateWithWhereUniqueWithoutPlayerCharacterInput = {
    where: EncounterParticipantWhereUniqueInput
    data: XOR<EncounterParticipantUpdateWithoutPlayerCharacterInput, EncounterParticipantUncheckedUpdateWithoutPlayerCharacterInput>
  }

  export type EncounterParticipantUpdateManyWithWhereWithoutPlayerCharacterInput = {
    where: EncounterParticipantScalarWhereInput
    data: XOR<EncounterParticipantUpdateManyMutationInput, EncounterParticipantUncheckedUpdateManyWithoutPlayerCharacterInput>
  }

  export type CampaignCreateWithoutQuestsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutQuestsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutQuestsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutQuestsInput, CampaignUncheckedCreateWithoutQuestsInput>
  }

  export type QuestCreateWithoutSubQuestsInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutSubQuestsInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutSubQuestsInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutSubQuestsInput, QuestUncheckedCreateWithoutSubQuestsInput>
  }

  export type QuestCreateWithoutParentQuestInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutParentQuestInput = {
    id?: string
    campaignId: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutParentQuestInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutParentQuestInput, QuestUncheckedCreateWithoutParentQuestInput>
  }

  export type QuestCreateManyParentQuestInputEnvelope = {
    data: QuestCreateManyParentQuestInput | QuestCreateManyParentQuestInput[]
  }

  export type NPCCreateWithoutQuestsGivenInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutNpcsInput
    locations?: NPCLocationCreateNestedManyWithoutNpcInput
    questsInvolved?: QuestNPCCreateNestedManyWithoutNpcInput
    interactions?: InteractionCreateNestedManyWithoutNpcInput
    items?: ItemNPCCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutQuestsGivenInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationUncheckedCreateNestedManyWithoutNpcInput
    questsInvolved?: QuestNPCUncheckedCreateNestedManyWithoutNpcInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutNpcInput
    items?: ItemNPCUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutQuestsGivenInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutQuestsGivenInput, NPCUncheckedCreateWithoutQuestsGivenInput>
  }

  export type QuestNPCCreateWithoutQuestInput = {
    role?: string | null
    npc: NPCCreateNestedOneWithoutQuestsInvolvedInput
  }

  export type QuestNPCUncheckedCreateWithoutQuestInput = {
    npcId: string
    role?: string | null
  }

  export type QuestNPCCreateOrConnectWithoutQuestInput = {
    where: QuestNPCWhereUniqueInput
    create: XOR<QuestNPCCreateWithoutQuestInput, QuestNPCUncheckedCreateWithoutQuestInput>
  }

  export type QuestNPCCreateManyQuestInputEnvelope = {
    data: QuestNPCCreateManyQuestInput | QuestNPCCreateManyQuestInput[]
  }

  export type QuestLocationCreateWithoutQuestInput = {
    location: LocationCreateNestedOneWithoutQuestsInput
  }

  export type QuestLocationUncheckedCreateWithoutQuestInput = {
    locationId: string
  }

  export type QuestLocationCreateOrConnectWithoutQuestInput = {
    where: QuestLocationWhereUniqueInput
    create: XOR<QuestLocationCreateWithoutQuestInput, QuestLocationUncheckedCreateWithoutQuestInput>
  }

  export type QuestLocationCreateManyQuestInputEnvelope = {
    data: QuestLocationCreateManyQuestInput | QuestLocationCreateManyQuestInput[]
  }

  export type ChronicleQuestCreateWithoutQuestInput = {
    statusChange: string
    chronicle: ChronicleCreateNestedOneWithoutQuestsInput
  }

  export type ChronicleQuestUncheckedCreateWithoutQuestInput = {
    chronicleId: string
    statusChange: string
  }

  export type ChronicleQuestCreateOrConnectWithoutQuestInput = {
    where: ChronicleQuestWhereUniqueInput
    create: XOR<ChronicleQuestCreateWithoutQuestInput, ChronicleQuestUncheckedCreateWithoutQuestInput>
  }

  export type ChronicleQuestCreateManyQuestInputEnvelope = {
    data: ChronicleQuestCreateManyQuestInput | ChronicleQuestCreateManyQuestInput[]
  }

  export type CampaignUpsertWithoutQuestsInput = {
    update: XOR<CampaignUpdateWithoutQuestsInput, CampaignUncheckedUpdateWithoutQuestsInput>
    create: XOR<CampaignCreateWithoutQuestsInput, CampaignUncheckedCreateWithoutQuestsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutQuestsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutQuestsInput, CampaignUncheckedUpdateWithoutQuestsInput>
  }

  export type CampaignUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type QuestUpsertWithoutSubQuestsInput = {
    update: XOR<QuestUpdateWithoutSubQuestsInput, QuestUncheckedUpdateWithoutSubQuestsInput>
    create: XOR<QuestCreateWithoutSubQuestsInput, QuestUncheckedCreateWithoutSubQuestsInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutSubQuestsInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutSubQuestsInput, QuestUncheckedUpdateWithoutSubQuestsInput>
  }

  export type QuestUpdateWithoutSubQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutSubQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestUpsertWithWhereUniqueWithoutParentQuestInput = {
    where: QuestWhereUniqueInput
    update: XOR<QuestUpdateWithoutParentQuestInput, QuestUncheckedUpdateWithoutParentQuestInput>
    create: XOR<QuestCreateWithoutParentQuestInput, QuestUncheckedCreateWithoutParentQuestInput>
  }

  export type QuestUpdateWithWhereUniqueWithoutParentQuestInput = {
    where: QuestWhereUniqueInput
    data: XOR<QuestUpdateWithoutParentQuestInput, QuestUncheckedUpdateWithoutParentQuestInput>
  }

  export type QuestUpdateManyWithWhereWithoutParentQuestInput = {
    where: QuestScalarWhereInput
    data: XOR<QuestUpdateManyMutationInput, QuestUncheckedUpdateManyWithoutParentQuestInput>
  }

  export type NPCUpsertWithoutQuestsGivenInput = {
    update: XOR<NPCUpdateWithoutQuestsGivenInput, NPCUncheckedUpdateWithoutQuestsGivenInput>
    create: XOR<NPCCreateWithoutQuestsGivenInput, NPCUncheckedCreateWithoutQuestsGivenInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutQuestsGivenInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutQuestsGivenInput, NPCUncheckedUpdateWithoutQuestsGivenInput>
  }

  export type NPCUpdateWithoutQuestsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutNpcsNestedInput
    locations?: NPCLocationUpdateManyWithoutNpcNestedInput
    questsInvolved?: QuestNPCUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutQuestsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUncheckedUpdateManyWithoutNpcNestedInput
    questsInvolved?: QuestNPCUncheckedUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type QuestNPCUpsertWithWhereUniqueWithoutQuestInput = {
    where: QuestNPCWhereUniqueInput
    update: XOR<QuestNPCUpdateWithoutQuestInput, QuestNPCUncheckedUpdateWithoutQuestInput>
    create: XOR<QuestNPCCreateWithoutQuestInput, QuestNPCUncheckedCreateWithoutQuestInput>
  }

  export type QuestNPCUpdateWithWhereUniqueWithoutQuestInput = {
    where: QuestNPCWhereUniqueInput
    data: XOR<QuestNPCUpdateWithoutQuestInput, QuestNPCUncheckedUpdateWithoutQuestInput>
  }

  export type QuestNPCUpdateManyWithWhereWithoutQuestInput = {
    where: QuestNPCScalarWhereInput
    data: XOR<QuestNPCUpdateManyMutationInput, QuestNPCUncheckedUpdateManyWithoutQuestInput>
  }

  export type QuestLocationUpsertWithWhereUniqueWithoutQuestInput = {
    where: QuestLocationWhereUniqueInput
    update: XOR<QuestLocationUpdateWithoutQuestInput, QuestLocationUncheckedUpdateWithoutQuestInput>
    create: XOR<QuestLocationCreateWithoutQuestInput, QuestLocationUncheckedCreateWithoutQuestInput>
  }

  export type QuestLocationUpdateWithWhereUniqueWithoutQuestInput = {
    where: QuestLocationWhereUniqueInput
    data: XOR<QuestLocationUpdateWithoutQuestInput, QuestLocationUncheckedUpdateWithoutQuestInput>
  }

  export type QuestLocationUpdateManyWithWhereWithoutQuestInput = {
    where: QuestLocationScalarWhereInput
    data: XOR<QuestLocationUpdateManyMutationInput, QuestLocationUncheckedUpdateManyWithoutQuestInput>
  }

  export type ChronicleQuestUpsertWithWhereUniqueWithoutQuestInput = {
    where: ChronicleQuestWhereUniqueInput
    update: XOR<ChronicleQuestUpdateWithoutQuestInput, ChronicleQuestUncheckedUpdateWithoutQuestInput>
    create: XOR<ChronicleQuestCreateWithoutQuestInput, ChronicleQuestUncheckedCreateWithoutQuestInput>
  }

  export type ChronicleQuestUpdateWithWhereUniqueWithoutQuestInput = {
    where: ChronicleQuestWhereUniqueInput
    data: XOR<ChronicleQuestUpdateWithoutQuestInput, ChronicleQuestUncheckedUpdateWithoutQuestInput>
  }

  export type ChronicleQuestUpdateManyWithWhereWithoutQuestInput = {
    where: ChronicleQuestScalarWhereInput
    data: XOR<ChronicleQuestUpdateManyMutationInput, ChronicleQuestUncheckedUpdateManyWithoutQuestInput>
  }

  export type ChronicleQuestScalarWhereInput = {
    AND?: ChronicleQuestScalarWhereInput | ChronicleQuestScalarWhereInput[]
    OR?: ChronicleQuestScalarWhereInput[]
    NOT?: ChronicleQuestScalarWhereInput | ChronicleQuestScalarWhereInput[]
    chronicleId?: StringFilter<"ChronicleQuest"> | string
    questId?: StringFilter<"ChronicleQuest"> | string
    statusChange?: StringFilter<"ChronicleQuest"> | string
  }

  export type ItemCampaignCreateWithoutItemInput = {
    campaign: CampaignCreateNestedOneWithoutItemCampaignsInput
  }

  export type ItemCampaignUncheckedCreateWithoutItemInput = {
    campaignId: string
  }

  export type ItemCampaignCreateOrConnectWithoutItemInput = {
    where: ItemCampaignWhereUniqueInput
    create: XOR<ItemCampaignCreateWithoutItemInput, ItemCampaignUncheckedCreateWithoutItemInput>
  }

  export type ItemCampaignCreateManyItemInputEnvelope = {
    data: ItemCampaignCreateManyItemInput | ItemCampaignCreateManyItemInput[]
  }

  export type ItemLocationCreateWithoutItemInput = {
    isHidden?: boolean
    notes?: string | null
    location: LocationCreateNestedOneWithoutItemsInput
  }

  export type ItemLocationUncheckedCreateWithoutItemInput = {
    locationId: string
    isHidden?: boolean
    notes?: string | null
  }

  export type ItemLocationCreateOrConnectWithoutItemInput = {
    where: ItemLocationWhereUniqueInput
    create: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput>
  }

  export type ItemLocationCreateManyItemInputEnvelope = {
    data: ItemLocationCreateManyItemInput | ItemLocationCreateManyItemInput[]
  }

  export type ItemNPCCreateWithoutItemInput = {
    npc: NPCCreateNestedOneWithoutItemsInput
  }

  export type ItemNPCUncheckedCreateWithoutItemInput = {
    npcId: string
  }

  export type ItemNPCCreateOrConnectWithoutItemInput = {
    where: ItemNPCWhereUniqueInput
    create: XOR<ItemNPCCreateWithoutItemInput, ItemNPCUncheckedCreateWithoutItemInput>
  }

  export type ItemNPCCreateManyItemInputEnvelope = {
    data: ItemNPCCreateManyItemInput | ItemNPCCreateManyItemInput[]
  }

  export type InteractionItemCreateWithoutItemInput = {
    transactionType: $Enums.TransactionType
    interaction: InteractionCreateNestedOneWithoutItemsInput
  }

  export type InteractionItemUncheckedCreateWithoutItemInput = {
    interactionId: string
    transactionType: $Enums.TransactionType
  }

  export type InteractionItemCreateOrConnectWithoutItemInput = {
    where: InteractionItemWhereUniqueInput
    create: XOR<InteractionItemCreateWithoutItemInput, InteractionItemUncheckedCreateWithoutItemInput>
  }

  export type InteractionItemCreateManyItemInputEnvelope = {
    data: InteractionItemCreateManyItemInput | InteractionItemCreateManyItemInput[]
  }

  export type ItemCampaignUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemCampaignWhereUniqueInput
    update: XOR<ItemCampaignUpdateWithoutItemInput, ItemCampaignUncheckedUpdateWithoutItemInput>
    create: XOR<ItemCampaignCreateWithoutItemInput, ItemCampaignUncheckedCreateWithoutItemInput>
  }

  export type ItemCampaignUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemCampaignWhereUniqueInput
    data: XOR<ItemCampaignUpdateWithoutItemInput, ItemCampaignUncheckedUpdateWithoutItemInput>
  }

  export type ItemCampaignUpdateManyWithWhereWithoutItemInput = {
    where: ItemCampaignScalarWhereInput
    data: XOR<ItemCampaignUpdateManyMutationInput, ItemCampaignUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemLocationUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemLocationWhereUniqueInput
    update: XOR<ItemLocationUpdateWithoutItemInput, ItemLocationUncheckedUpdateWithoutItemInput>
    create: XOR<ItemLocationCreateWithoutItemInput, ItemLocationUncheckedCreateWithoutItemInput>
  }

  export type ItemLocationUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemLocationWhereUniqueInput
    data: XOR<ItemLocationUpdateWithoutItemInput, ItemLocationUncheckedUpdateWithoutItemInput>
  }

  export type ItemLocationUpdateManyWithWhereWithoutItemInput = {
    where: ItemLocationScalarWhereInput
    data: XOR<ItemLocationUpdateManyMutationInput, ItemLocationUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemNPCUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemNPCWhereUniqueInput
    update: XOR<ItemNPCUpdateWithoutItemInput, ItemNPCUncheckedUpdateWithoutItemInput>
    create: XOR<ItemNPCCreateWithoutItemInput, ItemNPCUncheckedCreateWithoutItemInput>
  }

  export type ItemNPCUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemNPCWhereUniqueInput
    data: XOR<ItemNPCUpdateWithoutItemInput, ItemNPCUncheckedUpdateWithoutItemInput>
  }

  export type ItemNPCUpdateManyWithWhereWithoutItemInput = {
    where: ItemNPCScalarWhereInput
    data: XOR<ItemNPCUpdateManyMutationInput, ItemNPCUncheckedUpdateManyWithoutItemInput>
  }

  export type InteractionItemUpsertWithWhereUniqueWithoutItemInput = {
    where: InteractionItemWhereUniqueInput
    update: XOR<InteractionItemUpdateWithoutItemInput, InteractionItemUncheckedUpdateWithoutItemInput>
    create: XOR<InteractionItemCreateWithoutItemInput, InteractionItemUncheckedCreateWithoutItemInput>
  }

  export type InteractionItemUpdateWithWhereUniqueWithoutItemInput = {
    where: InteractionItemWhereUniqueInput
    data: XOR<InteractionItemUpdateWithoutItemInput, InteractionItemUncheckedUpdateWithoutItemInput>
  }

  export type InteractionItemUpdateManyWithWhereWithoutItemInput = {
    where: InteractionItemScalarWhereInput
    data: XOR<InteractionItemUpdateManyMutationInput, InteractionItemUncheckedUpdateManyWithoutItemInput>
  }

  export type InteractionItemScalarWhereInput = {
    AND?: InteractionItemScalarWhereInput | InteractionItemScalarWhereInput[]
    OR?: InteractionItemScalarWhereInput[]
    NOT?: InteractionItemScalarWhereInput | InteractionItemScalarWhereInput[]
    interactionId?: StringFilter<"InteractionItem"> | string
    itemId?: StringFilter<"InteractionItem"> | string
    transactionType?: EnumTransactionTypeFilter<"InteractionItem"> | $Enums.TransactionType
  }

  export type CampaignCreateWithoutChroniclesInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutChroniclesInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutChroniclesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutChroniclesInput, CampaignUncheckedCreateWithoutChroniclesInput>
  }

  export type ChronicleQuestCreateWithoutChronicleInput = {
    statusChange: string
    quest: QuestCreateNestedOneWithoutChroniclesInput
  }

  export type ChronicleQuestUncheckedCreateWithoutChronicleInput = {
    questId: string
    statusChange: string
  }

  export type ChronicleQuestCreateOrConnectWithoutChronicleInput = {
    where: ChronicleQuestWhereUniqueInput
    create: XOR<ChronicleQuestCreateWithoutChronicleInput, ChronicleQuestUncheckedCreateWithoutChronicleInput>
  }

  export type ChronicleQuestCreateManyChronicleInputEnvelope = {
    data: ChronicleQuestCreateManyChronicleInput | ChronicleQuestCreateManyChronicleInput[]
  }

  export type CampaignUpsertWithoutChroniclesInput = {
    update: XOR<CampaignUpdateWithoutChroniclesInput, CampaignUncheckedUpdateWithoutChroniclesInput>
    create: XOR<CampaignCreateWithoutChroniclesInput, CampaignUncheckedCreateWithoutChroniclesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutChroniclesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutChroniclesInput, CampaignUncheckedUpdateWithoutChroniclesInput>
  }

  export type CampaignUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ChronicleQuestUpsertWithWhereUniqueWithoutChronicleInput = {
    where: ChronicleQuestWhereUniqueInput
    update: XOR<ChronicleQuestUpdateWithoutChronicleInput, ChronicleQuestUncheckedUpdateWithoutChronicleInput>
    create: XOR<ChronicleQuestCreateWithoutChronicleInput, ChronicleQuestUncheckedCreateWithoutChronicleInput>
  }

  export type ChronicleQuestUpdateWithWhereUniqueWithoutChronicleInput = {
    where: ChronicleQuestWhereUniqueInput
    data: XOR<ChronicleQuestUpdateWithoutChronicleInput, ChronicleQuestUncheckedUpdateWithoutChronicleInput>
  }

  export type ChronicleQuestUpdateManyWithWhereWithoutChronicleInput = {
    where: ChronicleQuestScalarWhereInput
    data: XOR<ChronicleQuestUpdateManyMutationInput, ChronicleQuestUncheckedUpdateManyWithoutChronicleInput>
  }

  export type CampaignCreateWithoutInteractionsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutInteractionsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutInteractionsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutInteractionsInput, CampaignUncheckedCreateWithoutInteractionsInput>
  }

  export type NPCCreateWithoutInteractionsInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutNpcsInput
    locations?: NPCLocationCreateNestedManyWithoutNpcInput
    questsGiven?: QuestCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCCreateNestedManyWithoutNpcInput
    items?: ItemNPCCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutInteractionsInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationUncheckedCreateNestedManyWithoutNpcInput
    questsGiven?: QuestUncheckedCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCUncheckedCreateNestedManyWithoutNpcInput
    items?: ItemNPCUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutInteractionsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutInteractionsInput, NPCUncheckedCreateWithoutInteractionsInput>
  }

  export type InteractionItemCreateWithoutInteractionInput = {
    transactionType: $Enums.TransactionType
    item: ItemCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionItemUncheckedCreateWithoutInteractionInput = {
    itemId: string
    transactionType: $Enums.TransactionType
  }

  export type InteractionItemCreateOrConnectWithoutInteractionInput = {
    where: InteractionItemWhereUniqueInput
    create: XOR<InteractionItemCreateWithoutInteractionInput, InteractionItemUncheckedCreateWithoutInteractionInput>
  }

  export type InteractionItemCreateManyInteractionInputEnvelope = {
    data: InteractionItemCreateManyInteractionInput | InteractionItemCreateManyInteractionInput[]
  }

  export type CampaignUpsertWithoutInteractionsInput = {
    update: XOR<CampaignUpdateWithoutInteractionsInput, CampaignUncheckedUpdateWithoutInteractionsInput>
    create: XOR<CampaignCreateWithoutInteractionsInput, CampaignUncheckedCreateWithoutInteractionsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutInteractionsInput, CampaignUncheckedUpdateWithoutInteractionsInput>
  }

  export type CampaignUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type NPCUpsertWithoutInteractionsInput = {
    update: XOR<NPCUpdateWithoutInteractionsInput, NPCUncheckedUpdateWithoutInteractionsInput>
    create: XOR<NPCCreateWithoutInteractionsInput, NPCUncheckedCreateWithoutInteractionsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutInteractionsInput, NPCUncheckedUpdateWithoutInteractionsInput>
  }

  export type NPCUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutNpcsNestedInput
    locations?: NPCLocationUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUncheckedUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUncheckedUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUncheckedUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type InteractionItemUpsertWithWhereUniqueWithoutInteractionInput = {
    where: InteractionItemWhereUniqueInput
    update: XOR<InteractionItemUpdateWithoutInteractionInput, InteractionItemUncheckedUpdateWithoutInteractionInput>
    create: XOR<InteractionItemCreateWithoutInteractionInput, InteractionItemUncheckedCreateWithoutInteractionInput>
  }

  export type InteractionItemUpdateWithWhereUniqueWithoutInteractionInput = {
    where: InteractionItemWhereUniqueInput
    data: XOR<InteractionItemUpdateWithoutInteractionInput, InteractionItemUncheckedUpdateWithoutInteractionInput>
  }

  export type InteractionItemUpdateManyWithWhereWithoutInteractionInput = {
    where: InteractionItemScalarWhereInput
    data: XOR<InteractionItemUpdateManyMutationInput, InteractionItemUncheckedUpdateManyWithoutInteractionInput>
  }

  export type MonsterCreateWithoutCampaignsInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    encounterParticipants?: EncounterParticipantCreateNestedManyWithoutMonsterInput
  }

  export type MonsterUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    size: $Enums.Size
    creatureType: $Enums.CreatureType
    alignment: $Enums.Alignment
    portraitPath?: string | null
    hpMax: number
    hpDice?: string | null
    ac: number
    acDescription?: string | null
    speed: JsonNullValueInput | InputJsonValue
    abilities: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating: number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    dmNotes?: string | null
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    encounterParticipants?: EncounterParticipantUncheckedCreateNestedManyWithoutMonsterInput
  }

  export type MonsterCreateOrConnectWithoutCampaignsInput = {
    where: MonsterWhereUniqueInput
    create: XOR<MonsterCreateWithoutCampaignsInput, MonsterUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignCreateWithoutMonsterCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMonsterCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    itemCampaigns?: ItemCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMonsterCampaignsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMonsterCampaignsInput, CampaignUncheckedCreateWithoutMonsterCampaignsInput>
  }

  export type MonsterUpsertWithoutCampaignsInput = {
    update: XOR<MonsterUpdateWithoutCampaignsInput, MonsterUncheckedUpdateWithoutCampaignsInput>
    create: XOR<MonsterCreateWithoutCampaignsInput, MonsterUncheckedCreateWithoutCampaignsInput>
    where?: MonsterWhereInput
  }

  export type MonsterUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: MonsterWhereInput
    data: XOR<MonsterUpdateWithoutCampaignsInput, MonsterUncheckedUpdateWithoutCampaignsInput>
  }

  export type MonsterUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterParticipants?: EncounterParticipantUpdateManyWithoutMonsterNestedInput
  }

  export type MonsterUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    size?: EnumSizeFieldUpdateOperationsInput | $Enums.Size
    creatureType?: EnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    hpDice?: NullableStringFieldUpdateOperationsInput | string | null
    ac?: IntFieldUpdateOperationsInput | number
    acDescription?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: JsonNullValueInput | InputJsonValue
    abilities?: JsonNullValueInput | InputJsonValue
    savingThrows?: NullableJsonNullValueInput | InputJsonValue
    skills?: NullableJsonNullValueInput | InputJsonValue
    damageResistances?: NullableJsonNullValueInput | InputJsonValue
    damageImmunities?: NullableJsonNullValueInput | InputJsonValue
    conditionImmunities?: NullableJsonNullValueInput | InputJsonValue
    senses?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    challengeRating?: FloatFieldUpdateOperationsInput | number
    actions?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    legendaryActions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterParticipants?: EncounterParticipantUncheckedUpdateManyWithoutMonsterNestedInput
  }

  export type CampaignUpsertWithoutMonsterCampaignsInput = {
    update: XOR<CampaignUpdateWithoutMonsterCampaignsInput, CampaignUncheckedUpdateWithoutMonsterCampaignsInput>
    create: XOR<CampaignCreateWithoutMonsterCampaignsInput, CampaignUncheckedCreateWithoutMonsterCampaignsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMonsterCampaignsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMonsterCampaignsInput, CampaignUncheckedUpdateWithoutMonsterCampaignsInput>
  }

  export type CampaignUpdateWithoutMonsterCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMonsterCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    itemCampaigns?: ItemCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ItemCreateWithoutCampaignsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    locations?: ItemLocationCreateNestedManyWithoutItemInput
    npcs?: ItemNPCCreateNestedManyWithoutItemInput
    interactions?: InteractionItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    npcs?: ItemNPCUncheckedCreateNestedManyWithoutItemInput
    interactions?: InteractionItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCampaignsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCampaignsInput, ItemUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignCreateWithoutItemCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCCreateNestedManyWithoutCampaignInput
    locations?: LocationCreateNestedManyWithoutCampaignInput
    maps?: MapCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterCreateNestedManyWithoutCampaignInput
    quests?: QuestCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleCreateNestedManyWithoutCampaignInput
    interactions?: InteractionCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutItemCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    coverImagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastPlayedAt?: Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedCreateNestedManyWithoutCampaignInput
    locations?: LocationUncheckedCreateNestedManyWithoutCampaignInput
    maps?: MapUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    playerCharacters?: PlayerCharacterUncheckedCreateNestedManyWithoutCampaignInput
    quests?: QuestUncheckedCreateNestedManyWithoutCampaignInput
    chronicles?: ChronicleUncheckedCreateNestedManyWithoutCampaignInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutCampaignInput
    monsterCampaigns?: MonsterCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutItemCampaignsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutItemCampaignsInput, CampaignUncheckedCreateWithoutItemCampaignsInput>
  }

  export type ItemUpsertWithoutCampaignsInput = {
    update: XOR<ItemUpdateWithoutCampaignsInput, ItemUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ItemCreateWithoutCampaignsInput, ItemUncheckedCreateWithoutCampaignsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutCampaignsInput, ItemUncheckedUpdateWithoutCampaignsInput>
  }

  export type ItemUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: ItemLocationUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUncheckedUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CampaignUpsertWithoutItemCampaignsInput = {
    update: XOR<CampaignUpdateWithoutItemCampaignsInput, CampaignUncheckedUpdateWithoutItemCampaignsInput>
    create: XOR<CampaignCreateWithoutItemCampaignsInput, CampaignUncheckedCreateWithoutItemCampaignsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutItemCampaignsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutItemCampaignsInput, CampaignUncheckedUpdateWithoutItemCampaignsInput>
  }

  export type CampaignUpdateWithoutItemCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUpdateManyWithoutCampaignNestedInput
    locations?: LocationUpdateManyWithoutCampaignNestedInput
    maps?: MapUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUpdateManyWithoutCampaignNestedInput
    quests?: QuestUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutItemCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NPCUncheckedUpdateManyWithoutCampaignNestedInput
    locations?: LocationUncheckedUpdateManyWithoutCampaignNestedInput
    maps?: MapUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    playerCharacters?: PlayerCharacterUncheckedUpdateManyWithoutCampaignNestedInput
    quests?: QuestUncheckedUpdateManyWithoutCampaignNestedInput
    chronicles?: ChronicleUncheckedUpdateManyWithoutCampaignNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutCampaignNestedInput
    monsterCampaigns?: MonsterCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type NPCCreateWithoutLocationsInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutNpcsInput
    questsGiven?: QuestCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCCreateNestedManyWithoutNpcInput
    interactions?: InteractionCreateNestedManyWithoutNpcInput
    items?: ItemNPCCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutLocationsInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questsGiven?: QuestUncheckedCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCUncheckedCreateNestedManyWithoutNpcInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutNpcInput
    items?: ItemNPCUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutLocationsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutLocationsInput, NPCUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutNpcsInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutNpcsInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutNpcsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutNpcsInput, LocationUncheckedCreateWithoutNpcsInput>
  }

  export type NPCUpsertWithoutLocationsInput = {
    update: XOR<NPCUpdateWithoutLocationsInput, NPCUncheckedUpdateWithoutLocationsInput>
    create: XOR<NPCCreateWithoutLocationsInput, NPCUncheckedCreateWithoutLocationsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutLocationsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutLocationsInput, NPCUncheckedUpdateWithoutLocationsInput>
  }

  export type NPCUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutNpcsNestedInput
    questsGiven?: QuestUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questsGiven?: QuestUncheckedUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUncheckedUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type LocationUpsertWithoutNpcsInput = {
    update: XOR<LocationUpdateWithoutNpcsInput, LocationUncheckedUpdateWithoutNpcsInput>
    create: XOR<LocationCreateWithoutNpcsInput, LocationUncheckedCreateWithoutNpcsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutNpcsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutNpcsInput, LocationUncheckedUpdateWithoutNpcsInput>
  }

  export type LocationUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type QuestCreateWithoutNpcsInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutNpcsInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutNpcsInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutNpcsInput, QuestUncheckedCreateWithoutNpcsInput>
  }

  export type NPCCreateWithoutQuestsInvolvedInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutNpcsInput
    locations?: NPCLocationCreateNestedManyWithoutNpcInput
    questsGiven?: QuestCreateNestedManyWithoutQuestGiverInput
    interactions?: InteractionCreateNestedManyWithoutNpcInput
    items?: ItemNPCCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutQuestsInvolvedInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationUncheckedCreateNestedManyWithoutNpcInput
    questsGiven?: QuestUncheckedCreateNestedManyWithoutQuestGiverInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutNpcInput
    items?: ItemNPCUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutQuestsInvolvedInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutQuestsInvolvedInput, NPCUncheckedCreateWithoutQuestsInvolvedInput>
  }

  export type QuestUpsertWithoutNpcsInput = {
    update: XOR<QuestUpdateWithoutNpcsInput, QuestUncheckedUpdateWithoutNpcsInput>
    create: XOR<QuestCreateWithoutNpcsInput, QuestUncheckedCreateWithoutNpcsInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutNpcsInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutNpcsInput, QuestUncheckedUpdateWithoutNpcsInput>
  }

  export type QuestUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type NPCUpsertWithoutQuestsInvolvedInput = {
    update: XOR<NPCUpdateWithoutQuestsInvolvedInput, NPCUncheckedUpdateWithoutQuestsInvolvedInput>
    create: XOR<NPCCreateWithoutQuestsInvolvedInput, NPCUncheckedCreateWithoutQuestsInvolvedInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutQuestsInvolvedInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutQuestsInvolvedInput, NPCUncheckedUpdateWithoutQuestsInvolvedInput>
  }

  export type NPCUpdateWithoutQuestsInvolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutNpcsNestedInput
    locations?: NPCLocationUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUpdateManyWithoutQuestGiverNestedInput
    interactions?: InteractionUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutQuestsInvolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUncheckedUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUncheckedUpdateManyWithoutQuestGiverNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type QuestCreateWithoutLocationsInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutLocationsInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    chronicles?: ChronicleQuestUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutLocationsInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutLocationsInput, QuestUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutQuestsInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    items?: ItemLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutQuestsInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    items?: ItemLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutQuestsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutQuestsInput, LocationUncheckedCreateWithoutQuestsInput>
  }

  export type QuestUpsertWithoutLocationsInput = {
    update: XOR<QuestUpdateWithoutLocationsInput, QuestUncheckedUpdateWithoutLocationsInput>
    create: XOR<QuestCreateWithoutLocationsInput, QuestUncheckedCreateWithoutLocationsInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutLocationsInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutLocationsInput, QuestUncheckedUpdateWithoutLocationsInput>
  }

  export type QuestUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type LocationUpsertWithoutQuestsInput = {
    update: XOR<LocationUpdateWithoutQuestsInput, LocationUncheckedUpdateWithoutQuestsInput>
    create: XOR<LocationCreateWithoutQuestsInput, LocationUncheckedCreateWithoutQuestsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutQuestsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutQuestsInput, LocationUncheckedUpdateWithoutQuestsInput>
  }

  export type LocationUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ChronicleCreateWithoutQuestsInput = {
    id?: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutChroniclesInput
  }

  export type ChronicleUncheckedCreateWithoutQuestsInput = {
    id?: string
    campaignId: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChronicleCreateOrConnectWithoutQuestsInput = {
    where: ChronicleWhereUniqueInput
    create: XOR<ChronicleCreateWithoutQuestsInput, ChronicleUncheckedCreateWithoutQuestsInput>
  }

  export type QuestCreateWithoutChroniclesInput = {
    id?: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutQuestsInput
    parentQuest?: QuestCreateNestedOneWithoutSubQuestsInput
    subQuests?: QuestCreateNestedManyWithoutParentQuestInput
    questGiver?: NPCCreateNestedOneWithoutQuestsGivenInput
    npcs?: QuestNPCCreateNestedManyWithoutQuestInput
    locations?: QuestLocationCreateNestedManyWithoutQuestInput
  }

  export type QuestUncheckedCreateWithoutChroniclesInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    subQuests?: QuestUncheckedCreateNestedManyWithoutParentQuestInput
    npcs?: QuestNPCUncheckedCreateNestedManyWithoutQuestInput
    locations?: QuestLocationUncheckedCreateNestedManyWithoutQuestInput
  }

  export type QuestCreateOrConnectWithoutChroniclesInput = {
    where: QuestWhereUniqueInput
    create: XOR<QuestCreateWithoutChroniclesInput, QuestUncheckedCreateWithoutChroniclesInput>
  }

  export type ChronicleUpsertWithoutQuestsInput = {
    update: XOR<ChronicleUpdateWithoutQuestsInput, ChronicleUncheckedUpdateWithoutQuestsInput>
    create: XOR<ChronicleCreateWithoutQuestsInput, ChronicleUncheckedCreateWithoutQuestsInput>
    where?: ChronicleWhereInput
  }

  export type ChronicleUpdateToOneWithWhereWithoutQuestsInput = {
    where?: ChronicleWhereInput
    data: XOR<ChronicleUpdateWithoutQuestsInput, ChronicleUncheckedUpdateWithoutQuestsInput>
  }

  export type ChronicleUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutChroniclesNestedInput
  }

  export type ChronicleUncheckedUpdateWithoutQuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUpsertWithoutChroniclesInput = {
    update: XOR<QuestUpdateWithoutChroniclesInput, QuestUncheckedUpdateWithoutChroniclesInput>
    create: XOR<QuestCreateWithoutChroniclesInput, QuestUncheckedCreateWithoutChroniclesInput>
    where?: QuestWhereInput
  }

  export type QuestUpdateToOneWithWhereWithoutChroniclesInput = {
    where?: QuestWhereInput
    data: XOR<QuestUpdateWithoutChroniclesInput, QuestUncheckedUpdateWithoutChroniclesInput>
  }

  export type QuestUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type ItemCreateWithoutLocationsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignCreateNestedManyWithoutItemInput
    npcs?: ItemNPCCreateNestedManyWithoutItemInput
    interactions?: InteractionItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignUncheckedCreateNestedManyWithoutItemInput
    npcs?: ItemNPCUncheckedCreateNestedManyWithoutItemInput
    interactions?: InteractionItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutLocationsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutLocationsInput, ItemUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutItemsInput = {
    id?: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLocationsInput
    parentLocation?: LocationCreateNestedOneWithoutChildLocationsInput
    childLocations?: LocationCreateNestedManyWithoutParentLocationInput
    maps?: MapCreateNestedManyWithoutLocationInput
    encounters?: EncounterCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationCreateNestedManyWithoutLocationInput
    quests?: QuestLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutItemsInput = {
    id?: string
    campaignId: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childLocations?: LocationUncheckedCreateNestedManyWithoutParentLocationInput
    maps?: MapUncheckedCreateNestedManyWithoutLocationInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocationInput
    npcs?: NPCLocationUncheckedCreateNestedManyWithoutLocationInput
    quests?: QuestLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutItemsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutItemsInput, LocationUncheckedCreateWithoutItemsInput>
  }

  export type ItemUpsertWithoutLocationsInput = {
    update: XOR<ItemUpdateWithoutLocationsInput, ItemUncheckedUpdateWithoutLocationsInput>
    create: XOR<ItemCreateWithoutLocationsInput, ItemUncheckedCreateWithoutLocationsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutLocationsInput, ItemUncheckedUpdateWithoutLocationsInput>
  }

  export type ItemUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUncheckedUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUncheckedUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type LocationUpsertWithoutItemsInput = {
    update: XOR<LocationUpdateWithoutItemsInput, LocationUncheckedUpdateWithoutItemsInput>
    create: XOR<LocationCreateWithoutItemsInput, LocationUncheckedCreateWithoutItemsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutItemsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutItemsInput, LocationUncheckedUpdateWithoutItemsInput>
  }

  export type LocationUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ItemCreateWithoutNpcsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignCreateNestedManyWithoutItemInput
    locations?: ItemLocationCreateNestedManyWithoutItemInput
    interactions?: InteractionItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutNpcsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignUncheckedCreateNestedManyWithoutItemInput
    locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    interactions?: InteractionItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutNpcsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutNpcsInput, ItemUncheckedCreateWithoutNpcsInput>
  }

  export type NPCCreateWithoutItemsInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutNpcsInput
    locations?: NPCLocationCreateNestedManyWithoutNpcInput
    questsGiven?: QuestCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCCreateNestedManyWithoutNpcInput
    interactions?: InteractionCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutItemsInput = {
    id?: string
    campaignId: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: NPCLocationUncheckedCreateNestedManyWithoutNpcInput
    questsGiven?: QuestUncheckedCreateNestedManyWithoutQuestGiverInput
    questsInvolved?: QuestNPCUncheckedCreateNestedManyWithoutNpcInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutItemsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutItemsInput, NPCUncheckedCreateWithoutItemsInput>
  }

  export type ItemUpsertWithoutNpcsInput = {
    update: XOR<ItemUpdateWithoutNpcsInput, ItemUncheckedUpdateWithoutNpcsInput>
    create: XOR<ItemCreateWithoutNpcsInput, ItemUncheckedCreateWithoutNpcsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutNpcsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutNpcsInput, ItemUncheckedUpdateWithoutNpcsInput>
  }

  export type ItemUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUpdateManyWithoutItemNestedInput
    locations?: ItemLocationUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUncheckedUpdateManyWithoutItemNestedInput
    locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    interactions?: InteractionItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type NPCUpsertWithoutItemsInput = {
    update: XOR<NPCUpdateWithoutItemsInput, NPCUncheckedUpdateWithoutItemsInput>
    create: XOR<NPCCreateWithoutItemsInput, NPCUncheckedCreateWithoutItemsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutItemsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutItemsInput, NPCUncheckedUpdateWithoutItemsInput>
  }

  export type NPCUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutNpcsNestedInput
    locations?: NPCLocationUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUncheckedUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUncheckedUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUncheckedUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type InteractionCreateWithoutItemsInput = {
    id?: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutInteractionsInput
    npc: NPCCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateWithoutItemsInput = {
    id?: string
    campaignId: string
    npcId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutItemsInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutItemsInput, InteractionUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutInteractionsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignCreateNestedManyWithoutItemInput
    locations?: ItemLocationCreateNestedManyWithoutItemInput
    npcs?: ItemNPCCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInteractionsInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    rarity: $Enums.ItemRarity
    description?: string | null
    mechanicalEffects?: string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: string | null
    weight?: number | null
    quantity?: number
    isMagical?: boolean
    attunementRequired?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    campaigns?: ItemCampaignUncheckedCreateNestedManyWithoutItemInput
    locations?: ItemLocationUncheckedCreateNestedManyWithoutItemInput
    npcs?: ItemNPCUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInteractionsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInteractionsInput, ItemUncheckedCreateWithoutInteractionsInput>
  }

  export type InteractionUpsertWithoutItemsInput = {
    update: XOR<InteractionUpdateWithoutItemsInput, InteractionUncheckedUpdateWithoutItemsInput>
    create: XOR<InteractionCreateWithoutItemsInput, InteractionUncheckedCreateWithoutItemsInput>
    where?: InteractionWhereInput
  }

  export type InteractionUpdateToOneWithWhereWithoutItemsInput = {
    where?: InteractionWhereInput
    data: XOR<InteractionUpdateWithoutItemsInput, InteractionUncheckedUpdateWithoutItemsInput>
  }

  export type InteractionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutInteractionsNestedInput
    npc?: NPCUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpsertWithoutInteractionsInput = {
    update: XOR<ItemUpdateWithoutInteractionsInput, ItemUncheckedUpdateWithoutInteractionsInput>
    create: XOR<ItemCreateWithoutInteractionsInput, ItemUncheckedCreateWithoutInteractionsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInteractionsInput, ItemUncheckedUpdateWithoutInteractionsInput>
  }

  export type ItemUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUpdateManyWithoutItemNestedInput
    locations?: ItemLocationUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    rarity?: EnumItemRarityFieldUpdateOperationsInput | $Enums.ItemRarity
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mechanicalEffects?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAbilities?: NullableJsonNullValueInput | InputJsonValue
    value?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    isMagical?: BoolFieldUpdateOperationsInput | boolean
    attunementRequired?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: ItemCampaignUncheckedUpdateManyWithoutItemNestedInput
    locations?: ItemLocationUncheckedUpdateManyWithoutItemNestedInput
    npcs?: ItemNPCUncheckedUpdateManyWithoutItemNestedInput
  }

  export type NPCCreateManyCampaignInput = {
    id?: string
    name: string
    title?: string | null
    race?: $Enums.Race | null
    creatureType?: $Enums.CreatureType | null
    role?: $Enums.NPCRole | null
    class?: $Enums.CharacterClass | null
    alignment?: $Enums.Alignment | null
    attitudeToParty?: $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: string | null
    personality?: string | null
    motivations?: string | null
    backstory?: string | null
    dmNotes?: string | null
    portraitPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateManyCampaignInput = {
    id?: string
    parentLocationId?: string | null
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapCreateManyCampaignInput = {
    id?: string
    locationId?: string | null
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateManyCampaignInput = {
    id?: string
    mapId?: string | null
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type PlayerCharacterCreateManyCampaignInput = {
    id?: string
    playerName: string
    characterName: string
    race: $Enums.Race
    class: $Enums.CharacterClass
    level: number
    alignment: $Enums.Alignment
    backgroundType: $Enums.BackgroundType
    background?: string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: string | null
    hpMax: number
    ac: number
    passivePerception: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestCreateManyCampaignInput = {
    id?: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ChronicleCreateManyCampaignInput = {
    id?: string
    sessionNumber: number
    sessionDate: Date | string
    title?: string | null
    summary?: string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateManyCampaignInput = {
    id?: string
    npcId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
  }

  export type MonsterCampaignCreateManyCampaignInput = {
    monsterId: string
  }

  export type ItemCampaignCreateManyCampaignInput = {
    itemId: string
  }

  export type NPCUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: NPCLocationUncheckedUpdateManyWithoutNpcNestedInput
    questsGiven?: QuestUncheckedUpdateManyWithoutQuestGiverNestedInput
    questsInvolved?: QuestNPCUncheckedUpdateManyWithoutNpcNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutNpcNestedInput
    items?: ItemNPCUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    race?: NullableEnumRaceFieldUpdateOperationsInput | $Enums.Race | null
    creatureType?: NullableEnumCreatureTypeFieldUpdateOperationsInput | $Enums.CreatureType | null
    role?: NullableEnumNPCRoleFieldUpdateOperationsInput | $Enums.NPCRole | null
    class?: NullableEnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass | null
    alignment?: NullableEnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment | null
    attitudeToParty?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    appearance?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    backstory?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentLocation?: LocationUpdateOneWithoutChildLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutMapsNestedInput
    annotations?: MapAnnotationUpdateManyWithoutMapNestedInput
    encounters?: EncounterUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotations?: MapAnnotationUncheckedUpdateManyWithoutMapNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    map?: MapUpdateOneWithoutEncountersNestedInput
    location?: LocationUpdateOneWithoutEncountersNestedInput
    participants?: EncounterParticipantUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: EncounterParticipantUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlayerCharacterUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterParticipants?: EncounterParticipantUpdateManyWithoutPlayerCharacterNestedInput
  }

  export type PlayerCharacterUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterParticipants?: EncounterParticipantUncheckedUpdateManyWithoutPlayerCharacterNestedInput
  }

  export type PlayerCharacterUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    characterName?: StringFieldUpdateOperationsInput | string
    race?: EnumRaceFieldUpdateOperationsInput | $Enums.Race
    class?: EnumCharacterClassFieldUpdateOperationsInput | $Enums.CharacterClass
    level?: IntFieldUpdateOperationsInput | number
    alignment?: EnumAlignmentFieldUpdateOperationsInput | $Enums.Alignment
    backgroundType?: EnumBackgroundTypeFieldUpdateOperationsInput | $Enums.BackgroundType
    background?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: NullableJsonNullValueInput | InputJsonValue
    portraitPath?: NullableStringFieldUpdateOperationsInput | string | null
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    passivePerception?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChronicleUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quests?: ChronicleQuestUpdateManyWithoutChronicleNestedInput
  }

  export type ChronicleUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quests?: ChronicleQuestUncheckedUpdateManyWithoutChronicleNestedInput
  }

  export type ChronicleUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    playerDeeds?: NullableJsonNullValueInput | InputJsonValue
    importantDecisions?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npc?: NPCUpdateOneRequiredWithoutInteractionsNestedInput
    items?: InteractionItemUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InteractionItemUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonsterCampaignUpdateWithoutCampaignInput = {
    monster?: MonsterUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type MonsterCampaignUncheckedUpdateWithoutCampaignInput = {
    monsterId?: StringFieldUpdateOperationsInput | string
  }

  export type MonsterCampaignUncheckedUpdateManyWithoutCampaignInput = {
    monsterId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCampaignUpdateWithoutCampaignInput = {
    item?: ItemUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type ItemCampaignUncheckedUpdateWithoutCampaignInput = {
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCampaignUncheckedUpdateManyWithoutCampaignInput = {
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type NPCLocationCreateManyNpcInput = {
    locationId: string
    isPrimary?: boolean
  }

  export type QuestCreateManyQuestGiverInput = {
    id?: string
    campaignId: string
    parentQuestId?: string | null
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type QuestNPCCreateManyNpcInput = {
    questId: string
    role?: string | null
  }

  export type InteractionCreateManyNpcInput = {
    id?: string
    campaignId: string
    interactionDate: Date | string
    sessionDate: Date | string
    interactionType: $Enums.InteractionType
    summary?: string | null
    details?: string | null
    attitudeChange?: $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: string | null
    createdAt?: Date | string
  }

  export type ItemNPCCreateManyNpcInput = {
    itemId: string
  }

  export type NPCLocationUpdateWithoutNpcInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutNpcsNestedInput
  }

  export type NPCLocationUncheckedUpdateWithoutNpcInput = {
    locationId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NPCLocationUncheckedUpdateManyWithoutNpcInput = {
    locationId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestUpdateWithoutQuestGiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    parentQuest?: QuestUpdateOneWithoutSubQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutQuestGiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateManyWithoutQuestGiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    parentQuestId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestNPCUpdateWithoutNpcInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    quest?: QuestUpdateOneRequiredWithoutNpcsNestedInput
  }

  export type QuestNPCUncheckedUpdateWithoutNpcInput = {
    questId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestNPCUncheckedUpdateManyWithoutNpcInput = {
    questId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InteractionUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutInteractionsNestedInput
    items?: InteractionItemUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InteractionItemUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateManyWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    interactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactionType?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    attitudeChange?: NullableEnumNPCAttitudeFieldUpdateOperationsInput | $Enums.NPCAttitude | null
    involvedPcs?: NullableJsonNullValueInput | InputJsonValue
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemNPCUpdateWithoutNpcInput = {
    item?: ItemUpdateOneRequiredWithoutNpcsNestedInput
  }

  export type ItemNPCUncheckedUpdateWithoutNpcInput = {
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemNPCUncheckedUpdateManyWithoutNpcInput = {
    itemId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateManyParentLocationInput = {
    id?: string
    campaignId: string
    name: string
    type: $Enums.LocationType
    description?: string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: string | null
    dmNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapCreateManyLocationInput = {
    id?: string
    campaignId: string
    name: string
    imagePath: string
    gridSize?: number | null
    gridEnabled?: boolean
    scale?: string | null
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateManyLocationInput = {
    id?: string
    campaignId: string
    mapId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type NPCLocationCreateManyLocationInput = {
    npcId: string
    isPrimary?: boolean
  }

  export type QuestLocationCreateManyLocationInput = {
    questId: string
  }

  export type ItemLocationCreateManyLocationInput = {
    itemId: string
    isHidden?: boolean
    notes?: string | null
  }

  export type LocationUpdateWithoutParentLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLocationsNestedInput
    childLocations?: LocationUpdateManyWithoutParentLocationNestedInput
    maps?: MapUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutParentLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childLocations?: LocationUncheckedUpdateManyWithoutParentLocationNestedInput
    maps?: MapUncheckedUpdateManyWithoutLocationNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutLocationNestedInput
    npcs?: NPCLocationUncheckedUpdateManyWithoutLocationNestedInput
    quests?: QuestLocationUncheckedUpdateManyWithoutLocationNestedInput
    items?: ItemLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutParentLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notableFeatures?: NullableJsonNullValueInput | InputJsonValue
    coverImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMapsNestedInput
    annotations?: MapAnnotationUpdateManyWithoutMapNestedInput
    encounters?: EncounterUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    annotations?: MapAnnotationUncheckedUpdateManyWithoutMapNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutMapNestedInput
  }

  export type MapUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    gridSize?: NullableIntFieldUpdateOperationsInput | number | null
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    scale?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    map?: MapUpdateOneWithoutEncountersNestedInput
    participants?: EncounterParticipantUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: EncounterParticipantUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NPCLocationUpdateWithoutLocationInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    npc?: NPCUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type NPCLocationUncheckedUpdateWithoutLocationInput = {
    npcId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NPCLocationUncheckedUpdateManyWithoutLocationInput = {
    npcId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestLocationUpdateWithoutLocationInput = {
    quest?: QuestUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type QuestLocationUncheckedUpdateWithoutLocationInput = {
    questId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestLocationUncheckedUpdateManyWithoutLocationInput = {
    questId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemLocationUpdateWithoutLocationInput = {
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    item?: ItemUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type ItemLocationUncheckedUpdateWithoutLocationInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemLocationUncheckedUpdateManyWithoutLocationInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MapAnnotationCreateManyMapInput = {
    id?: string
    type: $Enums.MapAnnotationType
    x: number
    y: number
    title?: string | null
    content?: string | null
    isHidden?: boolean
  }

  export type EncounterCreateManyMapInput = {
    id?: string
    campaignId: string
    locationId?: string | null
    name: string
    description?: string | null
    difficulty: $Enums.Difficulty
    status?: $Enums.EncounterStatus
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type MapAnnotationUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MapAnnotationUncheckedUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MapAnnotationUncheckedUpdateManyWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMapAnnotationTypeFieldUpdateOperationsInput | $Enums.MapAnnotationType
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    isHidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    location?: LocationUpdateOneWithoutEncountersNestedInput
    participants?: EncounterParticipantUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: EncounterParticipantUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    status?: EnumEncounterStatusFieldUpdateOperationsInput | $Enums.EncounterStatus
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MonsterCampaignCreateManyMonsterInput = {
    campaignId: string
  }

  export type EncounterParticipantCreateManyMonsterInput = {
    id?: string
    encounterId: string
    participantType: $Enums.ParticipantType
    playerCharacterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type MonsterCampaignUpdateWithoutMonsterInput = {
    campaign?: CampaignUpdateOneRequiredWithoutMonsterCampaignsNestedInput
  }

  export type MonsterCampaignUncheckedUpdateWithoutMonsterInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type MonsterCampaignUncheckedUpdateManyWithoutMonsterInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterParticipantUpdateWithoutMonsterInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutParticipantsNestedInput
    playerCharacter?: PlayerCharacterUpdateOneWithoutEncounterParticipantsNestedInput
  }

  export type EncounterParticipantUncheckedUpdateWithoutMonsterInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    playerCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantUncheckedUpdateManyWithoutMonsterInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    playerCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantCreateManyEncounterInput = {
    id?: string
    participantType: $Enums.ParticipantType
    monsterId?: string | null
    playerCharacterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    monster?: MonsterUpdateOneWithoutEncounterParticipantsNestedInput
    playerCharacter?: PlayerCharacterUpdateOneWithoutEncounterParticipantsNestedInput
  }

  export type EncounterParticipantUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    monsterId?: NullableStringFieldUpdateOperationsInput | string | null
    playerCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    monsterId?: NullableStringFieldUpdateOperationsInput | string | null
    playerCharacterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantCreateManyPlayerCharacterInput = {
    id?: string
    encounterId: string
    participantType: $Enums.ParticipantType
    monsterId?: string | null
    customName?: string | null
    initiative?: number | null
    hpCurrent: number
    hpMax: number
    ac: number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: number | null
    positionY?: number | null
    isVisible?: boolean
    dmNotes?: string | null
  }

  export type EncounterParticipantUpdateWithoutPlayerCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutParticipantsNestedInput
    monster?: MonsterUpdateOneWithoutEncounterParticipantsNestedInput
  }

  export type EncounterParticipantUncheckedUpdateWithoutPlayerCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    monsterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncounterParticipantUncheckedUpdateManyWithoutPlayerCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    monsterId?: NullableStringFieldUpdateOperationsInput | string | null
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    initiative?: NullableIntFieldUpdateOperationsInput | number | null
    hpCurrent?: IntFieldUpdateOperationsInput | number
    hpMax?: IntFieldUpdateOperationsInput | number
    ac?: IntFieldUpdateOperationsInput | number
    conditions?: NullableJsonNullValueInput | InputJsonValue
    positionX?: NullableFloatFieldUpdateOperationsInput | number | null
    positionY?: NullableFloatFieldUpdateOperationsInput | number | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestCreateManyParentQuestInput = {
    id?: string
    campaignId: string
    name: string
    description?: string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.QuestStatus
    questGiverNpcId?: string | null
    rewardDescription?: string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: boolean
    dmNotes?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type QuestNPCCreateManyQuestInput = {
    npcId: string
    role?: string | null
  }

  export type QuestLocationCreateManyQuestInput = {
    locationId: string
  }

  export type ChronicleQuestCreateManyQuestInput = {
    chronicleId: string
    statusChange: string
  }

  export type QuestUpdateWithoutParentQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutQuestsNestedInput
    subQuests?: QuestUpdateManyWithoutParentQuestNestedInput
    questGiver?: NPCUpdateOneWithoutQuestsGivenNestedInput
    npcs?: QuestNPCUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateWithoutParentQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subQuests?: QuestUncheckedUpdateManyWithoutParentQuestNestedInput
    npcs?: QuestNPCUncheckedUpdateManyWithoutQuestNestedInput
    locations?: QuestLocationUncheckedUpdateManyWithoutQuestNestedInput
    chronicles?: ChronicleQuestUncheckedUpdateManyWithoutQuestNestedInput
  }

  export type QuestUncheckedUpdateManyWithoutParentQuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objectives?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumQuestStatusFieldUpdateOperationsInput | $Enums.QuestStatus
    questGiverNpcId?: NullableStringFieldUpdateOperationsInput | string | null
    rewardDescription?: NullableStringFieldUpdateOperationsInput | string | null
    rewardItems?: NullableJsonNullValueInput | InputJsonValue
    isMilestone?: BoolFieldUpdateOperationsInput | boolean
    dmNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestNPCUpdateWithoutQuestInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    npc?: NPCUpdateOneRequiredWithoutQuestsInvolvedNestedInput
  }

  export type QuestNPCUncheckedUpdateWithoutQuestInput = {
    npcId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestNPCUncheckedUpdateManyWithoutQuestInput = {
    npcId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestLocationUpdateWithoutQuestInput = {
    location?: LocationUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type QuestLocationUncheckedUpdateWithoutQuestInput = {
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestLocationUncheckedUpdateManyWithoutQuestInput = {
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type ChronicleQuestUpdateWithoutQuestInput = {
    statusChange?: StringFieldUpdateOperationsInput | string
    chronicle?: ChronicleUpdateOneRequiredWithoutQuestsNestedInput
  }

  export type ChronicleQuestUncheckedUpdateWithoutQuestInput = {
    chronicleId?: StringFieldUpdateOperationsInput | string
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type ChronicleQuestUncheckedUpdateManyWithoutQuestInput = {
    chronicleId?: StringFieldUpdateOperationsInput | string
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCampaignCreateManyItemInput = {
    campaignId: string
  }

  export type ItemLocationCreateManyItemInput = {
    locationId: string
    isHidden?: boolean
    notes?: string | null
  }

  export type ItemNPCCreateManyItemInput = {
    npcId: string
  }

  export type InteractionItemCreateManyItemInput = {
    interactionId: string
    transactionType: $Enums.TransactionType
  }

  export type ItemCampaignUpdateWithoutItemInput = {
    campaign?: CampaignUpdateOneRequiredWithoutItemCampaignsNestedInput
  }

  export type ItemCampaignUncheckedUpdateWithoutItemInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCampaignUncheckedUpdateManyWithoutItemInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemLocationUpdateWithoutItemInput = {
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemLocationUncheckedUpdateWithoutItemInput = {
    locationId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemLocationUncheckedUpdateManyWithoutItemInput = {
    locationId?: StringFieldUpdateOperationsInput | string
    isHidden?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemNPCUpdateWithoutItemInput = {
    npc?: NPCUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ItemNPCUncheckedUpdateWithoutItemInput = {
    npcId?: StringFieldUpdateOperationsInput | string
  }

  export type ItemNPCUncheckedUpdateManyWithoutItemInput = {
    npcId?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionItemUpdateWithoutItemInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    interaction?: InteractionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InteractionItemUncheckedUpdateWithoutItemInput = {
    interactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type InteractionItemUncheckedUpdateManyWithoutItemInput = {
    interactionId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type ChronicleQuestCreateManyChronicleInput = {
    questId: string
    statusChange: string
  }

  export type ChronicleQuestUpdateWithoutChronicleInput = {
    statusChange?: StringFieldUpdateOperationsInput | string
    quest?: QuestUpdateOneRequiredWithoutChroniclesNestedInput
  }

  export type ChronicleQuestUncheckedUpdateWithoutChronicleInput = {
    questId?: StringFieldUpdateOperationsInput | string
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type ChronicleQuestUncheckedUpdateManyWithoutChronicleInput = {
    questId?: StringFieldUpdateOperationsInput | string
    statusChange?: StringFieldUpdateOperationsInput | string
  }

  export type InteractionItemCreateManyInteractionInput = {
    itemId: string
    transactionType: $Enums.TransactionType
  }

  export type InteractionItemUpdateWithoutInteractionInput = {
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    item?: ItemUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionItemUncheckedUpdateWithoutInteractionInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }

  export type InteractionItemUncheckedUpdateManyWithoutInteractionInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}